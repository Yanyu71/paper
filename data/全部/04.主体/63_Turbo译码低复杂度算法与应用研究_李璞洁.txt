第一章绪论
1.1	研究背景及意义
1.1.1	信道编码理论的发展
通信系统力求做到使信息有效而可靠地进行传输，但是实际物理信道的传输 条件并不能总是保证系统达到可靠传输的要求。信号传输过程中，由于非理想的 信道条件和过大的噪声干扰，会造成信号传输过程中出现误码，这种错误一般使 用BER,即误比特率来衡量。为了能使通信系统可靠传输，通常会采用一些方法 抵御信号传输中的干扰，比如，对通信系统进行扩频降低系统的误比特率；或者 增大系统发送功率、选取更适应系统的调制、解调方式，以此提高信噪比进而降 低系统误比特率；另一种思路即为采用信道均衡等算法，增强系统抗干扰能力。
但是上述方法的实施有时也不能完全符合对于信通系统误码性能的要求，对 高可靠性通信的需求不断促进着信道编码理论的发展。信道编码又被称为差错控 制编码，是所有现代通信系统可靠性的保障。信道编码的基本思想就是在发射端 对原始数据添加一部分冗余信息，且该冗余信息与原始数据存在一定的相关性。 添加冗余信息进行数据传输是纠错码的主要思想，信道编码的本质就是利用这个 冗余信息对抗传输过程中的干扰。
贝尔实验室的Claude E.Shannon在1948年发表了一篇对通信理论发展极 为重要的论文《通信的数学理论》0] (A Mathematical Theory of Communication), 这篇论文的发表标志着信息与编码理论学科的创立。根据Shannon所提出的信道 编码理论：对于一个给定的有噪信道，存在一个确定的信道容量C,如果信道的 信息传输速率R<C, 一定存在一种编码方式，使得接收端译码错误率任意低。 香农理论的提出使得实现通信可靠传输有了理论依据，但是香农并没有给出具体 的实现方案。后人根据香农提出的学说不断进行探索，使得信道编码理论不断发 展和完善。
1949年，R.Hamming和M.Golay提出了第一个实用的差错控制编码方案 ⑵。这种编码方案以4个输入比特为一组将输入数据分为若干组，然后通过计算 这些信息比特的线性组合来得到3个校验比特，将二者串接起来，再将7比特的 码字送入译码器进行译码。计算机按照编码方案对码字进行解析，除了能够验证 码字传输是否有误，还可以定位比特错误的位置，从而能够纠正该错误码字。分 组码的编码思路即是如此，汉明码也由此诞生。汉明码⑶的提出是信道编码理论 的又一项重大突破，但是汉明码本身也存在一定的问题。如，汉明码的编码效率 较低，传输4个信息比特需要3个校验位进行校验，且只能纠正单个比特的错
1
误。
1955年，Elias提出的卷积码⑷使得信道编码理论得到了进一步发展，与分 组码相比，卷积码对各信息比特的相关性利用得更加极致。卷积码通常表示为 （n,k,m） , k表示输入信息比特数量，n表示编码器输出比特个数，m表示卷积 码内部寄存器数量。在卷积码的译码过程中，不仅要从当前码字得到信息、，还要 结合以前输入码字的信息进行联合译码。
20世纪60年代到20世纪70年代，纠错码又一次迎来了快速发展的黄 金时期，各种编码理论不断发展和完善，软判决技术的提出使得信道编译码技术 迎来了又一次技术飞跃。1961年，J.Wozencraft和B.Reiffen提出了序列译码⑸ 方案，旨在对卷积译码方案不能适用于较大约束长度的弊端进行改良。1967年， Viterbi提出了著名的网格译码算法，即Viterbi译码算法⑹。
随着Viterbi译码算法的提出，卷积码在通信系统中得到了巨大青睐，卷积 码被各种通信标准采用，如GSM, IS-95 CDMA, 3G等。这一时期另一个重要的 飞跃是级联码思想的出现，Forney在1966年提出了级联码⑺，通过内码和外码 级联的方法能够在降低实现复杂度的同时获得接近信道容量的性能。
1.1.2	Turbo译码器的研究现状
在Viterbi译码算法提出后，卷积码在通信系统中的发展异常迅猛，但是， Viterbi译码算法的译码复杂度始终制约着卷积码的发展。尽管在后来的研究中， 人们基于分组码，卷积码等基本编码方式对维特比译码做了许多简化处理，但这 些译码算法均因随寄存器数量指数增长的译码复杂度而变得高不可攀，难以适应 更加复杂的编码需求。为了提高译码效率在实际工程应用时不得不在译码复杂度 可接受的范围内进行编码，所以其增益与香农极限一直有2dB以上的差距。
1993年，在日内瓦召开的IEEE通信国际会议上，C.Berrou和A.Glavieux提 出了一种基于并行级联卷积码的Turbo码，一经提出便在信道编码理论的研究中 获得了巨大反响。Turbo码编码器将两个分量码并行级联，并利用交织器将第二 个分量码的输入码字顺序打乱构造出一种具有伪随机特性的长码。随后将两个译 码器的输出信息进行多次迭代，从而达到最优译码性能0包。
自从Turbo码被提出后，因其强大的性能优势及译码复杂度较低等优点，对 Turbo译码器的研究日益深入，许多优秀的成果被快速应用到通信系统中，这也 从另一方面极大促进了 Turbo译码算法的发展。在译码方式上，Turbo码主要有 两大类方案，一种是基于维特比（Viterbi）译码的SOVA （软输出维特比译码） 算法，另一种是BCJR算法⑻。BCJR算法是由Bahl、Cocke、Jelinek和Raviv四 人于1974年提出，这一算法对Turbo码网的发展起到了巨大的推动作用。在两
2
种算法中，BCJR算法是当今Turbo译码器应用的主流算法，BCJR算法包括基 于最大后验概率的MAP算法，和对其进行简化计算的Log-MAP算法及Max-Log-MAP算法。但是这些基于BCJR算法的Turbo译码方案在计算复杂度上要 远高于SOVA算法，且无论信噪比高低，译码复杂度始终保持一致，并不能有效 利用高信噪比的有利条件。因此本论文主要研究基于SOVA译码算法的简化算 法，以期在译码性能相差不大的情况下，在高信噪比条件下降低译码复杂度。
如今Turbo码已经成为应用最为广泛的译码算法之一，在LTE系统中，Turbo 码作为信道译码标准被广泛应用于民用通信中。随着5G的发展，LDPC码口叫 Polar码口I〕等信道编码方案被不断提出并加以完善，但是Turbo码因其具有良好 的性能仍然有着广阔的应用场景。在编码理论上基于咬尾和打孔的Turbo 2.0方 案也值得被深入研究和挖掘，并且在5G标准的提出过程中Turbo2.0方案也显示 出了其译码性能具有较强的竞争力。
1.1.3	CCSDS 应用的 Turbo 码
空间数据系统咨询委员会（CCSDS, Consultative Committee for Space Data System）成立于1982年，主要负责开发和采纳适合于空间通信和数据处理系统 的各种通信协议和数据处理规范，是一家全球合作的国际性空间组织。截止到目 前，该组织共有11个正式会员、28个观察员和140商业合作伙伴，中国国家航 天局（CNSA）,美国国家航空航天管理局（NASA）及日本国家宇宙开发事业团 （NASDA）都是其正式成员。CCSDS推出的一系列建议和技术报告，内容涉及 分组遥测、遥控、射频、调制、遥测信道编码、轨道运行、标准格式化数据单元、 无线电外测和轨道数据等，反映了当前世界空间数据系统的最新技术发展动态［⑸。
Turbo通过迭代译码实现接近香农限的优异性能，但是其迭代译码结构较为 复杂，在实时性要求较高的通信系统中并不适用。相反，对于通信距离较远，传 输时延较大的深空通信系统来讲，Turbo码的高性能具有十分强大的竞争力口支 因此，1999年，CCSDS就将Turbo码加入了遥测信道编码建议书，并一直将其 作为卫星通信和深空通信的信道编码标准，这也说明当前Turbo码仍有非常巨大 的研究价值，其未来的发展仍然非常值得期待。
1.2	论文主要研究内容
本论文主要针对Turbo码的低复杂度译码方案展开研究。当前主流的Turbo 译码方案主要有两种，一种是基于最大后验概率（MAP）的BCJR算法，另一种 是基于维特比（VA）译码的软输出维特比（SOVA）译码算法口21口3］。BCJR算法 是目前应用较为广泛的译码算法，在LTE系统及其他Turbo码的应用中得到大
3
量使用。MAP算法的本质是以符号为单位进行计算，因此得到的译码输出是误 符号率最低的，但是，从码字的角度来看，这种译码方式并不是根据状态转移编 码器可以输出的序列，因此从码字的角度看其并不是最优的方法，也正是因为 MAP算法保留了每个比特的信息、，所以才被广泛应用于Turbo译码。SOVA算 法实际上是Viterbi译码方法的扩展，从所有可行路径中寻找最优解。SOVA算法 保留的路径和状态数有关，它从所有可行路径中找到最优解，其本质上是一种最 大似然（ML）译码方法，但是两者也不是完全不同，当先验概率相等时，最大 似然译码与最大后验概率译码等价。
从译码策略的角度进行分析，BCJR算法主要的译码策略是以广度优先进行 搜索，所以BCJR算法的译码复杂度较高；SOVA算法的主要译码策略是以深度 优先进行搜索，所以在信噪比适宜的情况下，该搜索路径能在更少的操作步骤的 情况下到达译码的终点，这也是本文利用SOVA算法进行Turbo译码的主要原 因。
为了方便计算，对最大后验概率进行对数运算处理,得到了 Log-MAP算法。 为了进一步降低Log-MAP算法的计算复杂度，对该算法进行近似计算，产生了 Max-Log-MAP算法。该算法简化了 Log-MAP中对数计算的过程，将对数查表运 算简化为大小比较运算极大降低了译码复杂度。以Max-Log-MAP为例与SOVA 算法进行算法复杂度比较，Max-Log-MAP算法每一个节点的扩展都需要考虑两 条路径，所以其算法复杂度至少为SOVA算法的一倍。从计算量的角度进行分析 来看，MAP算法需要计算每一个节点的前向分支度量、后向分支度量以及状态 转移度量三个度量值，每一个度量值的计算量都与SOVA分支度量计算量位于 同一数量级，所以，从计算量的角度来看，大致上SOVA算法是BCJR算法的三 分之一。经过上述比较，本论文最终选用SOVA算法进行Turbo译码，并进一步 对SOVA算法进行简化，希望在性能损失可接受的范围内进一步降低译码复杂 度。
论文需要解决的关键技术问题如下：
1	.快速寻找最大似然路径的方法一Lazy Viterbi译码算法。
卷积码的最大似然译码（ML）最常用的方法就是维特比译码，但是利用维 特比译码算法的最大的缺点就是指数型增长的译码时延。对于二进制信息符号译 码，其算法复杂度为0（29，k为编码器内部寄存器长度，这种指数型增长的算 法复杂度，对于软件和硬件算法的实现造成了极大地困难。为了解决以上问题， 2002年，Jon Feldman等人提出Lazy Viterbi译码算法，能够大大降低最大似然 路径选择的算法复杂度，并且能够保证在最坏情况下，译码路径复杂度不会超过 Viterbi译码算法。
2	.削减路径度量值差异较大的分支路径算法——T-SOVA算法。
4
在SOVA(软输入软输出维特比)译码算法中，每个比特的LLR(log-likelihood ratio)取决于最大似然路径和它的竞争路径的最小度量差，本论文主要简化软输 入软输出维特比译码算法的思想是削减最大似然路径和竞争路径之间具有较大 度量差异的分支路径，并且保证其性能损失在可接受的范围内。
3	.在MIMO-SCFDE系统中应用T-SOVA算法。
基于T-SOVA算法的低复杂度Turbo码的应用场景为MIMO-SCFDE通信系 统，即多天线单载波频域均衡系统，该系统工作在低信噪比条件下，工作信噪比 范围为-20dB〜-10dB,为提升系统性能，对单载波频域均衡方案进行改进，利用 Turbo均衡方案，进一步提升系统性能。
1.3本文的组织结构
根据论文的研究内容，本文共有五章。
第一章为绪论，主要介绍信道编译码的发展情况，并着重介绍了 Turbo译码 算法的发展历程及其应用场景。
第二章详细介绍基于维特比译码算法(VA)的信道译码方案，主要介绍了维 特比译码算法(Viterbi Decoding Algorithm),同时为降低维特比译码算法的计算 复杂度，又提出序列译码算法(Sequential Decoding Algorithm),以及利用人工 智能领域基于Dijkstra算法快速查找最短路径的A*译码算法。第二章提出的基 于Viterbi译码算法的两种低复杂度译码方案，为第三章中SOVA算法寻找最大 似然路径(MLPath)提供了降低复杂度的方向。
第三章提出了一种简化的SOVA译码算法，即T-SOVA算法(Trimming Soft-input Soft-Output Viterbi Algorithm),并将该低复杂度 SOVA 算法应用到 Turbo 译码算法中，在适宜信噪比条件下，使其能够达到与当前大量使用的BCJR算法 性能基本相同，但译码复杂度大大降低的效果。
第四章介绍基于该T-SOVA算法的Turbo译码方案在MIMO-SCFDE (多天 线一单载波频域均衡)系统中的应用，并利用该Turbo译码器与MIMO-SCFDE系 统中的均衡器进行迭代，利用Turbo均衡方案进一步提高系统性能。
第五章总结全文，并提出方案的不足及需要进一步改善的方向。
5
6
第二章维特比算法及其低复杂度优化算法
通过上一章的介绍，本论文所研究的低复杂度Turbo译码算法主要通过基于 最大似然(ML)译码方法的软输出维特比译码(SOVA)算法实现。所以本章主 要介绍基于维特比译码算法(VA)的信道译码方式，以及针对维特比译码算法复 杂度高、且复杂度随约束长度指数增长等问题，介绍其相关改进算法。本章的主 要目的是在维特比译码算法的基础上，简化其寻找最大似然路径的方法，为第三 章介绍的低复杂度SOVA算法的第一步——寻找最大似然路径提供解决方案。 本章主要介绍维特比译码算法⑹(Viterbi Algorithm),序列译码算法^(Sequential Decoding Algorithm)及 A*译码算法口第(a* Decoding Algorithm)。
2.1	维特比译码算法
2.1.1	维特比译码简介
1967年，美国科学家维特比首先引入了一种卷积码译码方法，这就是著名 的维特比(Viterbi)译码算法，他也开启了信道编码技术由代数译码向概率译码 发展的大门。后来经过小村(Omura)证明维特比算法等价于求通过一个加权图 的最短路径问题的动态规划问题口嵋 而后，傅尼(Forney)经过证明指出，维特 比译码实际上是卷积码的最大似然译码方法，即维特比译码器的输出码字总是满 足对数似然函数值最大的码字。
诚如大家所知，信道编码的目的就是要提高通信系统的可靠性，在通信过程 中，通信可靠性的指标一般采用平均误码率8表示。平均误码率耳表示在总的 发送码字中，错误码字的概率平楚值，
々=XHP(E|y)	(2-1)
其中
P(E\y) = P(m^m\y)	(2-2)
式中m为发送的码字，而为收端译码器的输出码字，y为通过信道传输后的 接收码字，由此可知p(y)与具体译码算法无关，所以，通信系统可靠性最大的译 码应为平均错误概率最小的译码方式，故
min Pe = min(y)尸(而 w m \ y)
y
=>min 尸(龙 7771 v)
n max P(hi - m \ y)	(2-3)
7
根据以上公式可知，对于给定的接收序列y,如果选择合适的布，使得
P5i = m|y)最大，则输出码字汾一定是最佳的。
根据Bayes公式可知：
――小)
若发送的码字等概，这时p(/n)为常数，且p(y)与译码规则无关，则: maxP(加 | y) = max尸(y | m)
P(y\m) = Y\p{yi\mi')
(2-4)
(2-5)
所以，译码器如果可以选择一个估计值使得上式最大，则这种译码器称为最 大似然译码。P(y|m)称为似然函数，由于logx是x的单调函数，对以上公式做一 点变化处理则可以得到对数似然函数：
log 2(团山)=£ log P^i I 肛)	(2-6)
i
如果发送码字不等概，则最大似然译码不一定是最佳译码方式。在这种情况 下，在决定何种码字能够使P(My)最大时，必须以概率P(m)对条件概率 logp(如码)进行加权。但现实通信系统中，许多系统的接收端并不能知道发送码 字的概率，所以最佳译码并不是一个必要条件，即最大似然译码就成为了可行的 译码规则。
对于二进制对称信道(BSC)而言，上述似然函数的公式可以进一步改写
P
log
+ nlog(l-p)
(2-7)
1 — P
其中，d(y,zn)表示y与m之间的汉明距离，假设p<l/2,对于所有接收到的
序列y,都存在log 上 <0,且〃og(l-p)为常数，而
1-P
L-\
max logF(y | m = m) = min d［y,m^ = min gd (%,cz)	Q-8)
i=o
所以对于二进制对称信道而言，最大似然译码等效于求解接收码字与可能的
输入码字的最小汉明距离值［2。］。
2.1.2	维特比译码过程
由上一节可知，最大似然译码等效于最小汉明距离译码，因此具有最小 d(y, m)累积值的路径就是logp(y \ m)的最大似然路径，该路径被称为幸存路径。 定义分支度量值(BranchMetric)为BM = d(%g)；最小累积度量值，即对所有 分支度量值的累积量表示为PM。卷积码的编码过程与网格图中的一条路径对应， 即输入序列的编码过程与网格图中的路径存在一一对应的关系。当序列长度为L
8
时，网格中一共存在平条不同的路径，即其对应于乃种不同的输入码字。在网格 图中，每个状态转移的过程都是输出码字的过程，所以，在每一个符合输入的分 支中，都可以计算出分支度量值，译码过程也是建立在网格图搜索的基础之上， 且出发状态与结束状态已知，都是全零状态。
假设L表示码字长度，N侬表示卷积码寄存器长度，维特比译码算法的步骤 可以总结为以下三步：
1）以时刻/=入7悭为起始，计算进入各状态的不同路径的分支路径度量值， 并存储每个状态的幸存路径及其分支度量值BMo
2）令l = l+T,将进入某一状态的分支度量值与其前一段路程的幸存度量值 相加，然后计算进入该状态的所有最小度量的路径，得到新的PM值，这样就得 到了某一个节点的幸存路径及其累计度量值，并删去所有其他路径。
3）若IvL+J 重复步骤2,若/ = £+乂《则停止上述步骤，译码结束。
上述3个步骤中，第一步是第二步运算的初始化，第三步是第一步和第二步 的延续，上述过程的关键在于第二步。译码算法第二步的核心在于三点，即累积、 比较、选择。所谓累积值，指的是将每个路径的分支度量值进行累加，度量方法 可以选择汉明距离或欧式距离等计算方法；比较指的是将到达节点的两条分支路 径的累积度量值相比较；选择指的是选出到达某节点的两条路径中度量值最小的 一条路径作为幸存路径。
为了更加清晰、明确地展示维特比译码方法，以（2,1,2）卷积码为例说明维 特比译码过程。假设其输入数据为4 =[110 11],卷积编码器结构如下图所示：
经过编码器输出码字序列为m = [11 01 01 00 01],经过有噪信道传输，假设 接收端接收到的码字为y = [11 01 0110 01],对该接收码字利用维特比译码方式 译码，维特比译码格图如下图所示：
9
y
S0(00)
Sl(01)
S2(10)
S3(U)
图2-2 (2,1,2)卷积码译码网格图
如上图所示，图中圆圈代表编码器内部两个寄存器的状态，共有四种情况即 00,01,10,11,实线箭头表示编码器输入为1的情况，虚线表示编码器输入为0的 情况，图中红色数字表示编码器在当前寄存器状态下输入为0或1时，输出2比 特码字的情况。
在时刻/< N,空的情况下，计算出每个路径分支的分支度量值之和，即为码 字的汉明距离，如上图中绿色数字所示，如接受序列y中第一个码字信息“11”, 与第一回合两条分支路径中的的汉明距离分别为2和0,该数字被标注 在图中每个分支路径上。只有当每个状态节点具有两条路径时，译码算法才开始
10
根据分支度量的大小选择幸存路径，删除其他路径。
对于时刻/NN“。时，可以看到此时SO〜S3均有两条路径到达，选择两条路 径中度量积累量较小的支路作为幸存路径，并删除其他路径，各个节点在时刻/ =时的幸存路径如下图中蓝色曲线所示：
y
so(oo)
Sl(01)
S2(10)
S3(ll)
图2S (2,1,2)卷积码译码维特比译码步骤二
至此，第一次幸存路径选择完成，删除其他非幸存路径后，重复上述步骤, 直到/=L+N.eg，此时译码到达终点，如图2-5所示，卷积译码完成。剩余幸存 路径即得到的最大似然路径如下图红色折线所示：
输入0	输入1
图2-5 (2,1,2)卷积码译码维特比译码步骤三
根据该路径得到的译码输出应为V =[11 0101 00 01],观察可知，与编码 器输出码字m完全相同，该码字对应的编码器输入数据可以根据以上最佳路径 实线和虚线读出，即利用维特比译码结果为宠=[110 11],与x完全相同。虽然
11
经过有噪信道干扰，仍能得到正确码字。
本节主要介绍了 Viterbi译码算法的理论依据及译码步骤,详细解释了 Viterbi 译码算法中最小汉明距离译码与最大似然译码之间存在的等价关系，为后面介绍 软输出维特比译码算法及其简化算法提供了坚实的基础。
2.2	序列译码算法
卷积码的使用为实现信号的可靠性传输做出了巨大贡献，上一节着重介绍了 基于最大似然译码的维特比译码算法。诚然，维特比译码算法一经问世便开始被 大量应用，但是维特比译码算法仍然存在着巨大的缺陷。由上一节维特比译码算 法的介绍可知，维特比译码算法的算法复杂度主要取决于卷积码的约束长度。其 主要取决于卷积码编码器中寄存器的个数，该寄存器个数直接影响了每个时刻需 要搜索的节点个数，即维特比译码算法的算法复杂度随卷积码约束长度指数增长, 所以维特比译码算法要求其约束长度不得超过7。然而，为了达到通信系统可靠 性传输要求，这一约束长度的限制在实际应用中几乎不可接受，所以需要寻找一 种新的译码方式，而序列译码算法就是一种不受编码器约束长度限制的译码方式。
2.2.1	FANO译码算法
1963年，Fano对Wozencraft的算法进行改进，提出的了著名的序列译码算 法⑪，Fano译码实际上是一种基于码树图结构的准最佳概率译码。其延迟随机， 译码复杂度与卷积码的约束长度无关，但是与信道中噪声的干扰强度有关，下面 详细介绍Fano译码算法。
首先，维特比译码算法在任何条件下耗费固定的计算量并不是一种最优的译 码方法，在信噪比条件较好的情况下，很多对于非幸存路径上的计算式非必要的。 例如，假定长度为L的序列通过BSC信道无误传输，即了 =加，但是维特比算法 在译码时仍要进行非数量级的运算，在这种情况下，大部分的计算是无意义的， 所以寻求一种在高信噪比条件下，计算量较小的译码算法势在必行，这种算法不 受约束长度的影响，只与噪声大小有关，将卷积码的译码从约束长度中解放出来。
通过以上分析，我们可以对序列译码的译码思想进行简单总结，即根据接收 序列对发送码字进行判决，计算序列的判决结果和接收码字之间的度量差异，通 过选择一定的门限对度量值的大小判定，如果通过门限则表明当前结果大概率正 确，可以继续向下搜索，若无法通过门限则表明当前译出的码字大概率存在错误， 需要向前回溯，寻找其他可能序列。
12
2.2.1.1	费诺（Fano）度量
由式（2-5）可知，维特比译码算法是最大似然译码算法，且对于维特比译码 算法来说是最优度量，因为在任意译码时刻，都有相同的译码操作。但是，在序 列译码中，每个时刻译码器需要比较的路径长度并不相同，因此不能采用式（2-5）作为比较度量值的依据。因此在序列译码中，为了适应不同长度路径的比较 情况，需要对上式（2-5）做出新的调整。
假设将一个编码器（n,k,m）编码的码字送入一个二进制输入, 信道，输入序列为
Q进制输出的
C - (c(),,。2 , ■ " ・ , Q-i)
(2-9)
由DMC信道输出的序列记为：
R =（q,4,
(2-10)
在DMC信道条件下
L-\
nL-l
P(R|C)=nP(K/C,) = f[P(,"q)
i=0
，=0
(2-11)
其中，分别表示接收序列与发送序列中的第i个码元。 由Bayes公式可知：
P(QR) =
L-l
P(C)P(R|C) PW-[	nL-l
(2-12)
尸（R）=ri尸（飞）="储）
(2-13)
i=O
i=O
P（C）为发送码字序列的先验概率，假设等概发送，则 p（c） = rkL =
(2-14)
其中凡表示编码码率:
凡
(2-15)
将上述公式代入（2-12）
P(C|R)=
可得
U pg
(2-16)
对等式两边取对数可以得到：
/	、	'g	讶 P（r\c\
1幅 P（C | R） = f 也 + S log2 卷，=盲（1幅为2 -4）
(2-17)
式中？白仁）为信道转移概率，尸化）是输出符号概率，在发送码字等概的情 况下，最大似然函数译码就是最大后验概率译码，也就是求：
max (log? P(C | R))
(2-18)
13
求最大似然函数就是求式(2-17)的等式右边的最大值，因此，定义Fano度 量值：
河下(出)=1叫2驾?一凡	019)
费诺(Fano)度量按照式(2-19)定义，以此作为不同长度路径比较时的比 特度量值。
则某路径的路径累积度量值可以表示为：
Z-l	nL-\
% (R | C) = Z% (&G)=%监(力q)	(2-20)
;=0	/=0
2.2.1.2	费诺(Fano)算法
费诺译码算法的基本思路是基于一种深度优先的搜索策略，译码过程就是在 码树的各个节点之间进行路径选择。在某一节点处，译码器先由这个节点向前看 (即向更靠近译码终点的方向)，找到一个可能的幸存节点，若能满足某种门限 的设定，则向前移动到该节点，若不能满足，则返回该节点的上一个节点，并设 法沿这一个分支移动。判断是否向前移动的标准就是利用费诺度量值与一个自适 应门限T进行比较，当译码器到达译码终点时，Fano译码过程结束，输出的译 码结果为当前节点所选路径上的码字。
费诺译码算法之所以成为一个可行的译码算法，主要判断依据就是该译码算 法能够满足以下要求：
1	. Fano译码算法能以较大概率发现当前路径是否正确；
2	.当Fano译码器发现其当前路径为错误路径，其有极大概率能够重新定位 正确路径，并能回退到正确路径分支的节点；
3	.在进行译码过程中，译码计算复杂度较低，且要求的实现电路简单可行。
费诺(Fano)译码算法流程如下图2-6所示。
其中表示Fano度量，当前时刻为/,此时的门限值为(，%是返回到 时刻1-1节点处的Fano度量，入为调整门限值大小的系数。
由Fano译码算法的流程可知，Fano算法的完成计算次数与入值的大小选择 有极大的关系。若入过小，会导致计算次数过多，造成Fano算法计算复杂度增加， 相反，若增大入，确实会使得计算次数下降，但是必然会造成译码性能下降。因 为门限T的作用就是使序列译码算法尽量沿着最大似然路径寻找分支，若入过大， 当T低于最大似然路径的最小度量时，也可能低于另外几条路径的最小度量值， 从而使搜索分支为其他路径而不是沿着最大似然路径搜寻，让其沿着一条“坏路 径”不断延伸，使其深入的深度增大从而造成计算浪费。由此可知，选择人需要在 搜索精度与计算复杂度之间进行折中处理。
14
2.2.2	FANO译码算法的改进
与Viterbi译码算法相比，Fano译码算法的优势在于Fano译码算法突破了卷 积码编码器约束长度的限制，使得译码复杂度与约束长度不再有指数增长的关系, Fano序列译码方式使得约束长度大于8的卷积码得以应用，这极大地提高了信 息传输的可靠性。
然而，Fan。序列译码算法还是存在一些劣势。第一，Fano序列译码算法的 搜索复杂度与信道噪声相关，当噪声较小时，其译码次数较少；相反，当噪声较 大时，其译码次数会极大增加，甚至有可能高于Viterbi译码算法，所以序列译码 更适合工作在高信噪比条件下。第二，Fano提出的序列译码算法并不是严格的 按照最大似然(ML)译码，Fano所提出的序列译码算法只是一种次最优译码方 法。2002年，Yiinghsiang S. Han等人对Fano译码算法进行改进，将费诺(Fano)
15
度量依据瓦格纳(Wagner)准则改进，从而使序列译码算法服从最大似然译码, 并进一步降低序列译码的算法复杂度。
由于这种新的度量值具有非负特性，这种新的序列译码方式能够使用和维特 比译码同样的网格图进行译码，而不是利用Fan。所提出的码树进行译码，也就
是说，在最坏的译码条件下(即译码信噪比较低)，这种改进的序列译码算法在 最差情况下译码搜索次数不会高于全路径搜索的Viterbi译码算法。当信噪比较 高时(一般大于3dB),在AWGN信道条件下，改进的序列译码算法平均计算 次数相较于Viterbi译码算法降低几个数量级。为了方便书写，将这种改进的Fano 译码算法称为 MLSDA〔2" (Maximum-Likelihood Soft Decision Sequential Decoding Algorithm)。
首先介绍MLSDA算法的分支度量计算。将一个卷积码用(n,k,m)表示，其 中k表示输入译码器的码元比特数，n表示输出的码字比特数，m表示编码中寄 存器个数，设L为输入信息比特长度，则输出码字长度表示为N2n(L + m)。之 前已经提到过，MLSDA将Fan。译码的码树图改为格图，即将码树图中相同状 态的节点合并，并且格图的起点和终点都是唯一的。卷积编码结果表示为v2 (v。，Vi，V2,	经过信道,接收端接收到的信息表示为r = (r0,rlrr2,
由接收信息r得到的硬判决结果为y =仇,心，…,弘-1)。
1 Pr,ID
硬判决依据式(2-21)的符号做出,
△ 力=
即
1,0 < 0
0, ^>0
(2-21)
(2-22)
y的伴随式可以表示为
△ T tT
(2-23)
其中H是编码矩阵的校验矩阵，E(s)表示所有伴随式为s的错误样式集合。
根据瓦格纳准则，可以找到如下e*e E(s)满足下式：
N—\	N-\
ZWMKIXMI	(2-24)
7=0	;=0
其中e e E(s) o 1983年，S.Lin和J.Costello等人对上式进行了证明，证明过 程如下：
假设利用ML译码算法，译码输出结果为£=/,其中/满足下式：
16
N\	*\2	N-1	2
E(^-(-i)j ?。厂(-1厂)
N-l	*	N-1
=£ 一 (一旷。厂E-(-1广我
7=0	7=0
O；£[(T)" -(T)"]圾 < ；Z[(-1)" -(-1)'"]%	(2-25)
乙j=U	乙y=0
N—l	N—1
O z(匕㊉u)同江(匕㊉V7)k|
7=0	产。
N—l	N-\
= £e：同空白同
产 0	7=0
由上式可以得到式(2-26)
£ = y㊉e*	(2-26)
由式(2-25)和式(2-26)可以得到新的比特度量：
〃(七)=(无㊉ xj ■	(2-27)
当译码时刻为/时，假设选择路径对应输出的译码结果为 %1)=(/当''…由式(2-27)可以得到整个路径的度量累积值：
.	. ln—\
(2-28)
7=0
式(2-28)即为MLSDA算法的分支路径度量。
MLSDA算法改善了 Fano度量，定义了一种新的分支度量方式。由以上论 述可知，度量值M%)是一个非负值，所以使用MQj)度量值判断分支路径，可以 使译码树搜索合并成为格图搜索，这样做可以极大降低实现中搜索出的分支路径 的存储空间。并且通过运用这种新的度量计算方式，可以将Fano顺序译码算法 由一种次优的译码方法变为可证明的最大似然译码方式。
基于格图的MLSDA顺序译码算法的步骤可以概括为以下5步：
1	.初始化一个名为Open的堆空间，将译码起始节点放入堆中，并将此事的 分支度量设为0。
2	.初始化另一个名为Close的堆空间，将位于Open堆栈中节点的所有基于 该状态的下一时刻幸存节点的度量值计算出来，选择当前Open堆栈中 最上方的节点。将该节点加入到Close堆中，同时删除Open堆栈中的该 节点。
3	.加入新的分支路径时，如果后续幸存节点位于Open堆栈中，比较两次 度量值大小，选择较小的值进行更新，若后续幸存节点已经位于Close堆
17
栈中，则直接丢弃新的路径，即一个比当前分支更好的路径已经被选择 了。
4	.将已经加入Close堆栈中的节点的后续幸存节点及其度量值插入到Open 堆栈中，该堆栈的按照度量值从小到大排序（所有度量值均为非负数）。
5	.当译码终点位于Open堆栈的最上方时，译码结束，否则，返回步骤2继 续译码。
前面介绍了一种基于Fano顺序译码的改进算法，通过改变Fano度量使得新 的度量值满足非负特性，并证明这种MLSDA改进算法满足最大似然译码策略。 在实现层面，Open堆栈空间和Close堆栈空间不可能开辟到无限大，这对于存 储空间和排序算法都是无法接受的。针对这个问题，可以采用固定堆栈大小的方 式，即预先设计好堆栈的最大深度，若堆栈超出预定长度，则删除该堆栈中最大 的节点数据（即最不可能成为最大似然路径的分支）来保证堆栈长度不大于预定 深度。
这种限制堆栈长度的方式在低信噪比下确实会造成一定的性能损失，但是这 种方法能保证在较高信噪比条件下译码性能和工程实现都能被接收，也极大地推 动了顺序译码算法在工程实践中使用。这种新的顺序译码算法，优化了深度优先 的顺序译码策略，使得后续基于Dijkstra最短路径思想的A*算法成为可能，并 为后续Turbo码的两个SOVA分量译码器降低计算量和减小存储空间指引了新 的方向。
2.3	A*译码算法
A*算法是一种利用人工智能搜索树算法来寻找一张格图中最短路径的方法, 它的主要思想是基于Dijkstra最短路径算法，以最快的方式寻找到从起点到终点 的最优路径。1980年，Nilsson将这种方法定义为一种启发式的搜索图形方法， 并证明这种算法总是能寻找到一条最佳路径。1993年，A*算法被Y.S.Han、 C.R.P.Hartmann和C.C.Chen等人应用到线性码块的最大似然软译码算法中。简 单来讲，A*算法搜索整个码树，寻找最小的路径度量值。每一次迭代，该算法扩 展一个最优节点，并删除其他次优节点。这些节点扩展或删除的依据被命名为启 发函数，在某一节点处的启发函数必须是所用经过该节点的路径的最小值。
2.3.1	Dijkstra最短路径算法
迪杰斯特拉（Dijkstra）算法于1959年提出，是一种计算起点到所有其他节 点最短路径的有效方案。Dijkstra算法以起点为中心向距离其节点最近的各节点
18
逐渐扩展，直至到达路径终点。Dijkstra算法采用了 “贪心”的策略，即每次都 查找与该点距离最近的节点，因此该算法也逐渐成为了搜索最短路径的代表性算 法。由于其搜索的依据是最短距离，所以该算法主要用于非负图的路径规划，这 也正与信道译码中最常见的计算欧式距离十分契合。
Dijkstra最短路径算法的基本思路如下：
1	.声明一个数组D来保存源点到各个节点的最短距离，一个保存已经找到 了的最短路径节点的集合T,和一个未确定最短路径的顶点集合U。
2	.将起始点s的路径权重被赋值为0 (D[s] = 0),若对于起始点s存在能 直接到达的边(s,m),则把D[m]设为M(s,m),同时把所有s不能直接到达 的节点的路径长度设为无穷大，所以在起始时刻，集合T中只有起始点
So
3	.从D数组中选择最小值，则该值就是起始点s到该值所对应的顶点的最 短路径，并将该节点加入到集合T中。加入新节点后，寻找新节点到达 其他顶点的路径值，并计算通过该节点到达其他店的路径长度是否比源 点拥有更小的路径长度，若小于源点到某节点的路径值则替换这个顶点 在D中值。
4	.从数组D中找到最小值，重复上述操作，直至集合T中包含图中所有节 点。
若一个拥有六个节点的无向图如图2-7所示。
利用Dijkstra算法搜索以A为起点经过所有其他节点到F的最短路径的步 骤如表2-1所示。
19
表2-1 Dijkstra算法搜索路径步骤
步骤	集合T	集合U
1	初始化A,此时T=<A> 最短路径A->A=0 以A为起点开始搜索	U=<B CDEF> A->B=6, A->C=3, A->others=oo A->C=3最小
2	选择C,止匕时T=<AC> 最短路径 A->A=0, A->C=3 以C为中间点，A->C这条路径 开始搜索	U=<B DEF> A->C->B=5, A->C->D=6, A->C->E=7 A->C->others=oo, A->C->B =5 最小
3	选择B,止匕时T=<ABO 最短路径 A->A=0 , A->C=3 , A->C->B=5 以B为中间点，A->C->B这条 路径开始搜索	U=<DEF> A->C->D=6,（丢弃 A->C->B->D=10）, A->C->B->others=oo A->C->D=6 最小
4	选择D,此时T=<ABCD> 最短路径 A->A=0, A->C=3, A->C->B=5, A->C->D=6 以D为中间点，A->C->D这条 路径开始搜索	U=<E F> A->C->E=7,（丢弃 A->C->D->E=8） A->C->D->F=9 A->C->E=7 最小
5	选择E,此时T=<ABCDE> 最短路径 A->A=0, A->C=3, A->C->B=5, A->C->D=6, A->C->E=7 以E为中间点，A->C->E这条路 径开始搜索	U=<F> A->C->D->F=9,（丢弃 A->C->E->F=12） A->C->D->F=9 最小
6	选择F,止匕时T=<ABCDEF> 最短路径 A->A=0, A->C=3, A->C->B=5, A->C->D=6, A->C->E=7, A->C->D->F=9 此时F已经到达终点，搜索结束	集合U已空，搜索结束
由上述Dijkstra算法（DA）的步骤可知，DA主要应用于选择一条从起始点 到终点的最短路径，在信道译码中它主要的应用场景就是格图。若不加改变，完 全按照Dijkstra算法实践，将会搜索格图上的所有节点，最终到达译码终点。虽 然这种寻找方法一定得到的是一条最短路径，且对于译码来讲一定是最优译码码 字，但是这显然违背了降低译码复杂度、简化搜索路径的初衷。所以，对Dijkstra 20
算法进行简化是必然之举。应当选择一个合适的决策方法，当从某一节点出发时， 不再盲目搜索与之相连的所有路径，而是有选择地尝试正确概率最高的路径，这 也就是我们为什么要研究A*启发函数(A* Heuristic Function) o
2.3.2	A*算法及其启发函数
A* (A Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法， 即依据某个或某些优化准则(如工作代价最小、行走路径最短、行走时间最短等)， 在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。我们的 译码算法运用了一种广义迪杰斯特拉算法(Generalized Dijkstra Algorithm ),即 利用人工智能最优路径规划的方式进行信道译码。
A*算法搜索整个译码格图的依据式(2-29)
/(m) = g(m) + /2(m)	(2-29)
其中f(m)表示从初始状态经由状态m到达目标状态的代价估计，g(m)表示 在状态空间中从初始状态到达状态m的实际代价，做m)表示从状态m到目标状 态的最佳路径估计，即前面所提到的启发函数。
A*算法也可以通过调用两个堆栈来进行，即Open List和Close List。其中 Open List用于存储已经比较过，但是尚未被纳入最短路径的节点，Close List用 于存储已经被判断为最短路径的节点。A*算法的步骤可以总结为以下几点：
1	.将起始点纳入Open Listo
2	.遍历Open List,查找f(m)值最小的节点，把它作为当前要处理的节点， 然后移到Close List中。
3	.对当前Close List中的节点的下一个相邻节点进行检查，若该节点不在 Open List中，则将其加入到Open List；若该节点已经在Open List中， 检查当前路径是否更近，如果是就对路径值进行更新并重新计算它的 4m)和/(m)值，并重新对f(m)值进行排序，如果不是就保持原值。
4	.判断译码终点是否加入到OpenList。若没有加入Open List,则继续执行 步骤2〜步骤4；若译码终点已经位于Open List中，则译码停止。
启发函数人(m)的选择会影响A*算法的行为：若/?(m)=0,则只有g(m)起作 用，此时A*算法演变成Dijkstra算法，这一定保证可以能找到最短路径。〃(m)越 小，A*算法扩展的节点越多，运行也就会越慢。最理想的情况即为力(m)精确地 等于从m移动到目标的代价，则A*将会仅仅寻找最佳路径而不扩展别的任何结 点，这会大大降低运行时间。尽管这种情况不可能经常发生，但仍然可以在一些 特殊情况下做到地相等。如果〃(m)过大，则A*不能保证找到一条最短路径，但 它可以运行得更快。所以，启发函数的选择需要在运行速度和运行精确度中做出
21
取舍。
1993年，YSHan等人将A*算法应用到线性分组码的译码中，其中定义了 一种可供参考的启发函数计算方法，将最小分支度量值与最小欧式距离的平方相 联系口叫 假设该线性分组码为二元码字，经过BPSK调制，在AWGN信道条件 下以下1传输。接收端收到的序列表示为0 = (%用,％…,%-J，经过证明可知， 若对接收序列进行排序将会减少其他分支路径计的数量，从而降低计算量，所以 对接收序列|0|进行从大到小排序。这是因为根据AWGN信道高斯分布特性可 知，距离干1越远，根据其符号进行译码错误的概率就越小。重排后的序列记为 9*=(现0；,脸...,心)，在实现中对该过程并行处理，其复杂度为O(kxn),其 中k为一组码字的输入比特数。同时用力=(£#；,唳…,v")表示根据“符号做 出的硬判决。由于位于0*中的前k比特码字为系统码，一旦确定，其后(n-k) 比特码字也就已经确定，所以只需要搜索前k比特码字，无需对后面的码字搜索， 直接计算得到即可。
当搜索到第匕比特时，A*算法的启发函数h(m)表示为：
["1 /	八2、
向11<2侬_(_11)> -1<£< k-1
"	7	"T	, \2
(T)") k-l<l<n
(2-30)
上式给出了 A*算法用于信道译码时的启发函数计算，式(2-30)表明，若译
码m是目标节点，则有h(m)=0。该启发算法需要计算欧氏距离的平方，在实现 层面上还有许多不便，1996年，LauraEkroot与SamDolinar又将式(2-30)做了 简化处理，得到了其等价形式口叫c：表示根据译码规则译出的码字，由式(2-31) 表示：
/7-1
MM =	(5的丰。)	(2-31)
/=0
上式省略了计算平方的步骤，且只有根据选择路径所译出的码字与硬判决结
果不同时才需要进行累加，若译出的码字与硬判决结果相同，所需加入的累积量 为0,这也极大减少了启发函数的计算量，为后续算法应用A*算法进行最短路 径的选择提供了更大的应用空间。
2.4	本章小结
本章详细介绍了维特比译码算法及其改进算法，力求降低维特比译码算法的 算法复杂度，提升信道译码算法的译码速度和译码效率。为了解决维特比译码算 法的复杂度随约束长度指数增长的问题，我们提出了序列译码算法，并对其做出
22
调整使其满足最大似然函数；为了更快速地寻找译码起点到终点的最短路径，我 们借鉴了人工智能算法中的A*算法，并将启发函数定义成符合信道译码物理意 义的最小分支度量。经过对序列译码算法和A*译码算法的改进使得维特比译码 算法的复杂度大大降低，且更加易于实际应用。
本节提出的三种译码算法，其中A*算法和序列译码算法是对Viterbi译码算 法的改进，两种算法缩小了 Viterbi算法寻找最大似然路径的范围，大大减少了 Viterbi译码算法的计算复杂度。且A*算法和序列译码的改进算法MLSDA算法， 为第三章提出的T-SOVA算法（即简化的SOVA算法），提供了低复杂度搜索最 大似然路径（MLPath）的方法，大大降低了 SOVA算法的译码复杂度并极大地 节约了存储空间。
以上两种算法虽然充分利用了信道提供的信息计算分支度量，但是输出仍然 是硬判决0或1,这种硬判决输出方式对于后续研究Turbo译码器的两个分量译 码器之间相互传递信息是非常不利的。所以，在降低译码复杂度的基础上，仍然 需要使译码器的输出同样提供软信息、，这也是后续研究软输出维特比译码算法 （SOVA）的原因。
23
24
第三章Turbo码低复杂度软输出维特比译码算法
Turbo码是一种采用重复迭代译码算法的级联码，采用适当的译码算法及码 长无限长时可以接近香农极限定理。首先，本章将介绍Turbo码的原理及CCSDS 标准编码器结构，分析其结构对Turbo码性能的影响。其次，在第二节将介绍如 何利用SOVA算法进行分量译码器之间的信息传递，作为对比同时介绍基于最 大后验概率的MAP算法。最后，对SOVA算法进行简化，提出简化的T-SOVA 算法，使得在译码性能没有明显损失的前提下，降低Turbo译码复杂度。
3.1	Turbo码原理
3.1.1	Turbo编译码器结构
3.1.1.1	Turbo 编码器
Turbo编码器按照分量编码器的相对位置可以分为三种:并行级联（PCCC）、 串行级联（SCCC）和混合级联（HCCC） “久 三种编码器各有优劣，其中并行级 联应用最为广泛，因为它在低信噪比条件下译码性能较好，其缺点在于存在较高 的误码平层，而这一劣势也可以通过设计适当的交织器来降低并行级联码中的误 码平层。所以在实际应用中大多采用并行级联结构，故本论文研究的Turbo码也 采用并行级联结构。
图3-1典型Turbo编码器结构
Turbo编码最典型的应用就是并行级联卷积码，它将交织器与卷积编码结合 起来，以此来实现随机编码的思想。Turbo码中的两个分量码一般选择递归系统 卷积码（RSC）,以此保证编码器的译码性能。分量编码器级联，有效增加了码 长，且采用软输入软输出译码，使得Turbo码获得了接近香农限的优异性能。
Turbo编码器的典型结构如图3-1所示，其主要由交织器和两个分量编码器
25
组成。Turbo码的信息位直接送入复接器输出，校验位一部分通过编码器1输出， 一部分经过交织器后通过编码器2输出，两部分校验位送入删余矩阵，最后送入 复接器输出。删余矩阵根据编码速率不同而有所改变，最后将信息位与校验位串 行输出，完成编码过程。
3.1.1.2	交织器
Turbo码中交织器的作用有两点，其一是将输入信息的顺序打乱，以此来降 低编码后序列的相关性，抵抗信道可能发生的突发错误；其二是改变编码的码字 重量分布。交织器极大地降低了 Turbo码中较低码重或较高码重出现的概率，增 加了平均码重码字的数量，因为当信息序列经过编码器1后码重较轻，经过交织 后，信息序列被打乱，大概率经过编码器2后会取得较大码重，从而提升Turbo 码纠错性能。
交织器的种类有很多，常见的交织器类型主要有：行列交织器、堆栈式交织 器、QPP交织器〔22〕、伪随机交织器、分组螺旋交织器等。交织器的种类有很多， 不同的应用场景中往往选择不同的交织器类型。
在实际应用中，一般选择 QPP (Quadratic Permutation Polynomial)交织器。 QPP交织器是一种具有伪随机特性的交织器，根据不同码长，交织器通过生成多 项式为每个比特生成一个交织地址，通过地址映射实现交织。QPP交织器的生成 多项式如式(3-1)所示；
兀j=1f" +九,『、鹏。北	(3-1)
式中/i和人为QPP交织器的交织参数，L为交织深度。
由上式可知，QPP交织器硬件实现简单方便，不需要存储交织地址，交织地 址可以通过实时计算得出，节省存储空间。止匕外，QPP交织器在无冲突交织方面 也有不错表现，所以实际应用中被广泛采用。3Gpp提出的LTE标准中，给出了 码长从40到6144的情况下/^口人的取值，所以在后续Turbo码的研究中，我们 主要采用QPP交织器进行信息序列的置乱。
3.1.1.3	Turbo 译码器
Turbo译码器的结构框图如下图3-2所示，两个分量译码器之间形成迭代循 环的结构，其形式类似于涡轮(Turbo)，所以这种编译码方式被称为Turbo码。
26
P)
译码器1
解交织器
Lei ------
---► 交织器
译 码 器 2
Le2
LLR
——►	交织器
P2
图3-2典型Turbo译码器结构
Turbo译码器由两个分量译码器构成，译码器的输入包括信息位、校验位和 先验信息。对应于译码器1,信息位表示为石，校验位表示为pi,先验信息表示 为加2；对于译码器2,信息位经过交织表示为小，校验位表示为P2,先验信息表 示为加广每个分量译码器的输出为似然比（LLR）和外信息加1、加2。外信息就 是译码之间相互传递的信息，分量译码器输出的外信息作为另一个分量译码器输 入的先验信息。两个分量译码器通过循环传递外信息获得额外的信道信息，直至 到达Turbo码译码结束条件。
两个分量译码器的译码结构对应于分量编码器的结构，所以两个分量译码器 之间靠交织器和解交织进行连接。将译码器1输出的外信息通过交织器送到译码 器2的输入作为先验信息，将译码器2输出的外信息通过解交织操作送到译码器 1的输入作为先验信息，两个译码器相互辅助完成整个译码过程。
3.1.2	CCSDS标准编码器结构
由于本论文的主要应用场景是超远距离点对点的MIMO-SCFDE通信系统, 该系统的特点就是传输距离较远，译码时延较长，所以非常适合应用CCSDS标 准的Turbo译码器进行信道译码，故本论文研究的译码器结构符合CCSDS标准。
CCSDS-Turbo码编码器就是典型的并行级联编码器，编码器由两个递归系 统卷积码分量编码器并行级联而成。编码器中有4个移位寄存器，即存在16个 状态。码率的选择可以较为多样，有1/2〜1/6等4种编码速率，码率越低，每个 系统位携带的校验位越多，相应的性能越好，但同时译码复杂度也会升高。
CCSDS标准译码器描述如表3-1所示：
27
表3-1 CCSDS标准Turbo译码器描述
编码类型	PCCC
分量译码器个数	2
分量码编码类型	RSC
卷积码状态数	16
编码码率	R=l/2, 1/3, 1/4, 1/6
CCSDS标准编码器结构如图3-3所示:
图3-3 CCSDS标准Turbo译码器结构
常见的码率选择方式如表3-2所示：
表3-2 CCSDS标准Turbo码码率选择
码率	1/2	1/3	1/4	1/6
校验位选择	%或丫4	yny4	%必，丫4	yi，y2，y3，y4, ys
CCSDS标准Turbo编码器的两个分量编码器的结构完全相同，上述两个分 量编码器的生成多项式可以表示为(023,033,025,037)和(023,033,037)。为了 保证连续编码情况下编码器状态正常，需要保证在每一次编码开始时起始状态均 为0,即需要在编码伊始对四个移位寄存器进行清零操作。这种清零操作可以选 择硬件强制清零，也可以在每次编码序列的最后输入4个连续的0,使得编码器 寄存器清零。这多输入的4个0将在编码码块最后多出几比特，这些多出的比特 即为尾比特。
28
从译码格图的角度对加入尾比特进行分析更容易理解尾比特的含义，即在译 码最后阶段，不论最后一个有效码字停留在哪个状态下，经过最后四个始终周期 后，该路径最终会指引其走到状态为。的节点。所以，尾比特的作用不仅体现在 使编码器状态归0,其另一个重要作用就是增加最后阶段译码成功的概率。尾比 特的参与，可以有效降低译码曲线的错误平层，使得在高信噪比条件下译码成功 的概率大大提升。
3.2	Turbo码译码算法推导
3.2.1	SOVA 算法
根据以上对Turbo码编译码器结构的介绍可知，Turbo码的核心就是两个分 量译码器之间信息的传递。按照第二章基于维特比译码算法的信道译码方式只能 得到硬判决的输出结果，对于Turbo码而言，硬判决输出的维特比译码算法有两 个明显的缺点：第一，对级联码而言，一个分量译码器的译码错误会对另一个分 量译码器提供错误的先验信息，使得整体译码性能受到影响。第二，若分量译码 器的输出为硬判决结果，则其提供给另一个分量译码器的信息并不能完全反应信 道的影响。综合以上两点，为了弥补维特比译码的硬判决输出缺陷，对传统硬判 决维特比译码算法进行改进，使之提供软信息输出，这就是软输出维特比译码算 法（SOVA） o
SOVA分量译码器的译码过程与Viterbi译码算法比相差不多，在寻找最大 似然路径时，也可以按照第二章所介绍的信道译码算法进行复杂度上的优化。 SOVA与Viterbi算法的主要区别在于利用修正的度量值来寻找最大似然序列， 并结合另一个分量译码器提供的先验信息提高译码判决的准确性。
3.2.1.1	SOVA 的推导
Viterbi算法通过最大后验概率maxP（S（"'）| Y）的状态序列5（吟得到接收序列
的估计值｛取｝。
由Bayes公式可知:
小叫Y)?(Y|S⑻)⑻) P(Y)=
(3-2)
尸（S（叫Y）=
其中m表示第m条幸存路径，由于接收序列Y与m无关，所以求最大后验
概率等价于求式（3-2）等式右边的最大值：
max（尸（S（叫 Y）） = max（P（Y | S。"））尸（S®）））
且也只与k时刻和k-1时刻的状态有关，所以有：
(3-3)
29
尸(耳)=尸(Sj)尸(以)	(3-4)
对于DMC信道可知，有：
k
max 仅(Y|S ㈣)P(S("'))) = max 币(为坡团)P(S(m))
六1
=噌立尸(匕解)时))尸阳)尸侦))
；：	35)
”警“叩对?”为尸阳)尸便))网”"可"))
左一 1
=m警口?(匕愕),57)尸(噌卜便卜卜染))
/T
对上式(3-5)取对数可以得到一个累加序列，并定义k-l时刻的度量值为：
=比仙网匕陷)，•"))％*)]	(3-6)
I尸1	)
综合式(3-5)和式(3-6)可以得到:
max (M"))=
M：?+121nP(4)) — K
N L-
max j }
21n 尸(九噌)-〃,
、/ 〃=oL
(3-7)
其中九,o表示接收码字的系统位，线,0表示对应分支的系统位，%,兀表示接收 码字的校验位，&,几表示对应分支的校验位。
咄)二足便可匕明盾)尸陷]	(3-8)
I >1	)
式(3-7)中，
Mu =lnP(^ =l) + lnP(^ =-1)	(3-9)
陷,=ln尸=l) + lnP(枭,』年" =—1)	(3-10)
由式(3-9)和式(3-10)可知，%和My是两个与m无关的常数，所以对式
(3-7)进行进一步地简化可得:
,1㈣
+5壮

P(4 = +1) 1 ((,,)P(yk.n 1 % = +1)
1n西」力男1n尸… ——1)
(3-H)
式(3-11)中行警二即为先验概率，由另一个分量译码器传入当前译码器 P(uk=-1)
的输入，记为L(uQ,在AWGN信道条件下，膂瞥金组可以展开成高斯公式, p (y r7dx 土,?1——)
由此继续简化上式可得：
30
叔”=M2+9" d)+； £常忆”，
I	(3-12)
=Mk-X + T4""[〃%)+ 4^,0 ] + - 士染工加
/ ，”=1
式(3-12)中L为信道置信值，在AWGN信道条件下儿的值为：
L =42	人
c N。	(3-13)
由此SOVA算法的分支度量值足加可以定义为：
兄’")=5记)[“4.) +] + ；»!：%加	(3-14)
/	/ «=1
定义累积度量值M浮为：
M，，(3-15)
由上面的推导，已经得到了计算某条幸存路径m的分支度量B?1)和累积度 量值叫到)的计算方式，但是下面将考虑如何提供软输出(Soft-Output)信息。对 于一般的Turbo码，编码时输入输出均为0或1,即在时刻k有两条路径0或1 可以到达状态品，每条路径的度量值都可以由(3-15)计算得到，再将度量值较 低的一条分支路径删除，即只留下后验概率较大的一条路径。
假设在时刻k,到达状态Sk = s的两条路径的度量值分别为M环口且有 定义两条路径的度量差：
^k=M1-M； >0	(3-16)
所以，当前幸存路径为正确路径的概率如式(3-17)所示:
"r (&=S)=: 一.=1r
(3-17)
利用对数似然比公式可以将上述公式进行简化，得到式(3-18)：
.8)
由式(3-18)可以得到当前路径的对数似然比。
对于k时刻的状态节点而言，若当前时刻竞争路径和幸存路径上输出的译码 信息相同，则选择两条路径均可以得到相同的译码输出结果，所以对于两条路径 的选择并不影响判决结果的输出，在此情况下该节点处的可靠性可以保持不变。 相反，若在同一时刻竞争路径和幸存路径的输出结果存在差异，若选择其中任意 一条路径就意味着会有一定概率路径错误，造成译码结果的错误，所以在这种情 况下需要对当前节点的可靠性进行变更来反映可能错误的概率。
假设经过时间长度5,两路径合并为一条路径，即在k+b时刻两分支路在相 交。假设已经存储了幸存路径的错误概率与，且在5时长内，共有e个竞争路径
31
分支的判决与幸存路径的判决不同。此时时刻j处更新的错误概率如式(3-19) 所示：
Pj <- PjPcor + (1 - A- ) C1 -	， j = j\，…,je	(3-19)
此时的对数似然比表示为：
、 l-Pi
(3-20)
将式(3-17)和式(3-19)代入到式(3-20)中，可以得到式(3-21)： 入 「 \ 1	1 + 6(叫+可
4一八乙⑷二叫^^	321)
其中，
4 , E, a=4d/reel^	(3-22)
式中df%e表示码字之间的自由距离。
函数f@〃A)若想在实际中得到应用不可能计算指数，所以只能通过制表法, 通过查找乙,△来读取函数结果。a的作用主要是防止信噪比过高条件下的数据溢 出。为了进一步简化计算，可以对式(3-21)进行简化处理，如式(3-23)所示：
/■区,A)= min 区,A/a)	(3-23)
当时刻k幸存路径与竞争路径的输出判决不一致时，译码输出比特队要等到 k+3时刻再做出判决,而在这3长的时间内也会有一些竞争路径与最大似然路径相
交，这些竞争路径的输出并不能保证和最大似然路径完全相同，所以，这些不同
的判决就会影响最大似然路径对以判决的可靠度，所以在求队的对数似然比 LLR时要将其作为考虑因素。所以有式(3-24)：
|£Z7?^)| = min{A,.}	(3-24)
即，	上(以卜)=以向13	(3-25)
式中匕={左+1,k+ 2,…，左+3},以为最大似然路径给出的估计值，在时刻 /(/-= k + l,k+2,...,k+8),与最大似然路径相交的竞争路径的输出判决为A, 表示这些与最大似然路径相交的路径和最大似然路径的度量差值。
3.2.1.2 SOVA译码流程
上一节详细介绍了 SOVA译码算法的推导过程，介绍了分支度量值和累积 度量值的计算方法，并介绍了输出软信息(Soft-Output)的计算方法及更新原因。 本节将对上一节的内容进行归纳，给出SOVA译码算法的译码过程。假设SOVA 幸存路径和竞争路径的度量如图3-4所示：
32
需要更新LLR
!	!	1	1	!	1 「
t-5	t-4	t-3	t-2	t-1	t
5	4	3	2	1	o
图3-4 SOVA幸存路径度量图
图中实线表示最大似然路径，虚线表示竞争路径，假设在时刻3最大似然 路径与竞争路径相交，此时8 = 5。由图可知，在时刻t = t-4和t = t-2最大似 然路径与竞争路径的输出不一致，将该相对时刻2和4存入一个向量List中，需 要更新该时刻的可靠性值。
由此可知，递归SOVA译码器的译码流程如下：
1	.初始化时刻k=0,对于零状态，初始化度量M相")= (),其他状态初始化为 oo；
2	.k - k+l,对格图中的每个状态计算度量值：
M时 =射雪(以)+4%]+ ；2职2加 ； /	乙 W=1
3	.每个状态搜索最大的分支度量噌xM浮，规定表示幸存路径度量值, 表示竞争路径度量值；	m
4	.存储M,及判决比特和状态路径；
5	.计算及=卵_姿；
6	.比较k时刻每个状态处的幸存路径和竞争路径，存储两条路径上的比特判 决不同的相对时刻值，存入List中。
7	.从后往前更新所有存储在List中的时刻对应的度量△产=min ；
0,1，…9 I K)
8	.若没有收到整个传输序列，则返回执行步骤2；
9	.输出估计比特序列位，及其相应的软判决结果££K = A(/|y),并计算外信 息，作为下一个分量译码器的输入。
综上所述，本节详细介绍了 SOVA的推导过程及应用方法，证明了 SOVA算
33
法是一种能够应用到Turbo分量译码器的有效算法，且译码复杂度较低，计算较 为简单。作为对比，下一节将简单介绍另一种应用十分广泛的MAP算法及其改 进的 Log-MAP 和 Max-Log-MAP 算法。
3.2.2 MAP算法及其改进算法
1974年，Bahl、Cock、Jelenik和Raviv四人提出了著名的BCJR算法，该算 法是一种最大后验概率纠错算法。BCJR算法是当前应用最为广泛的Turbo译码 算法，基于最大后验概率算法的Turbo码译码算法又被称为MAP算法RI。
为了与上一节提出的SOVA算法对比，本节将介绍MAP算法的推导过程及 计算方法，并提出目前应用较为广泛的基于MAP算法的改进算法，即Log-MAP 和Max-Log-MAP算法。作为参照，第三节将会对MAP及其改进算法的计算复 杂度与传统SOVA算法及简化的SOVA算法进行对比，并为后续SOVA算法进 行复杂度的简化提供方向。
3.2.2.1	MAP 算法
假设编码器输入1=(t1八2,…遥N)，编码器输出信息位为u=(U1,U2, ...,UK), 输出的校验位为p = Qi，P2,…,Pm)，进行BPSK调制，其输出为a,经过AWGN 信道接收到的信息位为x = Oi，%2,…,％k)，校验位为y = (〉1，丫2,…,y.)，输入译 码器的信息为r,且有r = (x,y),在时刻t的状态记为生,时刻t+1的状态记为 仰+1。
后验概率的计算如式(3-26)所示：
P((u, p) |r) = P{(pt = p,(pl+x =q\r)	(3-26)
对上式进行推导可得：
= P(0 =P,0+i =q/)/P(r)
=尸(0	=q，L，q，L)/P(r)
= P^r=p,(pi+} =q,r<„rl)P(r>l\(p!=p,(pt+]	-⑺
=P 3 = P 阳+、= q，%，* P = 3 P (r)	(3'27)
=尸(0+1 =Q，rt\(pt =p,r<r)P((p! =p,r<l)P(r>t\(pl+! =q)/P(r) =♦(%+i =% 一. =P)P® =人力尸(。"+i =0)/P9)
定义前向度量值a1p),后向度量值总+19)和状态度量值Yt(p,q)，分别对应 式(3-27)等号右边的三项，式(3-28),式(3-29)和式(3-30):
«(2)=尸(0=夕，々)	328)
舟m(9)=尸G 幻0+i =?)	(3-29)
34
(3-31)
乙(夕应)=0(。,+1 =2“ M =。)	(3-30)
由(3-28)、(2-29)和(3-30)三式的定义可知，处表示时刻t状态为p的 节点处，当前状态p与t时刻之前接收数据的联合概率，我们习惯将其称之为前 向概率。股表示在当前时刻为t状态为p的节点的情况下，下一时刻计1状态变 为q的联合概率，我们习惯将其称之为状态转移概率。凡+i表示t+1时刻状态为 q的情况下，t时刻以后接收数据的概率，我们习惯将其称之为后向概率。
根据定义可以继续推导4+1和自：
% =尸(%+i = % %])=尸 3+1=% %，〃)
2-1
= q，% =
，=0
2-1
=» 9 = pp@+i=q，n 必=p，7)
p-0
2-1
=£%(2)九 34
p=0
A =?(乙」0 = 0 = P(L，必=?)
0-1
=£?(七"，％ =q\/=p)
q=0
2-1
=q+i=q\2= p)尸(q/ . <p+ =q,g=p)
<?=0
0-1
==q\，=0)尸(q/ (p* = q)
p=0
= »t(p,q)仇
p=0
其中Q表示分量译码器的寄存器状态值，这就给出了典型的Turbo码MAP 算法的前向和后向译码算法。只要赋予a和夕初始值，就可以计算所有的前向和后 向分支度量值。因为编码器初始状态为0,且前面已经介绍编码器大多应用尾比 特保证译码结束的状态也为0,所以对于a和胃的初始值有：
[%(0)，/⑴，…,%(Q -1)] =	(3-33)
[为⑼，&，⑴，…,£n(Q —1)] = [1,0,0,…,0]	(3-34)
下面进行状态转移概率%的推导，九的推导过程如下，由式(3-30)可知： yt(p,q) = P((pt+{ =q,rt\(pt = p)
=P(Q+\ =q\?= P)P^t I 旧+i =q,<p,=0)	(3-35)
=?(%)尸(7"%)
已知另一分量译码器传入的外信息为Le(%)，外信息的定义满足式(3-36)：
(3-32)
35
4(%) = log
P(ut = +1)、
(3-36)
对式(3-36)进一步推导可得:
尸(%) =
出 T)P(+D “也⑹/2 NT 尸(+1)
(3-37)
式中等号右边的第一项为一个常数，令“若高，则有式(3-38)：
P(%) = 4e“(仍	(3.38)
式(3-35)等号右边的第二项可以表示为：
产化 %) oc exp	(x,一｛y,-p,	广
2(t2	2(t2
- xj+uj+yj+p：			xtu,+ytp.	(3-39)
CAp	2a2	_	UAp
=5zexp '产 a
综合式(3-35)、式(3-38)和式(3-39)可以得到力的计算公式:
0c 4gexp w,4(t/,)/2]exp[
a2
oc
1 r /	、	1 r	1 r
exp -utLe(u,) + -Lcxtut + -Lcytp,
(3-40)
1
2
其中Lc = 4Es/N0,且有1/d=儿/2。
根据式(3-31)式(3-32)和式(3-40),分别计算MAP算法中的前向分支 度量，后向分支度量和状态转移度量，将上述三个因子相乘即可完成MAP算法 的计算。
3.2.2.2 Log-MAP 算法及 Max-Log-MAP 算法
结合上一节所介绍的MAP算法的原理及计算方法，MAP算法在进行计算 时，需要用到大量乘法，这需要耗费大量的计算资源，而在进行比特判决时，我 们只需要LLR提供的比值信息即可。为解决上述问题，对乘法操作取对数处理 可以使乘法变为加法，且可以抵消一些底数运算，这就是Log-MAP算法凶［25］的 初衷。
对数后验概率如式(3-41)所示：
M小)二•如…	(3-41)
式(3-41)经过进一步推导可得：
36
入e [ r) = log
ZqM©4/血+1
=1()2一小，/* % = 1MM
-°S	% = °)A+I
Tog Z(pG*P@x =q\0= P)B* °s \(八2％尸(％=q\?=?)心
(3-42)
+抽薪"产⑴/r，03)然 工皿息讨出M+\=q，2=P)鼠

P(u = 1)
=4：+ 2P / + A? /
式中人,t是经过信道传输的信息位提供的信息:
% = log
P(* % = 1)
P(xt I w, = 0)
=&X]
(3-43)
式中4t表示另一分量译码器传递的信息，初始值为0。
式中小,t表示外信息，其计算方式如式(3-44)所示：
4 Io. Z(「g)3一尸G一。二== P)葭
"一° E"*p(y，\*=q，，=p)限
(3-44)
上式的计算方法可以参考式(3-40)的推导过程。
以上各式使用了大量的对数和指数运算，这在实现中也是一个巨大的困难， 所以对上式进行简化处理，利用雅阁比(Jacobian)公式做近似处理，Jacobian公 式如式(3-45)所示：
In (e" + e') = max (x, y) + In (1 + e~^~^)	(3-45)
如式(3-45)所示，该公式将两个指数做加法后再进行对数运算简化成两个 指数比较大小的运算，大大降低了计算复杂度。式中等号右边的第二项，可以利 用查表法进行近似处理，利用|x-y|的大小作为查表输入，得到该对数值。该操 作几乎不会影响译码性能。
以上介绍了 Log-MAP算法，对于上述算法来讲还需要进行两步操作，第一 比较指数大小，第二根据两指数差值对进行查表操作。查表操作会极大降低译码 器的吞吐率，所以对式(3-45)进行进一步简化得到了 Max-Log-MAP算法叫〕： ln(eT+ev)«max(x, v)	(3-46)
进一步推广上式可以得到:
37
In WX j ~ max (七)	(3-47)
按照式(3-47)进行简化计算，可以极大提升译码的运算速度，可以认为在 计算时直接选择最大度量值。这样的简化计算会对译码性能造成一定影响，使得 Turbo译码器大概损失0.3dB左右，这就需要在工程实践中进行权衡，在译码精 度和计算复杂度中做出取舍。
3.3低复杂度SOVA算法
本章第二节介绍了两种主要的Turbo码译码算法，一种是基于最大后验概率 的MAP算法，另一种是基于维特比算法的SOVA算法。Turbo码的编译码方式 和迭代译码的结构决定了其有较大的译码时延，其时延主要由交织和译码算法引 起。交织器一旦确定，其时延就已经确定，所以影响Turbo译码器的吞吐率主要 由译码算法引起。为了改善算法复杂度，增加Turbo码译码算法的吞吐率，对 MAP算法和SOVA算法的复杂度进行比较是十分必要的。
3.3.1	SOVA算法与MAP算法复杂度比较
本节主要对SOVA算法、MAP算法、Log-MAP算法和Max-Log-MAP算法 进行对比，对四种算法的译码复杂度进行对比，并为后续提出一种简化的SOVA 算法提供方向。
这四种算法的共同点是搜索对应于信息比特的两个度量值最大的分支，输出 两条路径的差值作为软判决信息、，且这四种算法都可以接收来自信道信息和令一 个分量译码器的先验信息作为输出，输出判决值且给出最大后验概率。
由322节可知，MAP算法和Log-MAP算法都是基于所有可能路径的计算 方法，且两种算法在路径的选择和取得软判决信息的方法上也是相同的。但是由 于MAP算法中存在大量乘法及指数运算，对其进行对数域变换，变为Log-MAP 算法，使其具备实用性。对于Log-MAP算法用式(3-45)进行近似计算，这会 造成一定损失，但是并不会明显影响译码性能。同样地，Max-Log-MAP算法对 Log-MAP算法进行进一步简化，省略了 Log-MAP算法中的加法和查表步骤，从 算法层面来讲，这造成了 Max-Log-MAP算法变为寻找最大似然路径分支，其译 码性能相比于Log-MAP算法会有所下降。但是，Max-Log-MAP算法这种寻找最 大似然路径的方法和SOVA算法相似，且由上一节对两者的推导可以看出Max-Log-MAP 算法和SOVA算法有着相似的分支度量函数，二者具有极大地相似性。
Log-MAP算法是MAP算法的对数变换，二者在算法上是等价的，几乎不存 在性能损失。进行Log-MAP算法译码时，对于格图中的每条路径都要将其分为
38
两种，输出0的分支路径和输出I的分支路径。所有经过0的分支路径和所有经 过1的分支路径的比值就是该码字中信息位的后验概率。
Max-Log-MAP算法是Log-MAP算法应用最广泛的简化算法,它在Log-MAP 算法的基础上对Jacobian公式进行近似处理。Max-Log-MAP算法计算对应于输 出为0和1的分支度量和，且以二者的差值作为软判决输出。在计算后验概率时 只考虑最大似然路径和最大竞争路径。在计算前向分支度量和后向分支度量时， 只考虑最大竞争路径的变化所带来的后验概率的转变。
与基于MAP算法的译码思路不同，根据第二章对维特比算法搜索路径算法 的简化可以看出，SOVA算法只搜索最大似然路径，并不会遍历译码格图中的每 个节点，在搜索路径上即存在巨大优势。从第3.2.1节对SOVA算法的推导可以 看出，SOVA算法计算前向度量值的方法与Max-Log-MAP算法一致，但是SOVA 算法无需计算后向分支度量，因此SOVA算法相比较于Log-MAP算法会有精度 上的损失，损失程度大约0.5dBo但是从搜索路径和计算复杂度的角度来讲， SOVA算法相比于Log-MAP或Max-Log-MAP算法具有巨大的优势。
假定编码长度L,编码器寄存器个数为v, SOVA算法中反向修正长度为3。
MAP、Log-MAP> Max-Log-MAP及SOVA算法复杂度分析如表3-1所示。
表3-1四种Turbo译码算法复杂度分析
MAP	Log-MAP	Max-LogMAP	SOVA
加法运算	4x 2V	15 x 2V + 9	10 x 2V + 11	2 X 2V 4- 8
乘法运算	6 x 2V + 1	8	8	8
指数运算	6	0	0	0
最大值	0	5 x 2V - 2	5 x 2V - 2	2 x 2V + 6/2
查表操作	0	5 x 2V - 2	0	0
存储量	(L + l) x 2V+1	(L+l) x 2V+1	(L+l) x 2v+1	(8 + 3) x 2V
从表3-1中可以看出，MAP算法的复杂度最高，Max-Log-MAP算法相比于 Log-MAP算法复杂度稍有降低，且无需查表操作，SOVA算法与Max-Log-MAP 算法所需操作基本相同，当分量编码器约束长度超过4时，Max-Log-MAP算法 的计算量将达到SOVA算法的两倍以上。
由以上分析可知，当译码器寄存器个数不小于4的情况下，SOVA算法的计 算复杂度要明显低于其他三种算法。并且，由于第二章已经介绍的对Viterbi算 法搜索路径的改进，又可以大大减少格图的搜索范围，更加降低SOVA译码算法 的算法复杂度。基于以上两点原因，SOVA算法具有相当大的应用前景。对于已 经具有较低算法复杂度的SOVA算法进一步简化使得其具有更加广阔的应用场
39
旦
o
本章第3.3.2节和第3.3.3节提出了一种继续简化的SOVA算法(Trimming SOVA),以下简称为T-SOVA算法。
3.3.2	Lazy维特比译码算法
SOVA算法主要包含两个步骤：第一步是寻找最大似然路径(MLPath),第 二步是根据最大似然路径和最大竞争路径的差值计算每个信息比特的对数似然 比。SOVA算法的计算复杂度主要是由回溯路径的个数和度量差值的个数决定。
由第二章对维特比算法和其低复杂度译码算法的优化可知，序列译码算法和 A*算法，在高SNR条件下基于深度优先的搜索方式，比维特比算法更加有效， 但是在低SNR条件下这种搜索会变得相对缓慢。对于序列译码算法来讲，在低 信噪比条件下，译码树的分支会急剧增加，基于分支数量的分支度量值和门限计 算也会变得非常困难，且序列译码算法本质上搜寻的并不是最大似然路径。对于 A*译码算法来讲，该算法结合了维特比译码算法和序列译码算法的优点，当高 SNR条件下，A*算法按照序列译码算法的方式进行，但是A*算法目前还不能应 用于连续的数据流译码。
毋庸置疑，在高SNR条件下，利用序列译码算法会极大降低维特比算法的 复杂度，但是，在低SNR条件下序列译码算法和A*算法都还存在一些问题。所 以必须要对序列译码算法进行改进，使它保证在低信噪比条件下译码复杂度不超 过维特比算法，且译码性能与维特比算法相比几乎没有损失。
3.3.2.1	Lazy-Viterbi 译码算法步骤
对上述问题的探索已经在第222节提出的MLSDA算法中有所体现，为了 更适应SOVA软输出的特性，对第二章提到的MLSDA算法进行小幅度的修改， 提出了更适应SOVA算法的Lazy-Viterbi译码算法⑵】。
Lazy Viterbi译码算法中包含两个非常重要的计算模块，一个是译码网格图 (trellis),另一个是优先序列PQ (priority queue) □译码格图中的各个节点都 是从起始节点位置到当前节点的最短路径，在格图中每个节点u都有一个指针指 向它的前向节点Prev(u),且每一个节点都有其扩展路径，可以到达下一个节点 V。优先序列由一系列尾随节点(shadow nodes)组成。每一个尾随节点都是当前 节点的潜在扩展路径，使当前节点延展到下一个节点u。若用比来表示优先序列 中当前节点u的尾随节点，每个尾随节点都有一个累加度量值acc5)，其值表示 从u到&下勺路径度量，在优先序列PQ中的丘的排列顺序主要取决于accQ),将
40
PQ中的度量值acc(Q)按照从小到大排序，且每一个在优先序列中的尾随节点的 前向节点都必须保证已经位于格图向量中。
在译码的起始状态下，译码格图为空，优先序列中包含起始节点s的尾随节 点灯且有acc(§) = 0。译码开始后，优先序列PQ中不断有新的尾随节点插入， 每次选取优先序列中包含最小度量值的尾随节点，再将尾随节点插入到网格矩阵 中，使网格矩阵向译码序列的终点不断延展。若当前优先序列中的尾随节点已经 存在于网格之中，则丢掉该优先序列中的点，因为此时已经有距离更短的路径存 在于译码网格路径中；否贝IJ,对于网格矩阵中的新插入节点u, Prev(u) = Prev(u), 对于当前插入节点u的全部尾随节点v,。将被插入优先序列PQ,其度量值大小 为 acc(i5) = M + d(u, v)o
下面介绍Lazy-Viterbi译码算法的步骤：
1	.结合第222节提出的非负分支度量值d(u,v)的计算方法，计算所有可能 的输出符号的分支度量值；
2	.初始化优先序列PQ,在格图(trellis)中插入节点s；
3	.取出优先序列PQ中最小值所对应的节点(即位于PQ堆栈中最上方的 值)；
4	.若该节点已经位于格图中，则丢掉当前取出的节点，继续步骤3,否则将 该节点插入译码格图中，继续步骤5；
5	.计算新插入节点的路径度量值acc(。)，将该节点插入优先序列PQ中；
6	.如果优先序列PQ中位于顶端的节点不是译码终止节点，则返回继续执 行步骤3；
7	.回溯最大似然路径，输出最大似然路径对应的硬判决输出。
上述Lazy-Viterbi算法的译码步骤是由Jon Feldman等人与2002年提出，由 该算法的译码步骤可知，它的输出仍是硬判决结果。和1。为了适应适应SOVA 算法的输出，使其能够应用在Turbo码分量译码器中，对上述译码算法中的步骤 4做出修改，让它为SOVA算法的软输出提供信息。
更新步骤4：若PQ中取出的节点已经位于格图中，则计算当前存在与格图 中的最大似然路径度量值和当前竞争路径度量值的差，即笛=M2 - CMK
3.3.2.2	Lazy-Viterbi 译码算法分析
Lazy-Viterbi译码算法与维特比译码算法及A*译码算法的算法复杂度列表如 下：
41
表3-2最大似然译码算法复杂度分析
极高SNR	极低SNR
Viterbi译码算法	0(2k)	0(2k)
A*译码算法	0(logL)	日(2Klog(L2K))
Lazy-Viterbi译码算法	©(I)	0(2k)
其中K表示编码器中移位寄存器个数，L表示译码块长度。表3-2统计了 Viterbi译码、A*译码和Lazy-Viterbi译码三种算法的复杂度，下面对表3-2进行 分析。
Viterbi译码算法不论信噪比条件如何，始终保持®（29的计算复杂度，且与 编码器的约束长度成指数相关，在高信噪比条件下并没有充分利用当前的有利条 件降低算法复杂度。A*译码算法在高信噪比条件下的译码复杂度仅和译码块长 度L有关，这解除了约束长度K的桎梏，是极有意义的尝试，但是在低信噪比 条件下，A*译码算法的复杂度甚至会高于Viterbi译码算法。Lazy-Viterbi译码算 法将两者的优势结合起来，在高信噪比条件下其译码复杂度与A*译码算法相似, 但在低信噪比条件下，保证了译码复杂度不高于Viterbi译码算法。
图3-5展示了以上三种译码算法每个信息符号所需扩张的平均节点个数，编 码速率1/2,编码器约束长度为9,编码多项式八进制表示为（752, 541）,编码 器输入信源长度为100比特。
l_q Jnd-no」8d p①puedx① s①pou s三①」j
图3-5三种译码算法平均扩展节点数统计
综合表3-2和图3-5可以得出结论，Lazy-Viterbi译码算法主要存在三个优 点：首先，Lazy-Viterbi译码算法与MLSDA算法相似，都符合最大似然译码准 则；其次，在信噪比条件较好的情况下，Lazy-Viterbi译码算法的复杂度远低于
42
传统Viterbi译码算法；最后，在信噪比条件较差的情况下，Lazy-Viterbi算法的 译码复杂度不会高于传统Viterbi译码算法。
3.3.3	T-SOVA (Trimming SOVA)算法
通过前几节的分析，本节将介绍一种新的低复杂度SOVA算法，即简化的软 输出维特比译码算法(TrimmingSOVA),因此本算法简记为T-SOVA算法网29］。
为了减少度量差值的个数，首先应对SOVA的第一步进行优化，所以我们采 用Lazy-Viterbi译码算法进行最大似然路径的选择。Lazy-Viterbi译码寻找最大似 然路径极大降低了搜索路径的宽度，利用Lazy-Viterbi算法搜索ML分支仅仅是 T-SOVA算法的第一步，结合3.2.1对SOVA算法对数似然比LLR的介绍，T-SOVA算法的第二步就是要计算各个信息比特的软输出信息。
针对Lazy-Viterbi基于深度优先的思路发现，在信道条件较好，信噪比较高 的情况下，并不是每一个最大似然路径都有相应的竞争路径能够被插入到译码格 图中。在极端情况下，当信噪比极高时，可能大部分竞争路径没有机会排到优先 序列PQ的顶端。信噪比较高，即根据Lazy-Viterbi快速寻找到ML路径的情况 如图3-6所示：
LLR(t-l) LLR(t) LLR(t+l) LLR(q)	LLR(t+2 6 )
I.获得LLR的节点	ML路径	!
：二 \	I
：1 被忽略LLR的节点	路径 被忽乱勺竞争路径
一国HMEa务工t/f霹殍露回百目拓卷一
图3-6中加粗的实线表示经过Lazy-Viterbi算法搜索得到的最大似然路径， 实线表示在搜索过程中搜索到的某些节点的最大竞争路径，虚线表示在Lazy-Viterbi译码过程中被忽略掉的分支路径。由以上介绍可知，图中只有实心圆表示 的节点有软判决信息A3其他节点并没有通过竞争路径与最大似然路径的差值获 得软输出信息。
正是由于Lazy-Viterbi算法的这种特性，使我们在计算软判决输出LLR时有 如下两点优势：第一，由Lazy-Viterbi译码的过程我们可以知道，这种算法天然 地找到了节点的最大竞争路径，计算出了与最大似然路径最接近的缄，结合式(3-
43
24),这种算法从搜索机制上就适合于SOVA算法的计算和简化。第二，Lazy-Viterbi算法给那些被忽略掉的路径节点提供了更低的对数似然比LLR边界值， 这种削减了路径度量差值的算法更加适合于SOVA算法的简化计算，即T-SOVA 算法。
由Lazy-Viterbi算法可知，任意被忽略掉的分支路径差值都比距离该节点最 近处已经得到的LLR值大。这个结论极易证明，因为Lazy-Viterbi算法首先取出 某一点的ML路径值，后面再取出的就是竞争路径的最大值，其他任何路径都不 会比这个竞争路径的度量值再大了，所以得到的纯已经具有了最小值。根据这个 结论，我们可以近似得到那些被忽略的节点的LLR值：任何被忽略的节点处的 LLR值都比那些已经计算出LLR值的相邻节点处的值大，对于时刻3其中相邻 节点的范围为£ = t + l,....,t + 25o
由上面得到的结论，那些被忽略的节点处的LLR值可以由式(3-48)得到：
\LLRn(t^\LLR{q^	(3-48)
式(3-48)中的LLR(q)是｛|LLR(t + 1)|, |LLR(t + 2)|,…，|LLR(t + 26)|｝中的最 小值。
时刻/处的对数似然比LLR如式(3-49)所示:
LLR(J) = ln
迎=+1 ] D =T卜)
2⑺ % = +1)	/(%=+1)
p｛r\ut =-1)	p(%=-l)
Max-Log近似公式由式(3-50)表示：
In (x + y) = max (in x, In y)
(3-49)
(3-50)
综合式(3-49)和式(3-50)可得到LLR在时刻/处的值：
〃况(1卜0.5〃("勺(々=+1) —= -1)) + 4+"(月)	(3-51)
式中L如式(3-13)所示，儿表示先验信息，表示时亥贝+1)最大似然 路径上的节点，Si+i表示时亥1(1+1)的普通节点，式中火0)如式(3-52)所示：
△(尸)=In g+1(7〃4+J — In 力+i (% J	(3-52)
且有
!nA+i (^/+i) = ln/?0；＞/ l^/+i)	(3-53)
先将LLR的一部分只考虑信道信息和先验信息的影响，将d(£)由式(3-48) 表示，可以得到〃此：
\LLRi (z)i- I。乜 L - q (% = +1)	(% = -1))1 + \La (/)|	(3-54)
综合式(3-48),式(3-51)和式(3-54)可以得到那些在ML路径上竞争
44
分支被忽略的LLR的计算公式：
〃穴(/) = 〃«(/) + 〃k(/)	(3-55)
为了将T-SOVA算法应用到Turbo译码器中，需要分量译码器在迭代过程中 输入外信息Le：
4。) = 2 •(〃"(/)-40)	(3-56)
式中外和%为计算外信息的修正因子网］，可以避免两个分量译码器之间外信 息传递的相关性随迭代次数不断增加，从而造成译码性能的损失，增加该修正因 子的作用即为降低外信息相关性使SOVA算法性能更接近于Log-MAP算法。 乙⑷表示分量译码器的内信息，由信息位的信道信息和传入本译码器的先验信息 构成。
为了进一步简化SOVA算法，T-SOVA算法还设立了一个简化参数M,用来 限制分支度量差值队列的长度。假设竞争路径和最大似然路径的度量差值队列长 度超过L/M,则只取前L/M最小的值。利用这种简化参数M,可以使T-SOVA算 法的复杂度降低为SOVA算法的1/M。
综上所述，T-SOVA算法计算步骤可以归纳为以下5步：
1	.利用Lazy-Viterbi算法寻找最大似然路径；
2	.假设最大似然路径与竞争路径的度量差值大于L/M长度，选取最小的 L/M个度量差值，其余的度量值舍弃；
3	.检查是否最大似然路径上的节点的LLR值都已经有值，若某些LLR值 仍为8,则利用式(3-55)计算该处的LLR；
4	.用LLR的符号作为判决依据，若为负数则输出1,为正数则输出0；
5	.利用式(3-56)计算分量译码器输出的外信息L，并将外信息作为先验信 息传递给另一个分量译码器。
本节提出了 一种新的基于SOVA算法的简化算法，即T-SOVA算法，本算法 使得SOVA算法寻找最大似然路径更为直接，需要计算的软判决信息的数量大 大减少，且队列的存储及插删操作的复杂度变为原来的1/M。然后我们又给出了 将T-SOVA算法应用到Turbo码分量译码器中的方法,下一节将针对基于T-SOVA 算法的Turbo码译码器进行译码性能仿真及复杂度分析。
3.4低复杂度Turbo码性能分析
3.4.1	Turbo码译码性能分析
第三节详细介绍了一种低复杂度Turbo译码算法，即T-SOVA算法。本节将
45
对上节提出的Turbo译码算法进行性能仿真及复杂度分析。
如3.1.2节所示，采用CCSDS标准Turbo码结构，寄存器个数为4,码率为 R=l/6,码长为256和6144,迭代次数为8次，交织器采用符合3GPP标准的QPP 交织器，参数列表如表3-3所示：
表3-3 3GPP标准QPP交织器参数列表
码长L	fi	fl
1	256	15	32
2	6144	263	480
对基于T-SOVA.算法的Turbo译码方案及传统的Log-MAP算法及Max-Log-MAP算法进行译码性能仿真，T-SOVA算法的简化因子M = 4,8,16,64,外信息修 正因子% = 0.92, 92 = 0.89,仿真曲线如图3-7和图3-8所示。
D1
LU
CQ
10°
10-1
10-2
10'3
10-4
W5
W6
-0.5	0	0.5
1.5
Eb/N0(dB)
图3-7码长256不同Turbo译码方案BER仿真曲线
46
LU
CQ
-0.8	-0.6	-0.4	-0.2	0	0.2	0.4	0.6	0.8	1	1.2
Eb/N0(dB)
图3-8码长6144不同Turbo译码方案BER仿真曲线
* Log-MAP 6144
—- Max-Log-MAP 6144 SOVA
・ ♦ - T-SOVA M=4
------T-SOVA M=8
T-SOVA M=16
, ・•安・・・ T-SOVA M=64
图3-7和图3-8分别给出了按照CCSDS标准1/6码率编码方式编码的码长
为256和6144的不同译码方案的译码性能曲线。其中红色实线表示利用Log-MAP 方案进行Turbo译码的译码性能，蓝色虚线表示基于Max-Log-MAP方案 进行的Turbo译码的译码性能，绿色表示SOVA方案的译码性能曲线，而紫色、 黑色、青色虚线和蓝色点线分别表示3.3节提出的基于T-SOVA算法的Turbo译 码的译码性能曲线。
由图3-7和图3-8给出的性能仿真曲线进行分析,Log-MAP算法的译码性能 最优，但是根据第3.2.2节给出的Log-MAP算法的计算方法可知，Log-MAP算 法需要大量的存储空间及查表操作，并不符合低复杂度译码的需求。Max-Log-MAP方案省略掉了 Log-MAP算法中的查表操作，将加法器变为比较器，大大降 低了 Log-MAP算法的计算复杂度，将Max-Log-MAP算法输出外信息乘一个系 数Scale=0.75,其性能相比于Log-MAP算法在BER低于10-5的条件下，有大约 0.3dB的损失。图中绿色虚线为SOVA算法的译码性能曲线，且该SOVA算法对 分量译码器的输出应用了同T-SOVA算法一致的外信息修正因子，从仿真性能上 来看，SOVA算法的外信息经过修正后与Max-Log-MAP算法性能基本相同。但 是由321节对SOVA算法的介绍可以看出，SOVA算法基本省略了计算后向分 支度量值B，使得计算量减小1/3左右。图中紫色和黑色虚线分别代表了第3.3节 给出的基于Lazy-Viterbi算法寻找最大似然路径(MLPath)和基于T-SOVA算法 计算信息比特软输出信息的译码性能，且限制分支度量差值队列长度的简化因子
47
M=4,8,即将分支度量差值队列长度限制在〃4或〃8以内，可以大大减少译码存 储空间的使用。由上图可知，基于T-SOVA算法的译码性能在简化因子M=4,8时 与Max-Log-MAP算法和SOVA算法相比基本没有性能损失，继续增加限制，当 M=16时，译码性能大约损失O.ldB。若继续增大M,当M=64时，译码性能受 到较大影响，在BER低于IO-的条件下，译码性能损失将超过IdB。
通过图3-7和3-8对本论文提出的低复杂度Turbo译码方案进行的性能仿真 可以得到结论：本论文所研究的基于T-SOVA算法的低复杂度Turbo译码方案有 着与Log-MAP算法和Max-Log-MAP算法相似的译码性能，且其译码复杂度相 比较于前两者有较大幅度下降，是一种行之有效的Turbo译码方案。
3.4.2	EXIT图分析
Turbo码采用迭代译码机制在两个分量译码器之间交换软信息从而提高译码 准确度并能逐渐逼近香农限。观察两个分量译码器输出的系统位和外信息的情况, 能够更好地分析译码器迭代的收敛行为。EXIT (Extrinsic Information Transfer) 图即是一种用来分析互信息的非常有用的工具。
外信息传递特征反映的是一个分量译码器的先验输入和外信息输出之间的 关系，Turbo码由两个分量译码器组成，EXIT图就是要分析两个分量译码器的外 信息传递特征，得到外信息的完整传递过程。其生成过程就是将两个分量译码器 的外信息的互信息传递图画在同一张图上，并且横纵坐标对换，这样就能得到在 某一信噪比条件下Turbo译码器的EXIT图因心丸
本论文所研究的基于CCSDS标准的Turbo编码方案，本节将对其互信息转 移度量的分析。首先对生成多项式为(023,033,025,037)的Turbo码分量译码器 1的传递特征曲线进行分析，然后对341节进行仿真的码长为256和6144的两 种Turbo码进行EXIT图分析国。
图3-9给出了编码输入码长为6144情况下，不同Turbo译码方案在 &/N。= OdB时生成多项式为(023,033,025,037)的分量译码器1的外信息传递 特征曲线。
图3-9画出了 Log-MAP算法、Max-Log-MAP算法和T-SOVA算法三种Turbo 译码方案的外信息传递特征曲线，图中横坐标I_A表示分量译码器1的输入互 信息，纵坐标I_E表示分量译码器1的输出互信息。通过蒙特卡洛仿真可以得到 如下结论，当队列简化因子M=4时，T-SOVA算法与Log-MAP算法、Max-Log-MAP 算法的互信息传输性能基本相同，所以其迭代译码性能也基本相同，得到 相同译码性能所需的迭代次数也基本相同，当简化因子M=8,16时，通过外信息 传递特征曲线可以看出性能会有所下降，当M=64时，性能将急速恶化。
48
图3-9码长6144不同Turbo译码方案外信息传递特征曲线
图3-10和图3-11分别展示了当简化因子M=4时，T-SOVA算法在不同信噪
比条件下，码长为256和6144的外信息传递图。图3-12中展示了码长为256和
码长为6144的两种编码长度的互信息转移的比较，让我们能够直观比较短码和
长码互信息传递的差异。
,…△…-0.5dB分量译码器1
…米…-0.5dB分量译码器2
-A - OdB分量译码器1
-* - OdB分量译码器2
—^― 1dB分量译码器1
—— 1dB分量译码器2
0	0.1	0.2	0.3	0.4	0.5	0.6	0.7	0.8	0.9	1
IA/IE
1
0.9
0.8
0.7
0.6
<
0.4
0.3
0.2
0.1
0
图3・10码长256不同信噪比PSOVA算法EXIT图
49
<
L1J
A -OdB分量译码器1
―兴一-OdB分量译码器2 一4- -O.2dB分量译码器1 一米一 -0.2dB分量译码器2
-0.3dB分量译码器1
-0.3dB分量译码器2
…•△…-0.5dB分量译码器1
-O.5dB分量译码器2
0	0.1	0.2	0.3	0.4	0.5	0.6	0.7	0.8	0.9	1
IA/IE
图3-11码长6144不同信噪比T-SOVA算法EXIT图
图3-12码长256和6144时互信息转移曲线比较
图3-12直观地展示了长码和短码的互信息传输差异，即长码在迭代过程中 有更低的收敛门限，且其收敛速度明显快于短码，这也符合341节中译码性能
50
曲线所展示出的规律。
EXIT图可以有效地表示迭代译码过程中的外信息传递过程，利用EXIT图 可以直观地预测译码所需的迭代次数和译码收敛门限，并且可以指导译码方案的 设计，确定所需的译码迭代次数和分量码的设计。通过对基于T-SOVA算法的 Turbo译码方案EXIT图的分析可以发现，T-SOVA算法的迭代收敛性能并不弱 于基于最大后验概率的Log-MAP算法、Max-Log-MAP算法，进一步证明了本方 案的可行性和实用性。
3.4.3	算法复杂度分析
本章第3节已经详细介绍了 SOVA算法同MAP算法、Log-MAP算法和Max-Log-MAP算法的计算复杂度比较结果。且根据该结果可以得出SOVA算法在约 束长度为5,即编码器中寄存器个数为4时Max-Log-MAP算法的计算量几乎是 SOVA算法的两倍，故本节着重于对T-SOVA算法和SOVA算法的复杂度进行对 比。
SOVA算法和T-SOVA算法的复杂度的主要区别在于找到最大似然路径后回 溯操作的数量，回溯操作进行的次数将对算法复杂度产生重要影响。表3-4给出 了 SOVA算法和T-SOVA算法的平均回溯操作的次数。由表3-4可以看出T-SOVA 算法仅需要SOVA算法回溯操作数量的1/M。
表3-4 SOVA算法和T-SOVA算法平均回溯操作数量统计
SOVA	T-SOVA M=4	T-SOVA M=8	T-SOVA M=16	T-SOVA M=64
L=256	260	64	33	16	4
L=6144	6148	1537	769	383	192
比较SOVA算法和T-SOVA算法的复杂度并不能只比较计算量的大小，还应 该考虑SOVA算法和T-SOVA算法的内存消耗情况。通过对SOVA算法的分析 和推导可以利用SOVA算法和T-SOVA算法中所需扩展节点的个数来统计两种 算法的内存消耗情况。表3-5和表3-6分别给出了不同信噪比条件下256码长和 6144码长平均扩展节点个数。
由第332节所介绍的Lazy-Viterbi算法寻找ML路径的方法可知，T-SOVA 算法扩展节点的个数与信噪比条件有关，当信噪比条件较好时，其扩展节点的个 数将大大降低，当信噪比条件较差时，其扩展节点个数不多于SOVA算法。根据 表3-5和表3-6的统计情况可以看出相比较于SOVA算法，T-SOVA算法所需的 内存消耗量有明显下降，当Eb/N0大于3dB时，T-SOVA算法的内存消耗情况仅 为SOVA算法的20%到30%。
51
表3-5码长256平均扩展节点数量统计
Eb/N0 (dB)	-0.5	0.0	0.5	1.5	3.0
T-SOVA M=4	8038	6420	5436	3524	1808
T-SOVA M=8	8097	6503	5478	3602	1808
T-SOVA M=16	8103	6616	5456	3618	1808
SO\^	8220	8220	8220	8220	8220
表3-6码长6144平均扩展节点数量统计
Eb/N0 (dB)	-0.8	-0.5	0	0.5	3.0
T-SOVA M=4	196506	153598	82588	53788	39398
T-SOVA M=8	196532	153684	82608	53802	39398
T-SOVA M=16	196579	153726	82612	53815	39398
SOVA	196636	196636	196636	196636	196636
通过本节对T-SOVA和SOVA算法译码性能，收敛行为和计算复杂度的详细 对比可以看出，本论文所研究的Turbo译码算法具有译码性能与Max-Log-MAP 算法基本相同，迭代收敛性能不弱于Log-MAP算法，且译码复杂度远远低于前 面两种算法的特点，故将T-SOVA算法作为Turbo码的一种低复杂度译码方案具 有相当广阔的应用前景。
3.5本章小结
本章主要介绍了一种相较于当前普遍使用的MAP算法、Log-MAP算法和 Max-Log-MAP算法复杂度较低的T-SOVA算法，该Turbo译码方案是通过对 SOVA译码算法的两大主要步骤进行优化进而得到的一种低复杂度Turbo译码方 案。
本章第一节介绍了 Turbo码的原理及编译码器结构，并详细介绍了 Turbo译 码器中至关重要的交织器模块。在第3.1.2节介绍了本论文重点关注的CCSDS标 准的Turbo编码器结构，并详细介绍了不同码率校验比特的选择，为后续的译码 性能仿真做出铺垫。
52
本章第二节对当前普遍使用的Turbo译码方案进行详细的算法介绍和理论 推导。首先将第二章所提到的基于Viterbi硬判决输出的信道译码方案变为软输 出维特比译码，即SOVA,并详细推导了软输出判决LLR的计算过程。作为对 比，3.2.2节给出了 MAP算法、Log-MAP算法和Max-Log-MAP算法的推导过程 和计算方法，并且在第三节对上述两种基于SOVA算法和基于MAP算法的译码 复杂度进行对比，通过复杂度分析确定了 SOVA算法在译码复杂度上的优势地 位。
本章第三节在SOVA算法的基础上，进一步对其复杂度进行简化：SOVA算 法的第一部分——寻找最大似然路径利用Lazy-Viterbi方案进行优化，SOVA算 法的第二部分——计算软判决信息LLR及计算分量译码器的输出外信息儿利用 分支度量差值队列简化因子M进行简化处理，得到了一种新的简化Turbo译码 方案(Trimming SOVA),即 T-SOVA 算法。
在本章最后，对本论文所提出的基于T-SOVA算法的低复杂度Turbo译码方 案进行浮点性能仿真，仿真不同的简化因子M对T-SOVA算法性能的影响，以 期找到译码复杂度和译码性能的平衡点，并将该算法与Log-MAP算法和Max-Log-MAP 算法进行仿真性能和译码复杂度比较，并利用EXIT图对该迭代译码 方案进行分析。
53
54
第四章T-SOVA算法在MIMO-SCFDE通信系统中的应用
第三章详细介绍了一种低复杂度软输出维特比译码算法，并展示了 T-SOVA 算法的推导过程及复杂度优势，最后又将T-SOVA算法的输出变为适用于在两个 分量译码器之间传递的外信息，成功将该算法应用到了 Turbo译码算法中。经过 第四节对译码器进行单独的模块化仿真可以看出，该低复杂度Turbo译码算法取 得到了不错的译码效果。
但是这种新的低复杂度Turbo译码算法性能优劣的判断还需要进一步在实 际通信系统中进行验证。本论文所研究的Turbo译码器就是针对单载波频域均衡 系统(MIMO-SCFDE),在超远距离点对点通信的过程中，对低复杂度信道译码 的需求而设计。所以需要对这种低复杂度Turbo译码器在MIMO-SCFDE系统中 的性能进行仿真和测试。
4.1	MIMO-SCFDE 系统介绍
本论文所研究的Turbo译码器的应用场景是基于实验室的项目“超低信噪比 条件下MIMO-SCFDE点对点通信系统的设计与实现”进行的研究。该项目是针 对超远距离的特殊通信场景而设立，对通信算法的鲁棒性和实用性都有极高的要 求，具有非常高的实用价值。本项目在超远距离通信系统中应用，可以工作在点 对点低速通信状态中，整个系统的架构框图如图4-1所示。
其中发送端包含Turbo编码、速率匹配、QPSK映射、加扰、空时编码(STBC) 和成帧等操作，实现发送链路的全过程，经过发射机的射频操作最终由两发送天 线发射。
本论文中根据不同的信源速率采用不同的Turbo编码长度，主要涉及码长为 256、6144和10304,编码速率为1/6, Turbo码的内部交织结构采用QPP交织器 完成，交织器的生成多项式按照3GPP给出的LTE标准Turbo编码器实现。
速率匹配单元将不同传输速率的业务信息进行重复补偿，从而匹配唯一的帧 结构格式，本项目的传输速率分为128Kbps、512Kbps和1024Kbps,在业务信息 数据块的单位时间20nls内对不同速率的编码结果进行重复和补偿，以此来填充 帧结构中的位置，然后送入QPSK调制模块。
STBC单元采用Alamouti空时编码方案，将串行数据分为两路并行，充分获 得空间分集增益本系统采用空时块编码，以1024bit为一个数据块进行空时编 码，空时编码方案如图4-2所示。
55
1
-I
I
J
图4-1超远距离通信系统设计架构流程图
第一个数据时隙	第二个数据时隙
第一个数据时隙第二个数据时隙
*天线1 §书（@虱分.,虱"-叫以丑⑨e（砥

* 天线 2	$=[虱脑("..“虱乂-1)]	Sj=[s；(0),s；(MT),..“s；(1)]
图4-2空时块编码方案设计图
成帧单元的主要作用是对发送数据进行结构设计，使其按照预先设计好的帧 结构进行位置排列。帧结构是通信算法中非常重要的设计环节，帧结构的好坏将 直接影响整个通信系统的性能。本项目由于采用单载波频域均衡系统，在设计时 考虑多径信道的多普勒及频率选择性衰落等因素，最终利用自相关特性极佳的格 雷互补序列作为帧头和导频，本项目帧结构示意图如图4-3所示。
本项目的信道为多径衰落信道，且整个通信链路的信噪比较低，为了对抗超 低信噪比，在方案设计中充分利用的时分复用和空分复用技术，利用帧结构中的 重复结构，提升系统接收端的信噪比。野外实际测量多径信道功率变化及多普勒 频率如图4-4和图4-5所示，对多径信道的建模如图4-6所示。
56
♦帧头T
”卜充信息和CP・j一帧头中
衿卜充信息和CP»
F01 F02 1  • - 100 101 •  • 200 1 •  - 20 CPI Fl 1F12 201 ■ ■ ■ 30C 301 •  - 400 21 • • - 40 CP2
2*4096个GCS同步符号
CP 1024个数据符号
2*4096个GCS同步符号
—时隙:333.33us —>|	—时隙:333.33us ―J 时隙:42.317us T
图4-3超远距离通信系统MIMO-SCFDE帧结构示意图
图4-4野外实测多径功率变化情况

datal data2 data3 data4 data5 data6 data7
dala8 data9
datal 0 datal 1
datal 2 datal 3
datal 4 datal 5
datal 6
」①Mod」①-ddoa
图4-5野外实测多径信道多普勒频率
57

图4-6实际多径信道建模
本项目的接收端包含了从接收链路到射频信号处理到最终信道译码的整个 过程。首先对基带的接收序列进行解扰处理，然后通过帧结构中特定位置的帧头 和导频对实际信道进行多径信道估计，利用信道估计值对接收序列进行频域均衡 操作，最后将均衡结果输入到译码器中，进行Turbo译码。
信道估计单元利用帧结构中的导频进行信道估计，通过对格雷互补序列做相 关来估计多径信道的信道信息，获取信道响应值，从而还原发端的发射信息。本 项目的帧结构设计采用格雷互补序列作为导频，利用块状导频来克服远距离传输 带来的低信噪比影响。在计算中采用线性差值，滑动窗的方式，提高信道估计的 准确性。
均衡模块应用频域均衡技术，对多径衰落信道造成的码间干扰进行消除，并 通过帧结构中的重复结构，提高均衡计算过程中的信噪比。本项目中的均衡模块 采用最小均方误差算法（MMSE）,该算法要求均衡器的输出信号与实际发射信 号的均方误差最小时系统性能最优，通常将以MMSE为准则的滤波器称为维纳 滤波[35],因其实现简单故而应用广泛。
Turbo译码单元采用本论文所研究的T-SOVA算法，从而实现低复杂度信道 译码。将本论文中第三章所提出的低复杂度Turbo译码算法应用到本项目的系统 中，可以充分检验本论文所研究的算法的实用性和鲁棒性，为后续硬件实现提供 理论依据。
58
4.2	MIMO-SCFDE系统关键技术及性能仿真
4.2.1	信道均衡算法介绍
为了对抗无线信道的符号间干扰，在实际通信系统中会使用均衡器进行干扰 消除。均衡器的作用就是把所有存在码间干扰的接收序列｛j｝变为无码间干扰的 ｛%｝。其中最先被使用的均衡器为时域均衡，该方法被广泛应用于音频传输系统 和其他多种数字通信系统。它的主要组成部分是横向滤波器，其结构如图4-7所
O
；输入y （t）	j
! -Tb -1~~k Tb —• • —► Tb I ► ,   ► Tb -1
;――…	—一＜ I
I C-『［	C-N+］丁	Co 丁	Cn 丁
口	—
输出v（t）;
图4-7时域均衡器结构
如图4-7所示，时域均衡是由2N个延迟单元和（2N+1）个加权支路以及一 个加法器构成，氤为各支路的加权系数，即抽头系数。由于输入的离散信号从串 行的延迟单元之间抽出，经过横向路径集中叠加后输出，故称横向滤波器，滤波 器抽头个数的多少取决于多径信道的时延扩展［3曳虽然时域均衡器的设计思路比 较直观，但是硬件实现相当困难。所以在本项目中，均衡器采用基于最小均方误 差（MMSE）的频域均衡方案。下面将介绍本项目方案中的频域均衡算法。
由图4-3所示的帧结构来看，本方案中每1024个符号组成一个FDE块，在 每个FDE块的前面加入16个符号作为循环前缀（CP） 0 CP的作用就是为了在 进行频域均衡操作时将信道与发送符号的线性卷积等价为循环卷积，以此提高均 衡准确度并降低计算复杂度。在实际物理信道中，多普勒频率不超过10赫兹， 所以在一个FDE数据块内，可以假设信道状态不发生变化RI。假设发送符号序 列%的均值为0,方差为成，且符号之间互不相关。假设数据块长度为N, 一个 传输块经过信道后，接收端接收到的信号为：
”=4*居+吗，% = 0/，2,…N—1	（4-1）
其中，%为信道的冲激响应，长度为L （一般情况下L«N） , W"为加性高 斯噪声，均值为0,方差为虑，*为线性卷积运算。
由于信道冲激响应长度为L,所以接收信号的前L-1个符号受到信道冲击响 应的拖尾干扰。在接收端对接收到的信号进行去CP操作，可以将式（4-1）转化 为矩阵形式：
59
(4-2)
y = Hx+w
其中H如式(4-3)所示：
-h0	0	0 ...	九2
hi	h0	•
九 i	九L-l
H =	九L-l		0
0	曲-1	：
：	0	•••	h0
.0	:0	...	hi
hQ .
H为NxN阶矩阵，由于采用循环前缀，信道矩阵具有循环平移特性。
-3 (4
1
自尼…忆O:
对接收到的时域信号做FFT运算，在频域上，由式(4-3)可得：
R = Fy = FHx + Fw
= FHFhFx+Fw	(4-4)
= GS + v
式(4-4)中F和F11分另ij表示FFT和IFFT矩阵，S为信号向量的频域表示， v为噪声向量的频域表示。由于H为循环矩阵，有循环平移特性，因而G = FHFH 为对角矩阵，即：
G = FHFh =成ag 饱闾,…gm}	(4-5)
其中，对角线元素g”表示在第n个频点上，信道的频域响应，g“满足下式:
(4-6)
NT	.2 乃
g"=»k/ N 左=0
一般单载波频域均衡方案的均衡过程如图4-8所示。
图4-8单载波频域均衡过程
上图表示L路信号通过不同的路径先后到达接收端，对各路信号的时频变 换后的数据做加权处理，即乘以如何确定《为频域均衡技术的关键。
其中一种方式为通过最优化均方误差(Mean-Squared Error)来确定《的取 值。均方误差可以表示为：
N-1
\>(左)/"2	(4-7)
左=0
其中£(4)的表达式如式(4-8)所示。
60
£优）=石［区一&「］
L
4壬£切
1=0
(4-8)
(4-9)
欲使MSE最小，需要让£（左）在每个k值都取最小值，即对式（3-11）求导 可以得到如下等式：
.I研+（*）£）+4砂* -/如取="理）*	（4.10）
式(4-10)中i = (l,2,…,L)其中 C?为:
(4-11)
寸为信号方差，L个支路的信号虽然到达接收端的时间不同，但是它们携带 有相同的信源信息，所以各支路信号方差相等。为各支路噪声方差，若假设 各支路中噪声方差相等，即或）=才）=..=庚）=4,上式中的碍可以简化为：
.一 邱*
1a + TWT）	（442）
式（4/2）中a = b；/b3方，为信道估计出的信道系数，理想信道估计时， 有那）=那）。
由于上面的假设，频域均衡操作框图可以变为图4-9的形式:
图4-9各路噪声方差相等单载波频域均衡过程
(4-13)
如式（4-5）所示，信道的频率响应呈现出对角阵的特点，这种形式可以理解
为，通过FFT将时域卷积转化为频域相乘，因而在进行线性频域均衡的情况下， 只需要在频域采样点处进行乘法标量运算即可。因此，最小均方误差（MMSE） 频域均衡矩阵M也呈现对角阵的特点，即
61
M = diag {in0，叫,...,
(4-14)
M可以进一步表示为式(4-15)形式：
(	W] Y1
M = GH GGh+-^—4lN
I	K] , J
(	2
=Gh GGh+^-In	(4-15)
l	Gy i
其中，GH为G的共辆转置矩阵，In为单位矩阵。
在信号的频域上乘以频域均衡矩阵，可以得到频域均衡后的信号§ ：
S = MR = MGS+Mv	（4-16）
最后经过IFFT运算，将频域信号$转化为时域信号如式（4-17）所示：
x = FhS = FhMGS + Mv	，…、
（4-17）
= FhMGFx + FhMFw
以上就是本论文所研究的MIMO-SCFDE通信系统的关键技术，即基于 MMSE的频域均衡技术。由本节的介绍可知，本论文所采用的均衡算法计算简 单，适用范围广泛，且容易实现，具有很高的实用价值。
所以，我们将本论文所研究的低复杂度Turbo译码器应用到MIMO-SCFDE 通信系统中，通过仿真不同信道条件下该通信系统的误码率曲线，来检验本论文 所研究的Turbo译码器的有效性和鲁棒性。
4.2.2 T-SOVA算法在MIMO-SCFDE系统中的性能仿真
上一节介绍了本项目的频域均衡方案，本节需要对整个MIMO-SCFDE通信 系统进行联合仿真验证。首先搭建C语言浮点平台，实现发送端Turbo编码、速 率匹配、QPSK调制以及STBC编码，接收端实现解STBC、频域均衡、解速率 匹配和Turbo译码等操作。为了充分仿真系统性能，验证在不同信道条件下系统 的性能损失，对两种信道进行模拟。第一，仿真在AWGN信道条件下译码性能 曲线；第二，使用Jakes模型，对真实信道进行建模，对单径瑞利衰落信道和多 径信道分别进行链路级仿真。
系统性能仿真曲线分别比较了在AWGN信道、单径瑞利衰落信道、两径衰 落信道和四径衰落信道条件下，有无Turbo译码模块给传输性能造成的影响，且 比较了使用T-SOVA算法的Turbo译码器（简化因子M=4）和使用Log-MAP算 法的Turbo译码器在相同迭代条件下对MIMO-SCFDE系统的性能影响。
仿真模块包括基于T-SOVA算法（或Log-MAP算法）的Turbo译码模块、
62
速率匹配模块、STBC空时编码模块、成帧模块、QPSK调制模块、信道估计模 块和频域均衡模块。MIMO-SCFDE系统的仿真性能曲线如图4-10和图4-11所 示，仿真链路示意图如图4-12所示。


图4-10AWGN信道条件下T-SOVATurbo译码对系统性能的影响
LLI
—4—4 path Log-MAP Turbo i— —2 path Log-MAP Turbo 1 path Log-MAP Turbo
…4 path T-SOVA Turbo …◎…2 path T-SOVA Turbo 1 path T-SOVA Turbo -4- - 4 path硬判决 =8 = 2 path硬判决
-5	0	5	10
SNR/dB
图4-11衰落信道条件下T-SOVATurbo译码对系统性能的影响
63
收端仿真模块
IFFT
FFT
FFT
时域累力口
信道估计
时域累力口
硬判决
误码统计
解速率匹 酉己
Turbo译 码
图4-12收端和发端仿真链路示意图
上述性能仿真曲线比较了在AWGN信道条件和衰落信道条件下，本论文所 设计的低复杂度Turbo译码器对MIMO-SCFDE通信系统性能的提升作用。
图4-10展示了在AWGN信道条件下，MIMO-SCFDE通信系统中加入T-SOVA算法的Turbo译码器与直接采用硬判决输出结果的性能差异。由此可以得 出，在AWGN信道条件下，本论文研究的低复杂度Turbo码译码器极大地提升 了系统性能，且与Log-MAP算法的Turbo译码器性能差异约为0.3dB,当要求 通信系统的误比特率（BER）达到KT，以下的条件时，系统性能比硬判决提升大 于 18dBo
图4-11展示了在单径瑞利衰落信道，两径衰落信道和四径衰落信道条件下 该低复杂度Turbo译码器的对系统性能的影响。仿真中，各径利用Jakes模型模 拟，多普勒频率10赫兹，各径功率相等且对多径信道进行功率归一化。若系统 要求误比特率低于IO",该低复杂度Turbo译码方案相比于硬判决方案为MIMO-SCFDE 系统带来的增益超过16 dB,且与Log-MAP算法的Turbo译码方案相比 单径条件下相差约0.4dB,二径和四径条件下有约0.6dB的差距。所以，在衰落 信道条件下，经过均衡操作后，该低复杂度Turbo译码模块依然给系统性能带来 了大幅度改善。
64
4.3 Turbo均衡在MIMO-SCFDE系统中的应用
对于实验室项目所应用的无线信道场景而言，大多会由于多径效应造成信道 具有频域选择性衰落的特点，并且会造成符号间干扰（ISI） o为了抵抗信道的频 域选择性衰落，弥补符号间干扰给系统性能带来的损失，通常需要采用信道编码 和信道均衡两类技术ML第三章介绍了一种低复杂度Turbo译码算法，第4.2节 介绍了本项目的频域均衡方案。对于一般的通信系统而言，信道译码和均衡一般 各自独立，但是两者都是为了提升系统对抗实际信道的干扰能力而设计，受Turbo 码迭代译码思想的影响，可以对二者进行联合迭代，实现性能的进一步提升。
4.3.1	Turbo均衡原理
Turbo均衡网［40啊］原理与串行Twbo码的原理十分类似，Turbo均衡原理由 C. Douillard 等人于 1995 年首次提出,后经过 R. Koetter, A.C. Singer 和 M.Tuchler 三人的持续研究得到了更多业内人士的关注和使用。从数学角度理解，由于ISI 信道相当于对信道的冲激响应和发射信号进行卷积，其原理与RSC卷积编码器 并无本质上的区别，所以均衡可以看成是另一种意义上的译码。有了以上假设, 在接收端我们就可以按照串行Turbo码的操作进行译码。
Turbo均衡的发射及接收流程如图4-13所示。
结合图4-1所示的本系统架构图及系统实际修改及实现复杂度情况，对图4-13所示Turbo均衡方案的收端和发端链路进行解读。
I
I
I
I
I
I
I
I
I
I
经过硬判决
译码器
八
经过软判决
S(c”)
［s（y，，）
图4-13 Turbo均衡发端及收端链路示意图
由图4-1所示的系统流程图可知，图中数据源凡经过信道编码器输出〃，编 码器为CCSDS标准Turbo编码器，码率为1/6。图中的交织器在本方案中可以用
65
速率匹配来实现比特交织，相当于对数据做进行块交织。交织器的输出C,经过 QPSK映射输出符号结果为％ ,后续继续经过STBC编码以适应两发两收的多天 线系统。调制好的信号x.经过无线信道在接收端表示为以。接收端对收到的信号 进行解STBC及频域均衡处理后输出亢，输出软判决结果为s(x.)。再经过解 QPSK调制输出1“，输出软判决结果为s(%)。图中解交织模块对应于图4-1中经 过解速率匹配模块，输出为员，输出软判决结果为s(“)。最后经过Turbo译码 模块，输出为工，并利用第三章研究的T-SOVA算法输出每个信息比特的外信息 Leibn\y)^
Turbo均衡中交织器的主要作用与Turbo码中的交织器相似，其目的是降低 发送端Turbo编码器与多径信道的相关性，换句话讲就是力图降低ISI信道对传 输造成的符号间干扰的影响。一般的Turbo均衡系统发送端只有一个RSC卷积 编码器，为了更加适用于本方案，本论文所研究的Turbo均衡系统依旧在发送端 利用两个并行的卷积编码器组成Turbo编码器进行编码操作。
Turbo均衡的接收端模型如图4-14所示:
图4-14 Turbo均衡接收端模型
Turbo均衡算法有两种思路，一种是基于最优检测算法的最大后验概率检验 (MAP),但是由于MAP算法需要利用整个序列来判断每个比特的关系，所以 具有极高的复杂度，并不能直接用于信号检测。另一种思路就是基于最小误差算 法(MMSE)的Turbo均衡算法。
为了降低系统复杂度，且在尽量不改变本方案基础架构的前提下提高性能, 本节采用基于MMSE的SISO均衡器。该均衡器的优化目标是达到线性均方误 差的最小值，如式(4-18)所示。
血血("一元「)	(4-18)
从本质上看，Turbo MMSE均衡器仍然是一个线性滤波器，Turbo均衡器可 以得到天的先验信息。假设接收信号
4=叫+巩	(4-19)
式(4-19)中各向量如下所示；
Xl =	->•■■■> Xn+N ]	(4-20)
66
W_ =附_/，…,叱+N『
H _。讣。n [
(4-21)
(4-22)
Turbo均衡就是通过N个接收符号Z,			来估计X,，丸的估计值如式(4-23)所
示：
丸=	口,+。/(4-2)			(4-23)
式(4-23)中各分量值由以下公式推导而出：
丸=	M E(z“) = »笆一*			(4-24)
S		(4-25)
<=(	2V(2	，n，Zn) = b；L+HY1HH			(4-26)
工=8丫区		,Xn) = diag(u『M，		•「2?)	(4-27)
S	= H.[	°ix(N2+Mf , L	]		T	(4-28)
式(4-23 )中的片可以由QPSK映射模块的输出L xn = E, vn =cov(x/t,xn),由 QPSK 映射关系可以得到:					(c〜)中得到，其中
_ 1	tanh	9 12 ;	+ i • tanh	(几2)[ 2	(4-29) /
% =1 —	到2		(4-30)
均衡后的亢与QPSK的输出L(g, J无关，在计算月时可以令％ = 0, % = 1, 则式(4-23)可以进一步推导为式(4-31)的形式。
兀+舂)	(4-31)
Z：=(E„+(l-^)ssH)-Is	(4-32)
由式(4-31)可知，对每一个符号它都需要重新计算一次打，可以对上式进 行简化，对于每个利用力来代替随符号变化的4,则力可以得到如下简化计 算：
f.=K-fc
K = (l + (1-0 仆]	(403)
力=(淄*HHH「s
由式(4-31)可以计算出兀，则相应的均衡模块提供给解QPSK映射的外信 息可以表示为：
Le(c..J =氓/戊,—Re(月)
(4-34)
以％J =&/吃"•加(您)
67
其中匕〃 =1 —%H工，进一步化简可得d=1 —%H工。
以上即为Turbo均衡MMSE算法的推导过程。根据本系统实际情况考虑， 本项目采用频域均衡技术，为了更加方便地将Turbo均衡算法应用到本系统中， 且在对基本框架不做巨大改变的情况下应用Turbo均衡操作，本文将对上述公式 在频域上进行计算〔42】，以此来降低计算复杂度，同时更加适用于单载波频域均衡 系统。
采用FFT进行时域到频域的转化，对式(4-31)进行频域上的推导可得：
Xt=Fk-Zk+MkM	(4-35)
Fk=K-F；	(4-36)
Mk=K-(〃-理-Hj	(4-37)
K= . H常	(4-38)
](nt	)
2理・凡	(4-39)
N V=o	7
K = +	77/	(4-40)
式(4-35)到式(4-40)给出了 Turbo均衡的频域计算公式，使得Turbo均 衡能够被本项目MIMO-SCFDE单载波频域均衡系统使用，极大降低了计算复杂 度，且对已有系统框架和运算模块没有改变。
本节给出了 Turbo均衡的原理及推导过程，且推导出了适用于单载波频域均 衡的Turbo均衡方案，使之能够更加方便地融入到MIMO-SCFDE系统中来。下 一节将针对本节所提出的基于频域的Turbo均衡算法进行链路级仿真，以此验证 本节提出的Turbo均衡方案，并且能够对本论文所研究的基于T-SOVA算法的 Turbo译码器进行更深一步的挖掘和评判。
4.3.2	Turbo均衡性能仿真
有关信道均衡的研究一般采用Proakis教授提出的经典信道模型参数进行性 能测试，本文采用Proakis B和Proakis C两种信道进行链路级仿真。Proakis B和 Proakis C信道分别代表了中等失真和严重失真的多径信道模型，其冲击响应如 下图所示：
68
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
-3	-2	-1	0	1	2	3
Proakis B Channel
图4-15 Proakis B信道特征
图4-16 Proakis C信道特征
图4-15和图4/6显示了 Proakis B和Proakis C信道的冲击响应和频谱增益， 由信道频谱增益可以看到，传输信号在某些频段会有严重的衰落。
仿真条件为：基于CCSDS标准的Turbo编码器，码长为6144,码率为1/6, 寄存器个数为4,系统帧结构如图4-3所示，经过速率匹配3次编码块重复，并 经过若干次均衡FDE块重复最终符合帧结构所示的模式。接收端Turbo译码器 采用第三章所介绍的T-SOVA算法，简化因子M=8,译码器输出的外信息如式 (3-56)所示，且利用基于Log-MAP算法的Turbo译码器性能作为对比，两种 译码器的迭代次数均为6次。输出针对每比特的外信息再利用和发端成帧相同的 步骤操作，用于匹配频域均衡计算的先验信息。
4.3.1	节提出的Turbo均衡方案在Proakis B信道条件下的误比特率和误帧率
69
性能曲线如图4-17和图4-18所示，在Proakis C信道条件下的误比特率和误帧 率曲线分别如图4-19和图4-20所示：
or
UJ
CQ
SNR
图4-17 Proakis B信道条件下Turbo均衡BER性能仿真
江
LLI LL
Log-MAP 无Turb滋衡
-各-T-SOVA 无Turbo均衡
Log-MAP Turb殴衡1次迭代
T-SOVA Turbo® 衡 1 次迭代
—Log-MAP Turb(曲衡2次迭代
=© =T-SOVATurbc均衡2次迭代
-18	-17.5	-17
-16.5	-16
-15.5	-15
SNR
图4-18 Proakis B信道条件下Turbo均衡FER性能仿真
70
SNR
图4-19 Proakis C信道条件下Turbo均衡BER性能仿真
图4-20 Proakis C信道条件下Turbo均衡FER性能仿真
71
图4-17至图4-20给出了图4-14所示的Turbo均衡方案的仿真性能曲线。图 中实线表示利用Log-MAP算法的Turbo译码器的性能，虚线表示利用T-SOVA 算法实现的Turbo译码器的性能。综合考虑系统的计算复杂度和吞吐率等要求， 在不改变系统原有模块算法和框架结构的情况下，本系统最多可以进行两次 Turbo均衡迭代。基于以上原因，对MIMO-SCFDE系统的Turbo均衡方案仿真 了一次迭代和两次迭代两种性能曲线。
在Proakis B信道条件下，在不改变MIMO-SCFDE系统原有帧结构和运算 模块的基础上，若无Turbo均衡操作，利用T-SOVA算法相比于利用Log-MAP 算法的Turbo译码器有约IdB的性能损失，经过Turbo均衡方案进行迭代后，T-SOVA算法与Log-MAP算法的性能差异缩小至0.3dB,达到了在系统性能基本 相同的情况下大大降低系统的译码复杂度的既定目标。在ISI信道码间干扰极为 严重的Proakis C信道条件下，对于Log-MAP算法来说，利用基于频域的MMSE 均衡方案迭代一次，可以使系统性能提升0.5dB,迭代两次系统能得到将近IdB 的增益，对于利用T-SOVA算法的Turbo译码器来讲，两次Turbo均衡迭代带给 整个系统的增益约为2dB,使得系统性能在迭代后得到大幅度提升。同时，结合 第三章第四节分析可知，若本系统使用该低复杂度Turbo译码器，可以通过对基 于T-SOVA算法的Turbo译码器多进行一次如rbo均衡操作来弥补T-SOVA算法 相比于Log-MAP算法带来的译码性能损失。
经过第三章对低复杂度Turbo译码器的研究和第四章对该译码器在超远距 离MIMO-SCFDE通信系统的实用性和适应性的研究以及Turbo均衡方案对该 Turbo译码器的进一步使用，充分证明了基于T-SOVA算法的Turbo译码器的研 究价值。
由以上充分的模块仿真及整个通信链路的仿真可以看出，本论文所研究的低 复杂度Turbo译码器应用场景十分广泛，计算复杂度相比于传统译码器大大降低, 具有很高的理论研究价值和实际应用价值，对基于Turbo码的信道编译码的进 一步研究具有十分重要的意义。
4.4	低复杂度Turbo译码器C语言实现
本文第三章和第四章分别介绍了 Turbo码译码器的复杂度较低的算法及将 该算法应用到MIMO-SCFDE系统的方法，并给出了译码性能曲线和系统性能仿 真曲线。通过以上介绍，本论文所研究的T-SOVA算法有着译码复杂度较低的优 势，在未来对Turbo码译码器的使用上有广阔的应用空间。
为了未来可以更方便地应用该T-SOVA算法,本论文最后对该算法进行C语 言定点程序开发。在程序开发的便利性和实用性角度进行权衡考量，C语言可以
72
由编译器进行翻译应用于DSP或ARM开发中，且C语言代码相比于汇编语言 和Verilog语言可读性更强，可移植性更好，且后期维护和修改也更为方便画。
4.4.1	Turbo码译码器定点实现框架
基于T-SOVA算法的Turbo码的分量译码器由四个主要部分组成：分支度量 计算单元、路径选择单元、码字输出单元和软判决信息计算单元。子译码器计算 流程结构如图4-21所示。
硬判决使
硬利决值
图4-21基于T-SOVA译码算法的Turbo分量译码器结构图
其中路径选择模块计算某一时刻k路径的分支度量，选择幸存路径，并更新 每个节点的路径度量值，输出该时刻每个被扩展节点的幸存路径判决比特及幸存 路径与竞争路径的路径度量差值（应用T-SOVA算法时，若当前竞争路径尚未被 选择则暂时输出8）。
码字输出模块的主要功能即为输出T-SOVA算法的译码判决结果。设当前模 块的路径回溯长度为3,则在某一时刻k,可以根据当前的译码状态节点和寻找 到的最大似然路径判断k-B时刻T-SOVA译码器的输出。记录当前时刻格图中 已扩展节点处的路径度量差值，送入软信息计算模块（当Turbo译码器已经迭代 了足够次数时该模块直接输出硬判决）。
软信息计算模块根据k-3时刻的判决输出，并结合在路径回溯5长度范围 内的竞争路径输出和最大似然路径输出不同处的度量差值，不断更新时刻k处的 对数似然比，得到T-SOVA的输出软信息，并通过外信息计算公式，输出分量译 码器的输出外信息，或当译码迭代次数满足条件时输出判决信息比特。
Turbo码译码器的整体流程设计如图4-22所示。
图4-22中最关键的部分即为两个基于T-SOVA算法的分量译码器设计，为 了进一步说明本算法的设计思路，该分量译码器实现T-SOVA算法的流程图如图 4-23所示。
73
图4-22 Turbo译码器计算流程图
图4-23分量译码器T-SOVA算法计算流程图
本节介绍了 C语言的编码思路和流程，下一节将对定点算法中的关键算法 进行介绍，并给出C语言译码性能定点仿真结果。
74
4.4.2	译码器C语言设计关键技术
进行Turbo译码首先要根据生成多项式建立格图，根据建立的格图我们就可 以知道编码在某一状态下输入为1或0时下一状态的情况和输出的校验比特。根 据CCSDS标准，本论文所设计的译码器状态表如表4-1所示。
通过对表4-1的观察，我们可以看到基于CCSDS标准的Turbo编码的状态 转移图存在如下规律：相邻的两个状态，如S。(0000)和S](0001)，在不同的输入比 特条件下会进入相同的状态，状态S。当输入比特为0时进入S。状态，相反状态显 的输入比特为1时进入S。状态；状态S。当输入比特为1时进入S8状态，相反状 态不在输入比特为0时进入工状态，我们可以用一个蝶形来描述上述状态转移 图。同理可得其他状态的蝶形图，由于CCSDS标准Turbo编码器由4个寄存器 构成，所以这样的蝶形状态转移图共有8个。
表4-1为编码器输出统计表，图4-24展示了编码器16个状态的蝶形转移图。
表4-1 CCSDS标准Turbo码编码器输出情况统计表
输入比特0			输入比特1
起始状态	结束状态	编码器1	编码器2	结束状态	编码器1	编码器2
So	So	000	00	S8	111	11
S1	S8	000	00	So	111	11
s2	S9	010	00		101	11
S3	S.	010	00	S9	101	11
S4	S2	on	01	Sio	100	10
S5	S,o	on	01	S2	100	10
S6	S„	001	01	S3	110	10
S7	s3	001	01	S„	110	10
S8	S4	101	11	S12	010	00
S9	S12	101	11	S4	010	00
S1O	S13	111	11	S5	000	00
Sn	S5	111	11	S,3	000	00
S12	S6	110	10	Si4	001	01
S.3	S14	110	10	S6	001	01
S14	S15	100	10		Oil	01
S15	S7	100	10	S15	Oil	01
CCSDS标准8蝶形状态转移图如图4-24所示。
75
图4-24 CCSDS标准8蝶形状态转移图
对图4-24和表4-1进一步观察可以看到，对于蝶形图中的每一个状态，在 输入为0和1时，编码器的输出比特刚好相反。例如状态 在输入0时，分量编 码器1输出为000,分量编码器2输出为00,在输入为1时，分量编码器输出为 11b分量编码器2输出为11,两者的输出比特相反。
T-SOVA.算法的Turbo码译码器定点设计还有一个关键技术即为分支度量的 计算。随着迭代的进行，路径度量值会不断增大，在定点算法中一定会造成溢出 问题，将影响译码的准确度，所以对于T-SOVA算法定点实现来讲需要对路径度 量值进行归一化处理。
所谓归一化处理，一般的方法是需要在每个时刻从计算出的分支度量中选取 最小值，将该最小值置为0,其他各值以此为基准减掉该值。但是这种方法要求 巨大的操作数量，对T-SOVA算法而言，由于基于CCSDS标准的Turbo译码器 存在16个状态，所以最坏情况下同一时刻会有16个扩展节点。首先需要从16 个状态值中找出最小值，需要15次的比较操作。找出最小值后再将每个状态值 和最小值进行减法运算，这又需要16次的减法运算。这种算法会大大降低运算 速度，在定点实现中并不能实现低复杂度译码的需求。由于T-SOVA算法的分支 路径度量用欧式距离表示，所以该值恒为正数，所以本方案采取了一种新的方法 防止度量值溢出，即触发门限防止溢出的方案。
该方案的设计思路是对路径的累积度量设置一个最大的触发门限，当一定数 量的累积度量值超过该门限时，对所有累积值减去一个常数，防止度量值溢出造 成译码错误。门限的大小选择和防止溢出超过门限的数量选择也非常关键，若门 限过低，则防止溢出操作应用太过频繁，影响译码效率；若门限过高，此时很多 度量值已经发生溢出，造成的译码错误也就无法再次纠正。所以需要在译码精度 和工程实现复杂度两者之间做出取舍。
本论文中我们将译码器输入信息定标为Q(16,l),即16位正数的一位代表整 数位，其余15位代表小数位。将分支度量值定标为Q(32,3),相应的路径度量值 76
定标为Q(32,16)o由于T-SOVA译码算法我们主要关心的是那些累积路径度量值 较小的分支，所以对于度量值较大的分支的溢出并不需要过多考虑，利用门限触 发相减法进行溢出控制，当被扩展节点的矩阵中，累积的路径度量值中一半以上 的数据除符号位的最高位为1时，将当前度量值除符号位以外的最高位置0,对 本方案而言即相当于对定点表示的该路径度量值减去23，
利用以上方法本论文提出的基于T-SOVA算法的Turbo码译码器进行C语 言定点实现，其定点性能仿真图如图4-25所示。
图4-25码长256基于T-SOVA的Turbo译码器定点性能仿真图
由图4-25对该算法的定点仿真曲线可以看出，利用以上定标方法和基于门 限触发的防止溢出方法，本论文所提出的低复杂度Turbo译码方案相较于浮点仿 真性能相差约为0.3dB,满足传输距离较远、传输时延较大的MIMO-SCFDE通 信系统对Turbo译码模块的性能需求。
本论文提出的基于T-SOVA算法的Turbo码译码器，相较于MAP算法、Log-MAP 算法和Max-Log-MAP算法译码复杂度大大降低，相应地对软件平台的要 求也大大降低。通过对本算法的定点设计可以发现，这一通过简化SOVA算法进 行Turbo译码的思路为该低复杂度Turbo译码算法应用到诸如DSP芯片、ARM 芯片及ZYNQ系列的FPGA芯片上进行信道译码提供了更加广阔的思路。
77
4.5	本章小结
本章主要研究内容是一种基于T-SOVA算法的低复杂度Turbo译码器在 MIMO-SCFDE通信系统中的应用。通过对多天线单载波频域均衡系统的物理层 进行链路级仿真，验证该低复杂度Turbo译码器的有效性和鲁棒性。
本章第一节详细介绍了一种远距离通信系统——MIMO-SCFDE系统，对该 系统使用的关键技术和应用目的做了较为详尽的说明。由于该系统是一种基于无 线传输的点对点通信系统，所以又对其所经历的无线信道的时延和功率做了一些 采样和建模处理，并利用Jakes模型进行信道模拟。
本章第二节给出了 Turbo译码算法对整个通信系统的性能影响。为了充分反 映Turbo译码算法的性能，在不同信道条件下对该通信系统仿真。通过对误比特 率进行仿真可以看出,T-SOVA算法在不同信道条件下均能大幅度提升系统性能, 且对信噪比估计准确与否并不敏感，有极强的适应性，可以应用到不同的通信环 境中。
本通信系统利用单载波频域均衡系统来对抗多径衰落信道的码间干扰，为了 进一步改善系统性能，在本论文的最后尝试利用Turbo译码器输出软信息，并与 均衡器进行联合迭代。第三节给出了 Proakis.B和Proakis.C两种信道条件较差的 固定信道，更需要说明的是，这两种信道对于MMSE频域均衡器来讲具有较大 的均衡难度。在这种极端信道条件下，仿真Turbo均衡技术对MIMO-SCFDE系 统的作用，进一步证明本论文所研究的T-SOVA算法的价值和作用。
通过第三章分析该低复杂度Turbo译码器性能和复杂度，以及第四章将该 Turbo译码器放到MIMO-SCFDE通信系统进行整体性能仿真，充分证明了本论 文所研究的低复杂度Turbo译码方案的可行性和实用性。为了后续对该算法进行 硬件实现，第四节对该Turbo译码器进行了 C语言定点程序开发，方便该算法未 来在更广阔的领域应用和实现。
78
第五章总结与展望
本论文主要研究了一种基于维特比译码方式的低复杂度Turbo码译码器，结 合自身的工作和研究，对本文进行一些归纳和总结：
本文第一章首先介绍了信道译码理论的研究背景和发展状况，介绍了信道编 码理论发展过程中的一些关键节点，并详细介绍了信道译码算法中具有里程碑意 义的Turbo码译码器。本文基于空间数据系统咨询委员会提出的Turbo码的标准 进行译码器的设计和研究，CCSDS对Turbo码的青睐也使得Turbo译码算法得 到了非常可观的发展前景。
接下来第二章为了寻找一种低复杂度的Turbo译码方案，本论文着重研究了 基于维特比译码算法的信道译码方案。第二章详细介绍了维特比译码算法的计算 步骤和算法的优缺点，并且在第二章的第二节和第三节提出了针对维特比译码路 径选择优化的序列译码算法和A*译码算法。第二节详细介绍了 Fano序列译码算 法及其改进方案：最大似然软判决序列译码算法（MLSDA）。第三节介绍了一 种基于Dijkstra最短路径算法思想的A*译码算法，大幅度减少了高信噪比下搜 索最大似然路径的操作数量。在第二章改进算法的指引下，我们发现了基于深度 优先的最大似然译码路径选择，极大降低了维特比译码算法的搜索复杂度。
第三章为了将维特比译码算法应用到Turbo码的分量译码器中，对维特比译 码算法的输出进行了修改，将硬判决结果变为软判决结果输出，使得信息能够在 两个分量译码器之间传递。本章第二节详细介绍了 SOVA算法的推导和计算步 骤，作为对比，同时介绍了 MAP算法的推导，并介绍了其改进方案Log-MAP算 法和Max-Log-MAP算法，并对SOVA和MAP两类算法的计算复杂度进行详细 对比，得出SOVA算法复杂度最低的结论。第三节对SOVA算法进一步优化，继 续降低其算法复杂度，利用计算操作复杂度更低的Lazy-Viterbi算法寻找最大似 然路径，并且结合Lazy-Viterbi算法简化Turbo译码算法对数似然比LLR的计 算，得到计算复杂度更低的T-SOVA算法。最后，本章第四节对基于T-SOVA算 法的低复杂度Turbo码的性能进行分析，得到一种与Max-Log-MAP算法性能相 差不大但译码复杂度大大降低的Turbo译码算法。
第四章将本论文研究的低复杂度Turbo译码器应用到MIMO-SCFDE系统中。 本系统采用双发双收单载波频域均衡技术，达到点对点远距离传输目的。并尝试 利用本论文研究的Turbo译码器和本系统中的均衡器相互传递信息，利用Turbo 均衡技术提升系统性能。最后将本论文研究的基于T-SOVA算法的Turbo译码器 用C语言实现，使其方便在ARM或DSP上实现。
本文完成了对一种新的低复杂度Turbo译码算法的理论研究与性能仿真，并
79
将该低复杂度Turbo译码器应用到MIMO-SCFDE系统中，为远距离、低信噪比、 相对较大的译码时延的通信系统提供了一种新的信道译码思路，从性能仿真上看, 取得了不错的效果。
经过对低复杂度Turbo译码方案的研究，在以下方面还可以做进一步研究：
(1)T-SOVA算法在高信噪比条件下译码性能良好，且复杂度低，吞吐量高， 但是在低信噪比条件下仍然存在译码性能相对MAP算法较差的弊端，在应用时， 若能估计当前译码时刻的信噪比，自适应地选择译码方法可以保证低信噪比条件 下的译码性能。
(2)本文主要对低复杂度Turbo译码算法的性能进行MATLAB仿真，并用 C语言实现其中的堆栈存取，链表插删等操作，在代码复杂度上还可以进一步优 化，减少冗余，使其更容易应用。
80
-Ar-士上 参考文献
[1]	Shannon C E . A mathematical theory of communication"]. Bell Labs Technical Journal, 1948, 27(4):379-423.
[2]	M.J.E. Golay, Notes on digital coding, Proc. IRE, 1949, 37:657.
[3]	Hamming R W . Error detecting and error correcting codes[J]. Bell Syst. Tech. J. 1950, 29.
[4]	Gray R M. Coding for noisy channels[M]. Entropy and Information Theory. 1990.
[5]	J.M.Wozencraft and B. Reiffen, Sequential decoding.MA:MIT Press. Cambridge. 1961.
[6]	Viterbi A J . Error bounds fbr convolutional codes and an asymptotically optimum decoding algorithm]J]. IEEE Trans. Inform. Theory, 1967, 13.
[7]	Fomey G D J. Concatenated codes.[J]. Collection Iris, 1965, 4(2):8374.
[8]	Bahl L, Cocke J 5 Jelinek F, et al. Optimal decoding of linear codes fbr minimizing symbol enor rate (Corresp.)[J]. IEEE Transactions on Information Theory, 2003, 20(2):284-287.
[9]	Berrou C , Glavieux A , Thitimajshima P . Near Shannon limit eiTor-correcting coding and decoding©. Icc 93-ieee International Conference on Communications. IEEE, 2002.
[10]	Gallager. nLow-density parity-check codes.n Wiley-IEEE Press, 1963.
[11]	Arikan E. Systematic Polar Coding[J]. IEEE Communications Letters, 2011, 15(8):860-862.
[12]	Hagenauer, J, and L. Papke. "Decoding ccturboJ,-codes with the soft output Viterbi algorithm (SOVA) J IEEE International Symposium on Information Theory 1994.
[13]	Hagenauer, J , and P. Hoeher . nA Viterbi algorithm with soft-decision outputs and its applications.n IEEE Global Telecommunications Conference IEEE, 1989.
[14]赵海.低存储量CCSDS-Turbo码译码器的设计与FPGA实现[D]. 2017.
[15]费晓飞.空间通信协议安全性研究[D].解放军信息工程大学,2008.
[16]何小敏.卷积码编码与维特比译码加速器设计[D].北京邮电大学,2010.
[17]	Fano R . A heuristic discussion of probabilistic decoding[J]. IEEE Transactions on Information Theory, 2003, 9(2):64-74.
[18]	Ekroot L , Dolinar S . A* decoding of block codes [J]. IEEE Transactions on
81
Communications, 1996, 44(9):1052-1056.
[19]	Han, Yunghsiang S , C. R. P. Hartmann , and C. C. Chen「'Efficient MaximumLikelihood Soft-Decision Decoding of Linear Block Codes Using Algorithm A." IEEE International Symposium on Information Theory IEEE, 2002.
[20]吴伟陵，贺志强.信息处理与编码[M]. 2003.
[21]	Han Y S , Chen P N , Wu H B . A maximum-likelihood soft-decision sequential decoding algorithm fbr binary convolutional codes[J], IEEE Transactions on Communications, 2002, 50(2):173-178.
[22]	Sun J，Takeshita O Y. Interleavers fbr turbo codes using permutation polynomials over integer rings[J]. IEEE Transactions on Information Theory, 2005, 51(1):101-119.
[23]	Viterbi A J . An intuitive justification and a simplified implementation of the MAP decoder fbr convolutional codes [J]. Selected Areas in Communications IEEE Journal on, 1998, 16(2):260-264.
[24]	Robertson P, Villebrun E, Hoeher P. A comparison of optimal and suboptimal MAP decoding algorithms operating in the log domain. International Conference on CommunicationsfC].Seattle: WA,1995:1009-1013
[25]	Hagenauer J , Offer E , Papke L . Iterative decoding of binary block and convolutional codes[M]. IEEE Press, 1996.
[26]	Talakoub S , Sabeti L , Shahrrava B , et al. An Improved Max-Log-MAP Algorithm fbr Turbo Decoding and Turbo EqualizationfJ]. IEEE Transactions on Instrumentation and Measurement, 2007, 56(3):1058-1063.
[27]	Feldman, Jon , I. Abou-Faycal , and M. Frigo ."A Fast Maximum-Likelihood Decoder fbr Convolutional Codes/1 IEEE Vehicular Technology Conference IEEE, 2002.
[28]	Huang Q , Xiao Q ? Quan L , et al. Trimming Soft-Input Soft-Output Viterbi Algorithms [J]. IEEE Transactions on Communications, 2016, 64(7):1-1.
[29]	Pei R, Wang Z, Huang Q , et al. Low complexity SOVA fbr Turbo codesfJ]. China Communications, 2017, 14(8):33-40,
[30]	Huang C X , Ghrayeb A . A simple remedy fbr the exaggerated extrinsic information produced by the SOVA algorithm [J]. IEEE Transactions on Wireless
82
Communications, 2006, 5(5):996-1002.
[31]	Chen H , Haimovich A . EXIT Charts for Turbo Trellis-Coded Modulation]J].
IEEE Communications Letters, 2004, 8(11):668-670.
[32]李波.Turbo迭代译码收敛性能的仿真研究[D].西南交通大学,2012.
[33]杨程程.Turbo预编码的不等差错保护研究[D].郑州大学,2013.
[34]武利利.中短帧长Turbo码的收敛性能分析[D]. 2015.
[35]梁瀚予.低信噪比MIMO SCFDE系统中信道估计与频域均衡方法研究与实 现[D]. 2018.
[36]杨阳.MIMO系统中的单载波频域均衡技术[D].北京邮电大学,2010.
[3刀陈跃潭.低信噪比下MIMO SC-FDE系统中的频偏估计算法研究与DSP实 现[D].北京邮电大学,2015.
[38]许可.Turbo解码与Turbo均衡关键技术研究[D].国防科学技术大学,2011.
[39]	Tuchler M, Singer A C. Turbo Equalization: An Overview [J]. IEEE Transactions on Information Theory, 2011, 57(2):920-952.
[40]	Kschischang F R , Frey B J , Loeliger H A . Factor graphs and the sum-product algorithm[J]. IEEE Transactions on Information Theory, 2002, 47(2):498-519.
[41]	Tuchler M 5 Koetter R , Singer A C . Turbo equalization: principles and new results[J], IEEE Transactions on Communications, 2002,50(5):754-767.
[42]沈旭栋.单载波频域均衡系统及基于Turbo均衡的改进[D].清华大学,2009.
[43]秦磊.DSP上Turbo编译码的实现[D].西安电子科技大学,2012.
83
84
