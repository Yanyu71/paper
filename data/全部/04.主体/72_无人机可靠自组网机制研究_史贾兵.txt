第一章绪论
1.1	研究背景与意义
随着科技的发展，人类为了达到更精准、快速、高效、节能的目的，制造了 许多可以替代人力的机器。而无人机也是由于其自身的特点被制造和使用于各个 行业的机器。目前无人机已经应用到了很多领域，如：在军事上人们使用它进行 军事侦察、巡航、和快速打击等；在工业人们可以将其用于电力巡检、污染监测 等；在农业上还可以用于农林植保、巡检、喷洒农药等；其次无人机还可以用于 航拍、气象探测、救灾等。
在1996年，以色列的飞行工业公司，就使用了无人机在美国蒙大拿州对火 灾进行了侦察。2007年，诺埃尔飓风袭击了巴哈马群岛，美国立即调用无人机进 行实时监测。该无人机在风暴环境中飞行了 7个多小时，最低时飞行到300英尺 的海面上空搜集数据，并将数据传回了美国国家海洋与大气局位于佛罗里达州迈 阿密的国家飓风中心。当然，除了实时监测，在灾后搜索方面无人机也能发挥巨 大作用。2005年，美国南佛罗里达大学的研究人员用他们的小型无人机在“卡特 里娜”飓风袭击后寻找生还者。2008年1月我国南方出现了一场罕见的冰冻灾 害，我国政府第一次将无人机应用到了救援的行动中，并在积累了一定的经验同 时也意识到无人机在救援中的无限力量和前景。在2008年5月12日，我国汶川 发生了严重的地震灾害，建筑物大面积的倒塌，通信基础设施的毁坏和山体的滑 坡造成了道路的阻塞。我国政府再次将无人机列为救灾行动中的一员，进入灾区 经行拍摄，将真实的图像传回到救灾中心，政府可以根据真实的图片来更合理的 规划救灾路线，提出救灾方案。在救灾的过程工作效率，还可以做到人力无法完 成的任务，从而可以更快更有效的挽回国民的生命和损失。由于无人机的小巧， 灵活，成本低的特点，在深山密林中搜寻失踪的驴友或者逃犯使用无人机将会是 很好的选择。它可以减少人力、时间，可以更快速准确的搜寻到目标。
目前虽然无人机已经运用到了很多方面，但是还是比较简单的，基本上是单 个无人机同地面控制台的直接通信。单无人机系统局限性大，可生存性低，不利 于扩展，如果无人机和地面控制台之间受到了干扰或者超出了通信范围就可能造 成信息的丢失甚至无法通信。而多无人机自组织网络就在这种情况下孕育而生, 人们将移动自组网(mobile Ad Hoc network, MANET)和车载自组网(vehicle Ad Hoc network, VANET)的概念运用到多无人机网络通信中。无人机自组织网络 解决了单无人机的通信不可靠,节点不灵活,抗毁性不强,通信范围受限等问题，
1
还可以通过无人机之间分发和传递指控指令，采集的数据等进行协同任务，这样 可以更高效，快速的完成任务。为了很好的达到以上效果，实际在研究无人机系 统的时候也遇到了诸多问题。无人机之间的通信则是研究所有问题的基础和关键 所在。设计出适应未来发展需求、高效、安全可靠、抗毁性强的无人机自组织网 络，已经成为急需解决的问题。
1.2	国内外研究现状
在准备做无人机自组织网的时候，首先需要阅读与此相关的文献，来了解目 前大家都在研究哪些热点，还有哪些需要进行研究。文献［刀和文献［18］就研究和 分析了无人机通信网络的一些关键技术和所面临的挑战。这些都有助于从整体上 了解无人机自组网络所涉及的各个方面和它们之间的相互联系。
文献［7］调查研究了无人机通信网络的关键技术，通过阅读了大量的文献将 移动自组织网络、车载自组织网络同无人机自组织网络做了对比分析，引出了无 人机的特点和需要突破的具有挑战性的难题，如路由协议，无缝切换，能源效率 等。并研究分析了现有的一些文献对无人机自组织网络做出的贡献。
文献［18］研究了飞行自组织网络与传统的Ad Hoc网络相比所面临的挑战。 在不同性能指标下对现有的路由协议做了分析和比较。而这些比较和分析将有助 于根据不同的具体情况，网络工程师选择合适的路由协议来部署无人机自组织网 络。
国内外对无线自组织网络的研究主要集中在对路由协议和跨层协议的研究 上。目前，无线自组织网络的路由协议分类方法多种多样，并且随着研究人员的 贡献新的路由协议也在不断的出现，路由发现机制存在多种类型，不同的发现机 制是通过不同的路由算法实现的。路由协议基本可以被分为表驱动路由协议、按 需路由协议以及混合式路由协议三种类型。
文献⑵、［3］、［旬、［16］是对OLSR算法的研究及改进，文献［5］、［41］是对 AODV算法的研究及改进。文献”］是对OLSR算法和AODV算法进行性能的对 比。文献［23］到［35］是有关移动自组织网络跨层协议设计的论文。
文献⑵指出高移动性和负载不平衡是UAV网络的两个显着特性。UAV网络 的性能很大程度上受这些特性的影响。为了减少这些问题的影响，该文提出了移 动性和负载感知OLSR (ML-OLSR)协议，移动性感知算法和负载感知算法被引 入至U OLSR协议。
文献［16］由于无人机节点的高动态性，而这种动态性比典型的移动自组织网 和车载自组织网络更不稳定，所以现有的移动自组织网络的路由协议在跟踪网络
2
拓扑时已经部分失效。这篇文章中在链路状态路由协议（OLSR）的基础上设计 出了预测链路状态路由协议（p-olsr）,比较了两种不同的Ad hoc网络路由算法： 优化链路状态路由协议（OLSR）和预测链路状态路由协议（p-olsr）。使用了一个 由两个独立的固定翼无人机和地面上的一个节点组成的试验台。通过实验评估了 链路性能和通信范围，以及路由性能。仿真和实验结果表明，p-olsr在网络拓扑 变化频繁的存在明显优于OLSR路由。
文献［41］提出AODV安全协议设计思路和实现办法，为了让AODV协议更 加安全，作者设计出了一种基于公开密钥非对称密码数字签名算法的复合路径多 路由AODV安全协议，并对协议报文分组格式、报文安全流程和协议模块、路 由表结构等方面进行了改进。
文献［20］为了在无人机通信的过程中减少各种有意无意的攻击，无人机通信 需要可信的路由协议来协助其完成这个要求。这篇文章通过查阅大量的文献分析 总结了无人机的基于信任的安全路由协议的相似和不同之处。并且分析讨论了不 同路由协议的特点，它们适用的应用环境以及无人机的调度方案。文就口9］使用 了模型驱动开发的方法提出了一个可信安全的路由协议，通过这个协议可以更容 易的完成无人机的最终认证。
网络设计的一个重要原则是按功能进行层次划分，将功能分散化管理相互独 立这样就使得层次清晰易于管理。这中设计的方法在有线网中取得了极大的成功, 这中网络的设计思路并不适用于无线自组网络。如果无线自组织网络也使用了这 中设计就会导致效率和性能低下，而且非常不灵活。这是因为无线自组织网络会 出现有线网络不会遇到的问题，如节点接入冲突、信号干扰、节点能量有限导致 信号衰减等问题，传统的分层体系框架由于其层间的协,作有限进而限制了无线自 组网中通过各层间合作而能取得网络优化的能力。而无线自组网跨层路由协议就 孕育而生了，近些年已经有很多学者开始研究跨层路由协议了，并贡献了不少的 文献。
文献［31］提出了无人机自组网的一种跨层结构，通过合并OSI模型的下三层 为一层来设计这中跨层协议。同时还并提出了一种基于定向天线的MAC层 IMAC-UAV协议，在这篇文献中使用的路由协议为DOLSR协议，最终通过仿真 结果证明了这种跨层结构可以有效的提升网络性能。
文献［30］提出了与新的多信道MAC协议和适合于多信道的路由协议相关联 的跨层设计，使用EXata模拟器执行网络仿真以评估吞吐量。
虽然无人机通信的研究重点基本都处在路由层上，可是还是有一些文献是关 于其他方面，如MAC协议、无人机任务规划算法、移动模型等。
3
文献［9］这篇文章考虑了网络规模对吞吐量、能耗和有效传输范围的影响，对 无人机自组网的性能进行了评估。仿真结果表明，该评估方法能有效地评估无人 机自组网的性能。研究结果表明，当网络规模（无人机数量）增加，无人机吞吐 量和能源消耗减少，而整个网络传输范围（有效覆盖范围）增加。
文献网这篇文章提出了一种基于全双工无线电和无人机自组织网络MAC 方案。为了有效地处理无人机ad-hoc网络的高度移动环境，使用基于令牌的技 术来更新网络中的信息。在完美和不完全信道状态信息（CSD的存在下，MAC 方案分别被描述为一个组合优化问题和一个离散随机优化问题。仿真结果表明了 该MAC的有效性。
文献［14］提出了一种新的无人机的任务规划算法，可以在最少时间访问所有 的目标点，同时一直保持网络的连接状态。并且在2D地形上进行的一系列实验， 测试了任务执行的有效性和任务分配的成本效率。
文献［10］提出了一种适用于无人机自组网的真实情况下的移动模型。并将这 种设计出来的移动模型和常见的随机移动模型做了对比。同时也将其与真实的无 人机运行情况通过多个指标做了对比。
1.3	本文的主要工作及创新点
本文分析研究了关于无人机自组织网络的参考文献，并查找了有关无人机应 用的具体案例。研究和总结了无人机可靠自组织网络的关键技术，如路由协议、 MAC协议、跨层协议等。在研究理论基础的同时还深入研究了 NS-3仿真平台， 主要学习了官网给出的三本书（tutorial, manual和library）,再结合NS-3提供的 相关源码进行学习。深入分析了日志系统、Tracing系统、Application模块、移动 模块、wifi模块等。由于研究的需要还引入了 NS-3仿真平台没有的TDMA模 块，并对其设计结构和使用方法做了分析和总结。本文通过仿真实验，对比wifi 模块的MAC协议和TDMAMAC协议在无人机自组织网络中的性能，结果表明 wifi所使用的竞争型的MAC协议比引入的分配类的静态TDMA MAC协议在网 络性能方面要好，同时也发现了仿真上的一些难点和一些有待研究的部分。
本文的创新点体现在两方面。一是NS-3仿真平台的改进，具体包括随机游 走移动模型的改进、封装了一个容易获取仿真结果的接收器和发送器；二是无人 机自组织网络的典型MAC层协议分析对比。在NS-3上设计实现了 Wifi MAC 协议和TDMAMAC协议，并在不同的场景下进行了大量的仿真，通过网络性能 参数曲线图分析了两种MAC协议的性能。
4
1.4	论文结构
本文第一章介绍了无人机自组织网络的研究背景和现状，总结了不少学者对 无人机自组织网络在各方面所做的贡献，并列举了一些真实情况下其发挥的无法 替代的作用。第二章首先对自组织网络做了概述，并分析了当前无人机通信的现 状,和一些关键技术如链路层的MAC协议和网络层的路由协议等。第三章对NS-3仿真平台做了介绍和研究，详细讲解了一些主要的仿真模块，如日志模块、移 动模块、Tracing模块等。通过一个仿真的样例，来说明仿真的流程。第四章介绍 了无人机可靠自组网MAC协议性能研究，详细的分析了 NS-3平台中wifi模块 的MAC协议，从外部引入了 TDMA模块，并对它的工作原理做了介绍。将这 两个不同的MAC协议在无人机自组织网络的背景下做了仿真并对比了他们的性 能。第五章总结了全文所做的工作，并对未来无人机自组织网络可靠组网机制的 研究做了展望。
5
第二章无人机可靠自组织网络
2.1	自组织网络概述
移动自组织网络结合了移动通信和计算机网络的特点，在网络中节点在移动 的过程中仍然可以保持通信。早在1968年美国的夏威夷大学就研制出了无线数 据通信协议即ALOHAo其中ALOHA协议可以分为纯ALOHA协议和时隙 ALOHA协议。ALOHA协议是一种单跳网络，网络中发送节点只有跟目标节点 有直接连接才可以通信。而这只是移动自组织网络的雏形。在1973年PR(Packet Radi。)网络的出现，才真正开始了多跳网络的征程。PR网络允许两个节点可以不 直接通信，而是通过中继的方式传输数据。开始PR被广泛用于军事领域后来 IEEE提出了 802.11标准，并将PR网络更名为ad hoc网络，运用于社会中的多 个方面。
由于Ad Hoc网络在网络的组建，节点间通信与传统的无线移动通信网络不 同，Ad Hoc网络有以下几方面的特点。
无中心自组织
传统的移动无线通信网络包含有一个中心基站和多个移动节点。当节点需要 发送消息时，需要先将消息发送到最近的基站然后基站解析消息，根据解析的内 容寻找路由，最后将消息按照路由转发出去。在这个过程中移动节点的功能是发 送和接收数据，仅仅相当于一个终端。而基站的作用则比较重要，它不仅负责数 据消息的转发功能还需要寻找到合适的路由然后将数据根据路由发送出去。这样 看来把大多数的功能都放到了基站去做从而减轻了移动节点的负担。功能的集中 性恰恰会带来严重性的后果，一旦基站出现问题将会导致整个网络瘫痪，从而导 致移动节点无法通信。Ad Hoc网络没有任何的基础设施，网络中的每个节点都 是平等的，功能一致。不论何时何地，Ad Hoc网络可以被组建，每个节点都可 以发送接收数据，同时它们也充当了路由的角色可以寻路转发数据。节点可以随 时离开网络也可以随时加入网络，当一个节点出现故障时，数据还可以通过其他 节点转发，从而保证整个网络可以正常运行。所以AdHoc网络搭建灵活，抗毁 性强。
动态的网络拓扑结构
在AdHoc网络中网络的拓扑结构十分不稳定，在运行的过程中网络拓扑不 断的发生着变化。有许多原因会导致网络拓扑的变化如，节点的不断移动，节点 的能源消耗导致其脱离网络，节点可以随时加入网络,无线信道之间的干扰等等。
6
对于常规网络来说，它们的网络拓扑结构是稳定的，许多网络协议的研究都是以 这个为前提背景实现的。这些路由协议可以快速收敛并且寻找到合适的路由进行 节点的发送或转发。但是对于Ad Hoc网络来说由于其网络拓扑结构的动态性使 得传统的路由协议就不适合用于自身了，因为传统的路由协议在更新路由信息的 时间比网络拓扑变化的慢，也就是说还没有找到路由或者刚找到路由，结果此时 网络拓扑结构就变了。所以设计处一个适合Ad Hoc网络的路由协议将是一大热 点和难点。
受限的无线传输带宽
Ad Hoc网络是通过无线传输技术来实现节点间的通信的。和有线网络传输 相比较，由于无线信道自身的特点使其稳定性，带宽，安全性都处于劣势。无线 传输的物理特点就决定了它使用的信道带宽要要远低于有线信道。当节点在同一 个无线信道上通信时，当通信节点数增加会导致节点对信道资源的抢占，发送的 数据碰撞概率就会增加，从而降低信道的利用率。外界的噪声和信道之间的干扰 也会造成实际的带宽低于理论值。
移动终端的自主性和局限性
在移动计算机网络中包括两种不同功能的设备即移动终端和路由器。移动终 端主要的功能有提供人机交互的接口，人们通过交换接口去安装并且运行应用程 序，然后将应用接入到网络中。路由器的功能则是运行安装在路由器上的路由协 议，然后通过节点发送的信息寻找合适的路由并转发数据信息，使终端和路由器 构成一个互通的网络。但是在Ad Hoc网络中，只有一种功能相同的瞥节点， 其中每个移动节点的功能包括了终端和路由器。作为终端，它的功能和移动计算 机网络中的移动终端路由功能相同。由于在Ad Hoc网络中只有功能相同的移动 节点，所以想要节点间进行通信，每个节点都必须拥有路由器的功能。与固有的 网络设备相比，无线自组织网络中的设备，小巧，便携，移动性强等优点。但是 这些优点使得它的配置不会很高，如：内存低，CPU处理能力不强，能耗高。所 以移动终端的设备需要考虑节能省电，低功耗。对于这样的配备，移动终端的功 能将会受到很大的限制。
安全性问题
在AdHoc网络中，节点是通过无线信道进行通信的。它与有线信道相比安 全性差了许多。由于无线信道是开放的，任何节点都可以接入到同一个信道，而 且节点可以随时离开网络，也可以随时进入网络。这可能导致非法节点的入侵， 从而窃取网络中传输的数据，或者攻击网络使网络通信瘫痪。因此，Ad Hoc网 络的安全性问题也将会是研究人员的一大挑战。
可扩展性不强
7
Ad Hoc网络的可扩展性不强，主要表现在以下几方面，首先由于网络中的 所有节点共享信道，节点又要做终端有要做路由功能复杂导致处理能力不强还有 就是多跳传输等因素导致了 Ad Hoc网络的扩展性不强。其次为了提高可扩展性 子网、无类域间路由等技术被大量使用到了互联网。而对于Ad Hoc网络来说, 这些技术并不适用，进而导致可扩展性受到限制。最后对于Ad Hoc网络来说, 由于节点的移动性使得网络的拓扑不断的变化。如果使用先应式路由将会在维护 路由方面浪费很多资源,导致可扩展性差，如果使用反应式路由则延时又回很大, 对于对延时有较大要求的场景就会导致可扩展性不强。所以设计出适合Ad Hoc 网络的路由也将是一个挑战。
由于移动自组织网络无中心，自组织，多跳路由等的特点，使其运用到了各 个领域。在军事领域，美军已经将其纳入了战术互联网的核心技术。由于在战场 上基础通信设施被毁或者没有基础通信设施，而Ad Hoc网络是无中心自组织的 网络，它可以帮助士兵或者各种战斗装备通过AdHoc网络进行通信，达到了信 息的实时共享，可以帮助他们协同完成任务。人们还可以通过Ad Hoc网络进行 移动会议，以前大家想开一个会议通常需要配备路由器，集线器等来进行文档的 演示，会议资料的共享等。但是使用了 AdHoc网络，只要人们携带笔记本而不 用带那些繁琐的装备就可以随时随地召开移动会议了。在灾难恢复方面Ad Hoc 网络也做了非常重要的贡献，灾难基本上会导致基础通信设施的破坏，从而使得 无法通信给救援带来了很大的难度，有了 AdHoc网络就可以快速重建网络恢复 通信从而为保护人们的生命财产作出了巨大贡献。
2.2	无人机可靠自组网关键技术
2.2.1	数据链路层协议
数据链路层是OSI七层模型中的第二层，它处于物理层之上和网络层之下， 不管是发送数据还是接收数据都需要经过此层。数据链路层接收物理层提供的服 务，并且在物理层提供服务的基础上为网络层提供服务，它最主要的服务是把发 送端的网络层的数据可靠的传输到接收节点的网络层上。为了完成这个可靠的任 务，数据链路必须具备一系列相应的功能，主要有：怎样组合或者拆分数据为数 据链路层的最小数据单位帧；怎样控制帧在物理信道上可靠的传输，其中包括怎 样处理传输差错，为了匹配接收端的接收怎样调节发送端的速率；它还需要控制 管理两个节点之间链路的建立，维持和释放。
8
由于无人机网络节点的移动性，数据链路的易变性，和无中心性，这些都增 加了 MAC协议的设计难度。从而设计出节省能量、可扩展性强、时延低、吞吐 量高、信道利用率高以及较好的公平性的MAC协议，已成为无人机自组织网络 的研究热点。
由于无人机自组织网络中各个节点地位平等，不存在中心控制设备来协调管 理网络的资源，所以传统的集中式的资源调度不适用于无人机自组织网络。无人 机自组织网络MAC协议可以根据不同的方式进行分类，可以根据分布式控制思 想，信道数量的多少以及网络类型进行分类。
无人机自组织网络的MAC协议根据分布式控制思想可以划分为三类，即竞 争类型的MAC协议，分配类型的MAC协议，将竞争类型和分配类型MAC协 议相结合的混合类型MAC协议。这三种MAC协议类型主要的不同之处是节点 对于信道的访问策略不同，下面我们分别介绍着三种类型的MAC协议。
竞争类协议
竞争类MAC协议，顾名思义就是节点通过对信道资源的竞争策略来获得接 入信道的机会。随机接入信道的ALOHA协议是一种典型的竞争类MAC协议。 它的原理其实非常简单，节点可以随时发送数据，这样很容易会造成冲突，但是 可以通过广播信道的反馈性将受到的数据与发送缓冲区做对比进而就可以判断 自己发送的数据是否被正确的接收，如果发生冲突而导致数据发生破坏，那么经 过一段随机时间再重新发送被破坏的数据。一般情况下，竞争类的MAC协议工 作在异步模式，为了避免发生碰撞的问题通常会在协议中加入控制信令来避免碰 撞的发生。如果网络中发生碰撞，竞争类MAC协议也会通过重传机制来发送由 于碰撞破坏的数据，知道接收端成功接收。
竞争类MAC协议的工作原理相对比较简单，不需要复杂的时间同步和控制 调度算法实现起来比较容易，在网络负载较低的情况下对网络的性能也有不错的 表现，数据冲突概率小，因此重传率低，传输时延较小，信道的资源利用率很高。 通常简单的策略遇到复杂的问题就没有那么有效了，随着网络节点数量的增加， 网络整体性能存在明显下降，碰撞频繁，重传率高，传输时延较大，信道的资源 利用率大大降低。网络性能的这些负面表现说明了此时网络资源分配的极度不合 理，严重的情况甚至导致服务不可用，从而导致成功发送接收数据的概率很低。 常见的竞争类协议有ALOHA、S-ALOHA、CSMA、CSMA/CA等。
分配类协议
与竞争类的MAC协议不同的是分配类MAC协议通常需要时间同步。这种 分配类的MAC协议的基本思想是将时隙或者频率或者正交码分配给各节点，每 个节点只能使用自己被分配的时隙或者频率或者正交码来获取信道的资源完成
9
自己的通信任务。TDMAMAC协议是典型的分配类协议，它的原理是将不同的 时隙分配给各个节点，每个时隙对应唯一的一个节点，当到达节点自己所拥有的 时隙时才可以获得到信道资源进行数据的发送和接收。由于这种方式在开始就已 经把每个节点的时隙都安排好了，这样就使得灵活性较差。协议的分配可以是静 态的也可以是静态的。为了提高协议的可扩展性，提高信道的利用率可以根据节 点的密度和负载合理的设计出发送时间。
通过学习分配类MAC协议的特点，可以发现在节点密度大，网络繁重的情 况下使用分配类的MAC协议才能发挥出它的优势。因为不论网络压力有多大， 由于其固定的分配方式，网络中发送的数据都不会因为碰撞而丢失。而在节点密 度小，网络负载压力小的情况下，由于时隙的固定分配，使得延迟较大从而分配 类MAC协议的性能表现较差。网络中常见的分配类型的MAC协议有：TDMA MAC 协议，FDMAMAC 协议，CDMA MAC 协议。
混合协议
由于竞争类MAC协议和分配类MAC协议都有自己的优缺点，但是可以发 现这两者的优缺点可以互补，于是很容易让人联想到将这两种MAC协议结合起 来，于是就出现了混合类MAC协议。混合类MAC协议吸取了竞争类MAC协 议和分配类MAC协议的优势，在设计混合类MAC协议的时候，当节点密度小 网络负载压力小的时候,混合类MAC协议就会表现出竞争类MAC协议的特点， 而如果节点密度大网络负载压力大的时候，混合类MAC协议则会表现出分配类 MAC协议的特点。通过这种灵活的特点，网络的性能必然会提高。目前常见的 混合类协议有结合载波监听的竞争类MAC协议和分配类协议TDMA所形成的 混合时分多址访问协议，结合TDMA和CCSMA的混合MAC协议，ADAPT协 议等。
下面介绍另一种分类方式，即按照节点所接入信道的数量可以将其划分为单 信道MAC协议，双信道MAC协议和多信道MAC协议。
（1）单信道MAC协议，这个协议的实现是所有的节点都共享同一个信道。 节点发送的的控制报文和数据报文都将会通过这个共享信道进行传输，很明显这 样很容易出现各种数据之间的冲突。（2）双信道MAC协议，这个协议的实现是 所有节点都共享两个信道，分别用于传输节点发送的控制报文和数据报文。将数 据报文和控制报文传输到不同的信道上，从而免去了控制报文和数据报文间的冲 突，并且可以解决网络的两大问题，隐藏终端和暴露终端从而避免了数据报文间 的冲突。（3）多信道MAC协议。这个协议的实现是在双信道MAC协议上的扩 展，首先有单独传输控制报文的信道，其次它有添加了多个传输数据报文的信道， 使得相邻节点之间可以通过多个数据信道同时通信从而大大提高了通信的效率。
10
在设计无人机自组织网络MAC协议的时候需要考虑到多个方面才能设计出 高效，节能，扩展性强，网络性能良好的MAC协议。
节省能量。无人机自组织网络一个重要的问题就是能源问题，目前大多数无 人机仍然使用的是有限的电能，为了使得无人机可以尽量长时间的有效工作，设 计出的MAC协议需要在满足性能的前提下尽量节省能源。目前已经研制出了一 些通过太阳能来充电的无人机。就在前不久，中国航天科技集团研制出了彩虹太 阳能无人机，这种无人机在机电条件允许的前提下可以在天上工作数月甚至数年。
可扩展性。在无人机自组织网络中包含多个无人机，随着无人机的移动，无 人机的密度也在不断的发生变化。在网络运行期间，可能会有无人机加入网络或 者脱离网络所以在设计MAC协议的同时需要考虑到协议的可扩展性来适应网络 不断变化的拓扑关系。
延时。延时是数据包从发送端发送到达接收端所经历的时间。有一些应用场 景对时延并不敏感，在这种情况下可以不考虑延时，只考虑性能。还有一些应用 场景则需要对数据进行实时的监控，以便通过监控到的数据做出相应的反应。无 人机自组织网络的延时根据不同的MAC协议的策略而产生的。因此在敏感的应 用场景下设计MAC协议需要考虑延时。
吞吐量。吞吐量为在单位时间内发送端成功向接收端发送的总数据量，单位 是比特每秒。影响吞吐量的因素有信道利用率，延时，数据包冲突等。不同的应 用场景会对吞吐量有不同的需求，这些因素和吞吐量是此消彼长的关系，根据不 同的需求可以舍弃其他的因素来提高吞吐量。 -陷
信道利用率。信道利用率体现了无人机在自组织网络中对信道带宽的利用率。 当无人机采用平等分配信道方案时，由于实际情况对信道的需求并不相同，这样 就会导致信道的利用率降低，进而影响网络性能的提升。在这种情况下MAC层 如果可以动态的分配信道带宽则可以大大提高对信道的利用率。
公平性。在无人机自组织网络中，每个无人机都公平的共享信道。但是公平 性对于无人机自组织网络来说并不是那么重要。由于多个无人机协同完成一个任 务的时候，在不同的时刻无人机需要发送的数据量并不相同，一些无人机发送转 发的压力较大而一些无人机的压力很小，如果将每个无人机平等的接入到信道， 平等的划分了信道的带宽，这样一来信道的利用率就会大大降低，所以在无人机 自组织网络中公平性并不重要。
上述六个因素对无人机自组织网络对MAC层协议设计来说，前五项都非常 重要，虽然在能源方面各国已经研制出了一些可以长久使用的无人机初步解决了 能源问题，但是在我看来节省能源还是必要的因为这些东西并不是可再生的。可 扩展性可以给无人机自组织网络产生多种可能性，将会推动多场景无人机的发展。
11
而延时，吞吐量和信道利用率则是承担自组织网络性能的基础，只有打好基础才 能更好的将无人机自组织网络运用于各种真实情况。
2.2.2	路由协议
在无人机自组织网络中，无人机在传输和接收数据的同时还充当着转发其他 无人机数据的路由角色。由于无人机自身不断移动的特性，无人机所处的网络拓 扑将会处于极不稳定状态，由于无人机的这个特性，从而引出了一个研究热点即 设计出可以快速重建网络拓扑并且可以讲数据通过合理的路由传输给目的无人 机的路由协议。本节将对介绍一些常见的路由协议。
在研究无人机自组织网络的初期，人们想要将现有的MANET和VANET中 的路由协议移植到无人机自组织网络中，但是经过许多学者的研究和证明，这种 移植并不合理，因为无人机不断高速移动导致网络状态变化频繁而这种特点在 MANET和VANET的身上都不能找到。目前学者们研究的无人机自组织网络路 由协议的类别主要分为静态路由协议，先应式路由协议，反应式路由协议，混合 路由协议以及基于地理位置的路由协议。
静态路由协议指每个节点的路由表事先固定并且在运行的过程中路由表不 会变化。这种路由主要使用的场景是网络拓扑动态不变且路由表不需要更新的情 况，但是它不能适应环境对网络造成的影响。这中路由协议主要有数据中心路由 （data centric routing 缩写：DCR）,负载携带和传递路由（load carry and deliver routing 缩写：LCAD）。
先应式路由协议也可以称作主动式路由协议，其中每个节点都会维护自己的 一个或者多个路由表，这些表中记录着到达所有节点的路由信息，每当网络的拓 扑发生变化后都会更新自己的路由表。然而触发这种更新是要付出代价的即需要 产生大量的控制数据去探测网络状态。不同的先应式路由协议的区别是它们对于 路由表的更新策略不同。由于这种协议可以事先将路由表更新好，所以当有数据 信息需要发送的时候，直接可以根据路由表中的路由信息去传输，达到延时小的 目的。目前这种先应式路由协议常见的有最优链路状态路由（Optimized Link State Routing缩写：OLSR）以及OLSR的改进，目的地排序的距离矢量路由协议 （Destination-Sequenced Distance-Vector Routing Protocol 缩写：DSDV）。
反应路由协议又被称为被动路由协议或者按需路由协议或者随选型路由协 议，它的原理与先应式路由协议截然相反，它不会主动去更新路由表而是在需要 发送数据的时候才去寻找路由，从而节点就不需要花费大量的控制信息去维护路 由信息。但是正是因为这个原因，在每次发送数据的时候都需要临时寻找路由就
12
会产生较大的延时。目前这种反应式路由协议常见的有按需距离矢量路由协议 (Ad Hoc on-demand distance vector 缩写：AODV)以及 AODV 的改进，基于动 态源路由(dynamic source routing缩写：DSR)及其改进型。
由于先应路由协议和反应路由协议都有自身的优缺点，所以能不能将它们的 优点综合起来呢，于是混合型路由协议就孕育而生了。它可以减少先应路由协议 产生的控制信息还可以改善反应式路由在延时方面的缺点。目前混合路由协议的 研究也不少，其中比较出名的是区域路由协议(zone routing protocol缩写：ZRP) 在无人机自组织网络中，每个节点都有一个以自身为中心的圆形区域，在这个区 域中圆形的半径与节点数有关，每个节点的区域相互重叠，中心节点维护了一个 到自己区域内其他节点的路由信息通过位置辅助路由协议(Location Aided Routing Protocol缩写LARP)。在区域内使用的是先验式路由协议以减少发送所 需要的延时，在区域以外使用反应式路由协议以减少节点产生的控制信息、。
在研究人员考虑使用混合路由协议解决先应路由协议和反应路由协议的缺 点的时候，还有一些研究人员提出了基于地理位置信息的路由协议。在无人机自 组织网络中如果无人机都知道自己的位置以及其他无人机的位置，就可以按照一 定的路由策略讲数据发送给目标。其中比较常见的有位置和能力感知的地理路由 (geographical and energy aware routing 缩写：GEAR),贪婪周边无状态路由 (Greedy Perimeter Stateless Routing 缩写：GPSR)。
2.3	小结
本章节首先介绍了自组织网络的基本概念和它所持有的独特的特点，如：无 中心自组织，抗毁性很强，易于搭建和撤离，受限的无线传输带宽，移动终端的 自主性和局限性，安全性问题和可扩展性不强。接下来又介绍了无人机自组织网 络的MAC协议，并分别通过分布式控制思想，信道的数量以及网络的同步还是 异步将MAC协议经行分类，并分别介绍了它们的基本原理及优缺点等。最后介 绍了目前无人机自组织网络常用到的路由协议。
13
第三章NS-3仿真平台研究
3.1	NS-3 介绍
NS-3仿真平台是一个用于研究和教育的离散事件网络模拟器，NS-3项目开 始于2006年是一个开源项目。NS-3不是NS-2的向后兼容扩展，是一个新的模 拟器。NS-2和NS-3网络模拟器的设计和实现使用的语言是C++,但是它们不支 持对方的API,在构建NS-3模拟器的同时，NS-2的一些模块已经移植到了 NS-3平台。NS-3为网络研究和教育提供了一个开放的、可扩展的网络仿真平台。简 而言之，NS-3为用户提供了一个离散事件网络仿真平台，用户可以通过它来研 究特定网络环境下各种协议的执行和工作原理。使用NS-3仿真系统的优势包括 它可以研究一些真实情况无法模拟出来的场景，并可以通过灵活的参数配置重复 相同的仿真环境或模拟特定的仿真场景，达到自己的研究目的。NS-3模拟器中 大多数模块的设计主要是针对互联网协议的研究，但是NS-3的仿真功能并不仅 仅是这些。有一些使用者利用NS-3来模拟非基于Internet的系统。目前已经有 许多专门用来研究网络的仿真器，如OPNET, GloMoSim, NS系列等，以下是 NS-3与其他工具相比的一些显著特点。
NS-3被设计成一套可以与其他外部软件库结合在一起的库。虽然有些仿真 平台已经将图形用户界面集成到了各自的仿真器中，但NS-3在这方面更为模块 化。NS-3可以使用一些外部动画设备和数据分析和可视化工具。在NS-3仿真器 上做开发或者对其进行扩展，开发者更倾向于使用软件开发工具来实现，这样可 以提高工作效率。NS-3主要用于Linux系统，它还支持FreeBSD, Cygwin,并 且正在开发本地Windows Visual Studio使其支持NS-3。NS-3不是任何公司正式 支持的软件产品。用户可以通过邮件的形式对NS-3的更新发展提供支持。
与NS-2的比较
对那些熟悉NS-2 （NS-3之前的流行工具）的人来说，NS-3最明显的外部变 化是脚本语言的选择。NS-2中的程序在OTcl中编写脚本，模拟结果可以使用 Network Animator nam进行可视化。纯粹从C++ （即，没有任何OTcl的main （） 程序）在NS-2中运行仿真是不可能的。而且，NS-2的一些组件是用C++和OTcl 编写的。在NS-3中，模拟器完全使用C ++编写，并带有可选的Python绑定。 模拟脚本因此可以用C++或Python编写。新的动画器和可视化器可以在当前的 开发中使用。由于NS-3生成pcap数据包跟踪文件，所以还可以使用其他实用
14
程序来分析跟踪。但也有相似之处，例如，都是基于C++对象，而NS-2的一些 代码已经被移植到NS-3。
使用NS-3更高效的原因如下：
NS-3目前处于主动维护状态，有一个积极的响应用户邮件列表，而NS-2则 维护得很少，十几年来在主代码树中没有再看到重大的模块添加。NS-3提供了 NS-2中没有的功能，如代码执行环境的实现（允许用户在模拟器中运行真实的 代码）。与NS-2相比，NS-3提供了更低的基本抽象层级，使其能够更好地与实 际系统组合在一起。在NS-2中发现的一些限制已经在NS-3中得到了解决，如 在节点上正确支持多种类型的接口。
NS-2由于开发时间较长，与NS-3相比，拥有丰富的网络模块。然而，NS-3在几个热门研究领域中有更详细的模型，如复杂的LTE和WiFi模型，并且它 实现的代码支持一个宽频谱高精度模型。用户可能会惊讶于使用直接代码执行 （DCE）框架可以将整个Linux网络堆栈封装在NS-3节点中。特别是如果它们 已经用C++实现的话，NS-2模型有时可以移植到NS-3。	7
,峪
有几个NS-3用户必须知道的重要资源。主网站位于http://www.nsnam.org, 提供有关NS-3系统的基本信息。详细的文档可以通过 http://www.nsnam.org/documentation/获得。您也可以从此页面找到与系统架构相 关的文档。有一个Wiki可以补充NS-3的主要网站，你可以在 http://www.nsnam.org/wiki/找到它。您将在那里找到用户和开发者常见问题解答， 以及故障排除指南，第三方贡献代码，论文等。源代码可以在http://code.qsnam.org/ 找到并浏览。在那里你会找到名为NS-3-dev的仓库中的当前开发树。核心开发 者的过去的版本和实验版本也可以在那里找到。
3.2	NS-3平台架构
NS-3源码主要放在src文件夹中，软件组织结构如图3-1所示。通常情况 下，上层的模块依赖于下层模块。可以看到最下层是核心模块，它实现了 NS-3 的基本机制，如日志，事件调度，属性，回调，智能指针等。第二层是网络模块， 主要包括的是网络数据分组模块。第三层包括因特网模块和移动模块，其中因特 网模块主要包括TCP/IPv4和IPV6协议族的相关模块，因为大多数真实的网络 都是在因特网基础上搭建的所以在仿真中具有重要的作用。第四层包括协议模块, 应用模块，设备模块，传播模块等，每个节点都可以安装多个应用，同时也可以 安装多个设备进行通信。第五层和第六层分别是助手（helper）模块和测试模块， 在NS-3中每一个模块都有helper文件夹用来存放helper源码和test文件夹用来
15
存放模块测试源码。助手模块主要是用来封装模块底层APL将大多数的值设置 成默认值给使用者提供容易使用的接口。测试模块是用来测试底层API功能的 正确与否。
test
helper
protocols applications devices propagation
internet	mobility
network
core
图3-1 NS-3软件组织结构
下图展示了 NS-3网络的基本模型，主要包括四个部分：应用，协议栈，网 络设备，信道。图中展示了两个节点，每个节点都可以安装多个应用，多个网络 设备和一个协议栈。节点间的通信过程为发送节点1首先在应用层产生发送数据 通过socket接口向下传输给路由层，经过路由层寻找路由并封装数据继续向下 到达节点安装的网络设备，其中网络设备主要包括MAC协议和物理层协议，再 次经过对数据包的处理传输到信道中，最后经过在信道中的传输最终到达接收节 点2。接收节点接收到数据包后从下层到上层一次对其进行反向操作最终获取到 数据。在整个过程中，NS-3是通过传递数据包对象的引用和对数据包的拷贝来 模拟数据包的传输。
16
图3-2 网络基本模型
概念
在看和写NS-3代码之前，我们首先需要了解这个系统的一些核0抽象的概 念。有许多人已经了解这些概念了，但是我还是建议大家花一些时间阅读这部分， 给未来的学习打下坚实的基础。下面将会描述一些网络术语及在NS-3中的含义。
节点
由于NS-3是一个网络模拟器而不是专门的因特网模拟器，而“主机”这个 词与因特网及其协议有着密切的关系，为了防止产生歧义，在此NS-3并没有使 用“主机”这个术语。取而代之的是使用了图论里的概念一一节点，在其它的网 络模拟器中也使用了这个概念。
在NS-3中具有计算能力和通信功能的设备被抽象的定义为节点。NS-3中使 用Node类来定义节点。在网络仿真中Node类中的一些方法可以用来管理安装 在节点中的设备。节点就相当于生活中的电脑、手机等，可以对其添加不同的功 能，如可以给节点安装应用程序，传输协议，路由协议，和一些驱动程序等。这 样可以使得节点具有更丰富的功能，可以实现不同场景的仿真。
应用
17
通常情况下，计算机软件分为系统软件和应用程序软件。系统软件可以管理 调度计算机中的各种资源，如内存，磁盘，网络，显示等。而系统软件通常不会 使用这些资源来完成任务。应用程序软件则通过获取系统软件所管理的资源来完 成用户的某项工作。
简单而言系统软件就像电脑中的操作系统如Windows, DOS, Linux等，而 应用程序软件就像安装在电脑中的应用一样如，Word, PPT, QQ,微信等。在 NS-3中，没有操作系统的真正概念，但是它有应用程序的概念。就像应用程序 软件在计算机上运行来完成人们的现实生活的任务一样，NS-3也可以在节点上 安装应用程序来驱动整个仿真过程。
在NS-3中，由于有多种不同功能的应用，为了对其进行扩展NS-3抽象出 来一个基类它包含了不同应用所共有的特性。这个抽象类在C++中由Application 表示。Application类中提供了许多方法其中最终要的是控制应用程序的开始和结 束。在创建新的应用程序时，需要继承这个抽象类Application然后再扩展各自 的功能。本文定制了自己的应用程序SJBSender和SJBReceiver,它们都继承于 Application类，并拥有了自己的特性如给节点安装更灵活，获取仿真结构更便捷 等。
信道
信道是数据流从一个节点到另一个节点到通道，这个通道可以是有线的也可 以是无线的。人们可以将电脑通过网线连接到以太网中或者连接无线wifi发送 数据或者接收数据来完成通信任务。在NS-3中同样为了扩展不同类型的信道， 它将其抽象出了一个公用的基类即Channel类。
Channel类提供管理通信子网对象和连接节点的方法。在定制自己的特有信 道时，需要继承信道的基类Channel。一个信道可以模拟像线缆一样简单的东西 同样也可以模拟像大型以太网交换机那样复杂的事物，或者在无线网络的情况下 可以建立三维空间。在本文中主要使用的信道有 WifiChannel , SimpleWirelessChannel它们分别对应与不同的模块WifiChannel对应于wifi模块， 而 SimpleWirelessChannel 对应于 TDMA 模块。
网络设备
在技术还比较落后的时候，如果您想将计算机连接到网络，则必须购买特定 类型的网络电缆和需要在计算机中安装外围卡的硬件设备才能完成。如果外设卡 实现了一些网络功能，则称为网卡。现在大多数计算机都内置了网络接口硬件， 想要让这些硬件起作用就需要驱动程序来控制硬件否则这些硬件就会沦为摆设。 同样对于网络设备而言也需要驱动程序控制，在Unix和Linux中，通过ethO等 名称引用来表示这些网络设备。
18
在NS-3中，网络设备不仅仅指到是模拟硬件它是模拟硬件和驱动程序的结 合。在仿真过程中，节点可以安装一个或多个网络设备接入到信道，通过它可以 和其它的节点进行通信。
在NS-3中为了对网络设备进行扩展，将其抽象出了一个公共的基类即 NetDevice类。NetDevice类提供了管理与节点Node和信道Channel对象的连接 的方法；在定制自己的网络设备时，使用者需要继承基类NetDevice扩展自己的 功能。本文主要使用了 wifi模块对应的 WifiNetDevice和TDMA模块对应的 TdmaNetDeviceo这些网络设备都需要和自己对应的信道一起工作，这些信道都 在各自的模块中。
拓扑助手
在真实的网络中，主机内部会安装一个或多个网卡。与之对应的在NS-3中， 每个Node也会安装一个或多个NetDeviceo在大规模的网络仿真中需要管理 Nodes, NetDevices 和 Channel 之间的关系。
由于在仿真中有一些操作比较常见比如给节点安装网络设备，将网络设备接 入到信道中，分配IP地址等。为了方便使用NS3提供了拓扑助手来处理这些常 见的操作，它对使用者隐藏了复杂的操作暴露了简单的接口。例如，它可以直接 通过NS-3提供的核心模块来创建网络设备NetDevice并安装到节点上，给节点 添加MAC地址，配置节点的协议栈，然后将NetDevice连接到信道。甚至还可 以将多个设备连接到多个信道上，还可以将单个网络连接到互联网络中等。
3.3	主要模块
3.3.1	日志模块
在NS-3开发中想要获取调试信息、警告信息、、错误信息或者其他信息，日 志模块可以给你带来便利。NS-3日志模块提供了一个直观的、相对简单的方法 来获取仿真过程中的有用信息。在NS-3中，在不同情景下可以根据需要选择不 同级别的日志，这样可以更高效，清晰的查看目标日志而不去关心其他日志，使 编程仿真更有层次感。例如可以完全禁用日志、仅对部分组件可用、或者全局可 用。NS-3将日志分为七个级别，以下按照递增的顺序进行说明。
NS_LOG ERROR-Log error messages.记录错误信息
NS_LOG_WARN--Log warning messgaes.记录警告信息
NS_LOG_DEBUG-Log relatively rare, ad-hoc debugging messages.记录相
对不常见ad-hoc的调试信息
19
NS_LOG_INFO--Log informational messages about program progress, t己录
程序进展信息
NS_LOG_FUNCTION-Log a message describing each function called.记录
描述每个调用函数信息
NS LOG LOGIC-Log messages describing logical flow within a function.
记录一个函数内描述逻辑流程的信息
NS_LOG_ALL—'—Log everything mentioned above.记录所有信息
此外，还有一种经常被使用的无条件日志级别，与日志级别或者组件选择没 有关系。
NS_LOG_UNCOND---Log theassociated message unconditionally.无条件记
录相关消息
日志的使用可以通过shell命令行设置，也可以通过代码设置。
命令行设置：
$export
'NS_LOG=UdpEchoClientApplication=level_all|prefix_fi.mc|prefix_time:UdpEchoSe rverApplicatin =level_all |prefix_func|prefix_time'设置 shell 环境变量 NS LOG 为 字符串：多组件时，组件之间用冒号（：）隔开。
UdpEchoClientApplication=level_all|prefix_func|prefix_time 等号左边：想要设 置的日志组件名称。等号右边：要用的日志级别，输出多信息时用单杠（|）隔开。 改变环境变量后，可以通过$ export -p列出所有的shell赋予程序的环境变量， 查看NS_LOG级别是否改变。
代码设置：
LogComponentEnable（"UdpEchoClientAppli cation",LOG_LEVEL_INFO）;包 含两个参数，第一个参数为组件名称，第二个参数为日志级别。设置日志级别为 LOG_LEVEL_INFO,当传递一个日志标志时，实际上打开了该级别及其以下的 所有级别。所以，这行代码表示打开了 NS_LOG_INFO, NS_LOG_DEBUG, NS_LOG_WARN, NS_LOG_ERRORo
3.3.2	Tracing 模块
从程序中获得仿真信息的方法有很多种，最简单直接的方法是通过std::cout 将仿真信息直接打印到控制台上。在程序逻辑比较简单的情况这种方式是有效的, 但是随着仿真逻辑变的越来越复杂，打印的信息也越来越多，解析和执行输出的 任务就会变得越来越困难。使用标准输出的另外一个不好的地方是每当需要输出
20
新的仿真数据时，NS-3的核心组件会被重新编辑引入新的打印信息。因为没有 一个标准的方式来控制所有的输出信息，所以输出的信息将会无限增长。最终输 出仿真信息需要的带宽限制了仿真的运行时间。当输出文件增长到很大时，解析 这些数据将会成为巨大的问题。NS-3提供了一个简单的日志机制，可以通过日 志组件控制日志的输出，但是这种控制级别并不是很好。一种好的方案是希望在 不对核心系统进行修改和重新编译的情况下，当用户感兴趣的变化和感兴趣的事 件发生后可以及时通知用户。NS-3就是根据这中方案设计出了 Tracing系统，将 属性和配置子系统很好的集合在一起，并且使用场景也很简单。
Tracing子系统在很大程度上依赖于NS-3回调和属性机制。NS-3 Tracing系 统建立在独立的Tracing源和Tracing接收器的概念之上，将Tracing源和接收器 连接到一起，接收器可以快速的响应Tracing源的变化。tracing发送端可以发送 信号通知在仿真中发生的事件，并可以访问感兴趣的底层数据。例如，Tracing源 可以监控到网络设备何时接受到数据包，并可以访问接受到的数据包中的内容。 Tracing源也可以监控到模型中感兴趣的状态的改变。Tracing源本身是没有用的， 他们必须连接到对源提供有用信息的代码段上。使用Tracing源信息的实体是 Tracing接收器。Tracing源是事件发生器，Tracing接收器是事件消费者。
这种明确的划分将大量的Tracing源散布在系统中的各个部分，这样可以更 详尽的监控到仿真的各个角落。只有当用户将Tracing接收器连接到其中一个 Tracing源上才会输出需要的信息，否则什么都不输出。这种Tracing系统的设计 允许新用户将新类型的接收器附加到现有的Tracing源上，而不需要编辑和重新 编译NS-3的核心组件。
Tracing源生成的Tracing事件可以没有Tracing接收器也可以有多个Tracing 接收器，可以把这种形式看成点对多点的信息链接。这种点对多点的形式是通过 回调函数实现的。回调函数是一种允许系统中的两个模块通过函数调用进行通信 的方法，同时将调用函数与被调用类完全分开。
基本上一个Tracing源是一个回调，它可以注册多个功能的Tracing接收器。 当Tracing接收器对某个接收Tracing事件感兴趣，它将回调添加到由Tracing源 保存的回调列表中。当感兴趣的事件发生时，Tracing源会调用。perator()提供零 个或多个参数。依次遍历回调列表中的每个回调方法，通过回调方法将参数传递 给Tracing接收器。
Tracing模块的使用
Tracing系统有三个级别的接随着用户对平台的熟悉，和对仿真结果的 进一步需求，用户的使用级别和层次可以逐渐提升，依次如下：
21
初级用户可以通过API来控制系统己经提供的Tracing对象，决定使用哪些 关心的对象来输出仿真中的Tracing信息；
中级用户可以扩展Tracing系统，修改生成的默认的输出格式或者以不同的 方式使用现有的Tracing源，而不需要修改仿真平台的核心代码。
高级用户可以修改仿真平台核心代码以添加新的Tracing源和Tracing接收 器。
NS-3 Tracing助手提供了丰富的环境，用于配置和选择不同的Tracing事件 并将其写入文件。
目前在NS-3中有两种用于Tracing的助手，设备助手和协议助手。设备助 手查看哪些Tracing应该通过节点上安装的设备启用。如，可以使用指定的节点 上的设备启用pcap跟踪。从使用Tracing助手的流程来看，自然而然的就可以生 成文件的命名约定，即：<prefix>-<node>-<device>o协议助手会考虑通过协议和 接口来指定哪些Tracing应该被启用。从使用跟踪助手的流程来看，自然而然的 就可以生成文件的命名约定，即：〈prefix〉-〈protocol〉-〈interface〉。
NS-3 提供 了两种 tracing 机制，ASCII 码 tracing 和 pcap 级别的 tracingo NS-3也支持创建.pcap格式的trace文件，缩写pcap表示packetcapture,事实上是包 含有定义一个.pcap文件格式的APL Wireshark软件可以读取并且显示这种格式 的内容。然而，有很多其他分析器也使用这个数据包格式。NS-3提供了封装底 层tracing系统的helper功能，用来提供配置简单数据包的更多细节。如果你使 用了这个功能，将在ASCII文件中输出结果一一这就是为什么这种tracing得名 ASCII tracingo对于熟悉NS-2的用户，这种trace与out.tr相似。结果中的每一 行对应了一个trace事件。trace文件的每一行都以一个单独的字符开始，这些字 符的意义都不相同以下列出了每个字符和它们的含义说明。
+ ：设备队列中的入队操作；
-：设备队列中的出队操作；
d ：数据包被丢弃，通常是因为队列己满或者数据包在队列中超时；
r ：数据包被网络设备接收；
3.3.3	自组织网按需路由协议AODV
该模型实现了 Ad Hoc按需距离矢量（AODV）协议的基本规范。该模型是 基于ns2仿真平台的AODV模型编写的，并对其进行了优化和调整。AODV模 型的源代码的目录在src/aodv中。
22
类 aodv::RoutingProtocoi 继承 Ipv4RoutingProtocol 实现了所有服务数据包交 换的功能。基类定义了两个用于分组路由和转发的虚函数。第一个， aodv::RouteOutput(),用于主动发包时调用的：第二个，aodv::RouteInput(),用于 转发和/或分发收到的数据包。该协议调用取决于许多可改变的参数。此功能的 参数是aodv:：RoutingProtocol的属性。参数的缺省值是从RFC中来的，并允许启 用/禁用协议特性，如广播hello消息、广播数据包等。AODV按需发现路由。因 此，当路由请求包(RREQ)被发送出去后，AODV模型缓存所有的数据包。aodv-rqueue.cc 中实现了 数据包队列。Ipv4RoutingProtocol::ErrorCallback()、 Ipv4RoutingProtocol::UnicastForwardCalIback(),数据包的智能指针和 IP 报头，都 存储在这个队列。数据包队列实现了旧数据包的垃圾收集和队列大小限制。
在标准中定义的路由表的实现支持旧条目的垃圾回收和状态机。它是作为一 个STL映射容器实现的。在这个映射关系中key是IP地址。此AODV实现可以 检测单向链路的存在，并可以在必要时避免它们。如果一个节点收到来自邻居节 点的一个RREQ,这可能是单向链路造成的。这中方式是由AODV-UU实现的 并且可以将其禁用。协议操作非常依赖于链路断开检测机制。该模型通过两种方 式实现。首先，这个实现支持hello消息。然而，hell。消息不是在无线环境中执 行邻居感知(至少不超过802.11)的好方法。因此运行在无线环境时，性能可能 会很差。有以下几个原因：1，HELLO消息是广播。在802.11中，广播通常比单 播己更低的比特率进行,因此HELLO消息可以比单播数据能够传播得更远。2, Hell。消息很小，因此比数据传输更容易发生比特错误，3,广播传输不能保证是 双向的，不像单播传输那样。第二，如果可能的话，我们使用第2层反馈。如果 在帧传输时所有重试发送失败，链接被认为是断开的。这种机制用于主动链接，比 第一种方法工作得更快。
3.3.4	移动模型
NS-3有一套移动模型用来跟踪节点的位置和速度。在此模块中有一些助手 类用于给节点安装移动模型。移动模型的源代码目录位置为src/mobilityo
该移动模型的设计包括移动模型，位置分配器和帮助函数。在NS-3中，特 殊的MobilityModel对象跟踪(笛卡尔)坐标系统的位置演变。移动模型通常聚 合到 NS-3 :: Node 对象，并使用 GetObject <MobilityModel> ()查询。基类 NS-3 :: MobilityModel针对不同的运动行为进行了分类。对象的初始位置通常由 PositionAllocator设置。这些类型的对象将在抽象画布上展现出来。一旦模拟开 始，位置分配器可能不再被使用，或者它可以被用来为这种移动模型选择未来的
23
移动“路标”。大多数用户使用移动辅助类与移动系统进行交互。MobilityHelper 结合了移动性模型和位置分配器，并且可以与节点容器一起使用，以在一组节点 上安装移动性能。
移动模型助手的使用分为两步。1,给MobilityHelper设置位置分配器。2, 给MobilityHelper设置移动模型。以下是代码使用的细节：
MobilityHelper mobilityHelper;
mobility Helper. SetPositionAllocator ("NS-3: :GridPositionAllocator",
"MinX", DoubleValue (0.0),...);
该代码告诉移动助手使用二维网格来初始节点的位置。第一个参数是指定 位置分配器类型的NS-3 Typeld其余的属性/值对用来配置这个位置分配器，如最 小x轴位置MinX,最小y轴位置MinY,节点间的x轴的距离DeltaX,节点间 y轴的距离DeltaY等。
mobilityHelper.SetMobilityModel("NS3::RandomWalk2dMobilityModel","Boun ds", RectangleValue (Rectangle (-40,40, -40, 40)));
该代码设置移动模型等子类。第一个参数是指定移动模型类型的NS-3 Typeld其余的属性/值对用来配置这个移动模型。最后讲移动模型设置给节点如， mobilityHelper.Install (wifiStaNodes);
3.3.5	统计框架
统计框架包括以下功能：
1,核心框架和两个基本数据收集器：一个计数器和一个最小/最大/平均/总 观察器。
2,扩展那些轻松处理时间和数据包。
3,为OMNet++格式化的纯文本输出。
4,数据库输出使用轻量级的SQLite。
该框架基于以下核心原则：
1,	一个实验试验由一个仿真程序实例进行，无论是并行还是串行。
2,控制脚本执行模拟实例，根据需要更改参数。
3,收集并存储数据，以便使用外部脚本和现有工具进行绘图和分析。
4,通过将统计框架连接到现有的跟踪信号，采取NS-3内核的措施。
24
3.4	仿真实现方法
本文的仿真实现的环境是：电脑的操作系统为ubuntu 16.04, NS-3的版本号 是3.25,绘图工具为gnuplot,可视化动画工具为NetAnim。
想要做NS-3的仿真，首先需要搭建仿真环境。
1,虽然NS-3支持多种操作系统，但是还是建议在linux操作系统下做仿真。这 里就不说操作系统的安装步骤了，网上有许多教程。
2,操作系统准备完毕后，去官网下载NS-3 www.nsnam.oiY，后缀为.tar.bz2。将 其进行解压，使用命令为 tar xjfns-allinone-3.25.tar.bz2
3, 一切准备就绪后，就开始安装NS-3仿真平台。虽然NS-3仿真平台需要依赖 许多插件，但是我还是建议首先不需要搞清楚都需要哪些插件，也不需要事 先安装，直接安装NS-3,根据控制台的信息然后进行安装。通过上面的解压 会看到一个名为ns-allinone-3.25的文件夹，进入文件夹后使用命令./build.py 对NS-3进行编译。然后再进入NS-3.25文件夹使用命令./waf configure-enable-examples -enable-tests,开启例子和帮助，再使用命令./waf build进行 编译。在编译期间可能会出现错误，不过不用紧张，这是因为缺少插件产生 的，只要根据提示去下载对应的插件即可解决。
4,工欲善其事，必先利其器。只有单单的NS-3仿真平台，编代码进行仿真是很 痛苦的。就需要有编译器来达到事半功倍的效果。本文所用到的是eclipse来 完成的仿真，eclipse 的下载网址是 https:/Avww.ecliDse.org/downloads/,安装很 简单这里就不再熬述了，接下来就需要将NS-3配置到eclipse中去。这个配 置网上同样也有很多博文，我推荐一个实验成功的网址 *\v.cnbk>gs.com/zlcxbb/p凸852810.html,这篇博文图文并茂，只要顺着 一步一步的做就可以成功。在这里有一点需要提醒，就是在打开eclipse的时 候最后在前面加上sudo使其拥有最高权限，以防由于一些文件的访问权限的 问题而影响到仿真的进度。
5,仿真的代码一般放在scratch文件夹中，仿真人员可以使用eclipse运行程序， 同时也可以使用命令行运行程序，如./waf-run文件名，使用者可以使用shell 脚本来控制改变仿真程序的仿真次数，每次仿真的参数等，然后运行.sh文件。
6,程序运行结束后可以通过控制台显示日志或者Tracing,如果信息超出了控制 台显示的最大容量也可以通过eclipse的设置或者命令行的命令将其存入文件 中。NS-3还支持统计模块，可以通过使用sqlite3数据库将关心的数据存入到 数据库的表中。
25
7,	NS-3同样集合了 gnuplot,它可以通过API进行图片的绘制，不过这个API 还是有一些不全，如果你想使用好这部分的API同样得花时间阅读文档和代 码。你也可以使用shell脚本来读取sqlite3数据库中的数据，然后通过gnuplot 工具绘制仿真结果图。
8,	NS-3还集合了可视化动画工具为NetAnim,可以很方便的输出.xml文件。只 需要引入netAnim模块然后在代码Simulator::Stop();和Simulator::Run();之间 增加一行代码 Animationinterface anim("xxx.xml");就可以生成 xxx.xml 文件。 通过软件NetAnim打开xxx.xml文件就可以对其经行解析，然后呈现在界面 中，通过此软件可以看到节点每时每刻的运行状态和发包，收包的状态，还 可以看到各个节点中的路由表信息，使用的传输协议和路由协议等。还可以 通过NS-3的设置来显示一些仿真结果统计图，如丢包率，吞吐量等。
3.5小结
本章节主要介绍了 NS-3的一些基本知识，包括其产生，发展并与NS2进行 对比。介绍了一些学习NS-3的方法和资料，网址。NS-3由于其开源性，更新快， 代码干净等特点受到了广大开发者的喜爱。通过从整体介绍NS-3的架构和网络 仿真的一些基本概念，可以使人们更容易理清各个组件与无人机自组织网络的对 应关系。还介绍了一些常用的开发模块并简要介绍了各自的使用方式，如日志模 块，Tracing模块，移动模块等。
本章节后半部分首先手把手教你如何搭建仿真平台，并声明了一些注意的细 节，只要跟着一步一步的完成，就可以轻松搭建。平台搭建完毕后，大家可以根 据官网的样例来属性仿真平台。
26
第四章无人机可靠自组织网MAC协议性能研究
4.1	Wifi 802.11 MAC 协议
4.1.1	Wifi 802.11 介绍
为了统一规范无线局域网，国际电工电子工程学会制定了 802.11协议簇。 从1997年开始，为了满足不同的需求，802.11协议簇经历了多个版本，包括原 始标准 802.11, 802.11a-z, 8O2.11ac, 8O2.11ad, 802.11ax,本文中使用的标准为 802.11a。802.11a的工作频率为5GHz,物理层的速率最高可达到54Mbps,传输 层速率最高可达25Mbps。根据不同的情况，数据率可降为48, 36, 24, 18, 12, 9或者6Mb/s。物理层采用的是OFDM方式，支持的信道带宽为20MHz、10MHz 和5MHz。包括52个子载波，48个数据载波，OFDM符号持续时间为16 U s,保 护间隔为3.2 us,占用带宽4.15MHz。
802.11的MAC协议主要使用的是载波监听多路访问/避免冲突协议。 CSMA/CA通过使用ACK信号来避免冲突，只有当发送端接收到网络上返回来的 ACK信号才会认为数据正确的被接受到了。
我们通过下图来说明载波监听多路访问/避免冲突协议的工作原理
图4-1 A发送RTS帧	图4-2 B发送CTS帧
从图4-1和图4-2我们可以看到有5个节点，粉色区域是节点A的通信范 圉，蓝色区域是节点B的通信范围。节点B, C, E,在节点A的通信范围内，而 节点D在节点A的通信范围外。节点A, D, E在节点B的通信范围内，而节点 C在节点B的通信范围外。
当节点A要向节点B发送数据时，节点A在发送数据之前，先以广播的形
27
式向节点B发送一个RTS报文。当节点B收到RTS报文后，会想节点A发送一 个CTS报文。当节点A收到数据就可以向节点B发送数据了。
通过上面的描述大家应该了解了节点发送数据的流程，接下来我们通过在通 信期间周边节点的反应来解释下是如何冲突避免的。
首先看节点E,它同时在发送端节点A和接收端节点B的通信范围内。所以 节点E在整个通信过程中不能发送数据。节点C在节点A的传输范围内，而在 接收端节点B的传输范围内。因此节点C可以接收到节点A发送的RTS报文而 接收不到节点B的CTS报文，因此在通信过程中，节点C可以发送数据而不影响 节点B的接收。最后，让我们看看节点D,节点D在节点A的通信范围外，而在 节点B的通信范围内。所以节点D收不到节点A发送的RTS报文，但是可以收 到节点B发送的CTS报文。从而节点D在收到CTS报文后应该在节点B的接收 过程中，不可以发送数据，以避免干扰节点B接收节点A的数据。
4.1.2 NS-3平台上Wifi模块的设计及实现
NS-3仿真平台中的节点可以包含一个netdevice集合对象，就像真实计算机 包含以太网接口卡一样。在NS-3仿真平台上可以给节点添加wifinetdevice对象 来创建基于IEEE 802.11的Ad Hoc网络。
NS-3仿真平台中包括一个重要的模块即wifi模块，这个模块源码的文件目 录位于src/wifi中。在此模块中有一个重要的对象即WifiNetDevice,它是基于 802.11标准的无线网络接口控制器。NS-3仿真平台也是通过此接口给节点添加 wifi模块来进行802.11的仿真。目前NS-3支持的功能包括：
基本的802.11 DCF的基础设施和组织模式。
支持物理层 802.11a, 802.11b, 802.11g, 802.11n(2.4 和 5GHz 频段)，802.1 lac 和 802.1 lax 草案 l.Oo
聚合 MAC 服务数据单元(Aggregation Mac Service Data Unit)和根据 802.lln 扩展的聚合mac协议数据单元(MAC Protocol Data Unit简称：MPDU),并且还 可以将这两种聚合结合到一起成为两级聚合。
从802.11e扩展的基于服务质量的增强分布信道接入(Enhanced Distributed Channel Access,简称EDCA)和排队策略。
可以使用不同的传播损耗模型和传播延迟模型。
此wifi模块还支持各种码率控制算法如：Aarf, Arf, Cara, Onoe, Rraa, ConstantRate, and Minstrel o
支持802.11s mesh网络。
28
支持 802.lip 和车联网(Wireless Access in Vehicular Environment,简写： WAVE)o
虽然NS-3仿真平台中的wifi模块是基于IEEE802.il设计的，但是不是所 有的方面都与现实中的一致，同时也有许多模块目前还没有实现，等待后续的开 发更新。下面的一些细节涉及到了物理层和信道模型：
1,	802.11ax仍在草案阶段，不是所有的功能都实现了。
2,	802.11ax不包含任何的高密度的改进。
3,	802.11axmu-ofdma不支持。
4,	802.11ax只能用恒定的速率控制算法。
5,	802.11ax只支持苏协议数据单元格式。
6,	802.llac/ax MU-MIMO是不支持的，不超过4个天线可以配置。
7,	802.11n/ac/ax波束形成是不支持的。
8,	PLCP报头接收不是建模。
phy_rxstart 不支持。
图4-3 Wifi模块设计架构
29
图4-3显示了 Wifi模块的设计框架，主要包括三个子层模块：物理层模块， 下层MAC模块和高层MAC模块。
物理层模块主要负责包的接收和能量消耗的跟踪。包接收通常有三个主要部 分：
每个包的接收有可能接收成功但也有可能接收失败，这个可能性取决于调制, 信噪比和物理层的状态，比如物理层的状态为传输或者睡眠时，接收就会失败。 存在一个对象，它可以跟踪到所有的接收信号，当做接收决定的时候，可以准确 的计算干扰功率，进而决定是否被成功接收。调制和标准的一个或多个错误模型， 可以被用来评判接收成功的可能性。
下层MAC模块的功能是通过传输RTS, CTS和ACK信号进行介质访问。 下层MAC模块又可以进一步划分成下层MAC模块和中层MAC模块，中层 MAC模块的功能有:处理包队列，给数据包分帧，如果有必要还可以通过核查 WlfiRemoteStationManager 来控制包的重传。
下层MAC模块包括三个主要的组成部分，首先NS-3::MacLow关心的是 RTS, CTS, DATA, ACK 信号的传输。其次 NS-3::DcfManager 和 NS-3::DcfState 则实现了 DCF 和 EDCAF 功能。最后 NS-3::DcaTxop 和 NS-3::EdcaTxopN 处理 包的队列，包的分帧和包的重传。
高层MAC模块的功能有：mac层信标生成、探测和关联状态机以及一组速 率控制算法。目前有高层MAC模块包括三种类型分别在通信过程中扮演不同的 角色，对应于三种不同的拓扑元素。它们都继承于同一个父类NS-3::RegularWifiMaCo 其中 NS-3::ApWifiMac 对应于接入点 AP, NS-3::StaWifiMac 对应于非接入点站，NS-3::AdhocWifiMac则对应于自组织网络。
其中最简单的是NS-3::AdhocWifiMac,因为它所实现的wifi MAC是不需要 生成任何的信标，探测和连接信号的。NS-3::StaWifMac这个类实现了主动探测， 如果有太多的信标丢失时，可以连接状态机来进行自动重连。NS-3::ApWifiMac 实现了一个接入点，它可以周期性的生成信标，而这个生成的信标可以接受每一 次的尝试连接。
这三个高层MAC模块都继承了相同的父类NS-3::RegularWifiMac,这个父 类暴露给它们一些MAC配置，如属性QosSupported是用来配置是否允许 802.11eAVMM-style支持服务质量，属性HtSupported则是用来配置是否允许 802.1 In支持高吞吐量，属性VhtSupported用来配置802.1 lac是否支持非常高的 吞吐量，属性HeSupported是用来配置是否允许8O2.ax支持高效率。
30
4.	L3 Wifi模块的调用
对Wifi模块的使用其实就是给节点配置网络设备接口。WifiNetDevice的配 置功能非常强大但是使用起来非常复杂。当仿真的时候大部分的配置都是不变的 只需要改变个别的配置，所以NS-3提供了一些帮助类通过使用默认设置来简化 它的使用。这些帮助类还使用了 NS-3的属性系统，允许用户更改默认的属性值。 创建WifiNetDevice需要一下几步来完成：
首先需要决定使用什么物理层，如SpectrumWifiPhy或者YansWifiPhy。这 个将影响到使用何种信道与其相对应。
配置信道，信道是信号的传播通道，信号可以从一个设备通过同一个wiE信 道到达另一个设备。信道的主要配置包括信道的传播损耗模型和传播时延模型。
配置wifi物理层，wifiphy负责实际发送和接收来自信道的无线信号。在这 里，wifiphy决定每帧将被成功解码或不根据接收信号强度和噪声。因此，对 wifiphy主要的配置是错误率模型，可以通过错误率模型计算成功解码的概率。
配置WifiMac,这一步是用来配置wifi结构和设备的级别的。用卢可以将其 配置成ap-sta或者ad-hoc的wifi结构，还可以配置802.1 Ie是否支持Qos, 802.1 In 是否支持HT, 802.11ac是否支持VHT, 802.1 lax是否支持HE。
创建WifiDevice,在这一步，用户配置期望的wifi标准(如,802.11a, 802.11b, 802.11g, 802.1 In, 802.11 ac 或者 802.11 ax)和速率控制算法。
配置移动模型，通常WifiNetDevice需要移动模型。
以下是根据上述的仿真顺序完成的代码实现：	皿
创建一个节点容器，存放两个节点。
NodeContainer AdHocNode;
AdHocN ode.Create(2);
创建信道助手和物理层助手，然后将物理层接入到信道中。
YansWifiChannelHelper channel = YansWifiChannelHelper: :Default();
YansWifiPhyHelper phy = YansWifiPhyHelper: :Default();
phy.SetChannel(channel.Create());
创建MAC助手，并设置wifi结构为ad-hoc,时隙大小为16uso
WifiMacHelper mac;
mac.SetType("NS-3::AdhocWifiMac", "Slot", StringValue("16us"));
创建wifi助手，将wifi标准设置成802.11a,并设置恒定的传输速率为6Mbpso
WifiHelper wifi;
wifi.SetStandard(WIFI_PHY_STANDARD_80211 a);
31
wifi.SetRemoteStationManager(nNS-3::ConstantRateWifiManager'\MDataModen, String Value(n0fdmRate6Mbpsn));
创建网络设备容器，用来管理所有节点的设备，通过上面创建的wifi助手， 物理层助手，MAC助手给节点容器安装网络设备。
NetDeviceContainer AdHocDevices;
AdHocDevices = wifi.Install(phy5 mac, AdHocNode);
4.2	TDMA MAC 协议
4.2.1	TDMA 介绍
时分多址（Time division multiple access,缩写：TDMA）,是在通信技术中 的一种常见的多址技术。时分多址是将时间分割成不重叠的时间段即为帧，而又 将每个帧分割成多个不相交的时隙，其中每个时隙与每个节点一一对应，而信道 中的每一个节点共享所有的频率。每个节点只有在到达自己的时隙才可以发送接 收数据。在自己时隙中发送数据的时候，如果剩下的时间不足以发送剩下的数据 则只有到达下一次自己的时隙时才可以继续发送。TDMA实现起来比较简单，但 是每一个简单的东西都会有其自身的缺点，那就是延时较大，不过在节点数不多 的情况下它的缺点并不会显现的特别明显。下图即为时分多址在频域，时域和空 域中的结构图。
空间	时间
图4-4 TDMA结构图
32
4.2.2	NS-3平台上TDMA设计及实现
时分多址是一种无竞争的媒体访问协议。网络中所有节点共享的信道带宽被 划分为这些节点中专用的时隙。每个节点仅在分配给它的专用时隙期间传输数据。 传输时隙通常是固定的时间间隔。每个传输时隙由一个保护间隔隔开，以便传输 不重叠。保护间隔的值由简单无线信道模型决定。这通常是数据包传输距离所规 定的距离所需的时间。在这个简单的TDMA模型中，假定节点的时钟是同步的。
TDMA的NS-3实现有一个集中的TDMA控制器，为网络中的各个节点分 配传输时隙。图4-5是TDMA模块的架构图，在这个架构中主要的类有“NS-3 :: TdmaControlIer,,, “NS-3 :: TdmaCentralMac"和"NS-3： TdmaMacQueue"。NS-3 :: TdmaController 控制协议的调度。NS-3 :: TdmaCentralMac 功能有 TDMA 帧 处理，创建MAC头和尾部以及MAC回调机制。NS-3 :: TdmaMacQueue负责数 据包的入队和出队。
图4-5 TDMA模块架构图
33
TdmaCentralMac类的基类是TdmaMac。目前的实施考虑简单的集中式 TDMAMAC协议。但是，考虑到分布式TDMA模型的其他可能实现，在这里 创建了一个通用基类，以便可以从中派生出其他实现。所有准备好由节点传输 的数据包都从网络层发送到TdmaCentralMac。接收到数据包后，将它们排入队 列并等待数据被发送的时隙发送数据包。节点等到自己发送的时隙， TdmaCentralMac类查找自己队列TdmaMacQueue的数据包发送数据。然后迭代 地将数据包出队，附加MAC头部和尾部，并将它们发送到 SimpleWirelessChannelo在发送之前，TdmaCentralMac根据数据包大小和数据 速率计算所需的传输时间。将所有发送数据包的传输时间相加，并将其与由 TdmaControlIer分配给它的时隙SlotTime进行比较。如果无法在该时隙中传输 更多的数据包，则停止传输。简单无线信道将数据包转发给所有的节点，节点 可以通过在仿真开始时由用户指定的MaxRange属性值判断是否接受。 TdmaCentralMac也负责从简单无线信道接收数据包。它删除附加的MAC头和 尾部，并将数据包转发给网络层。
TdmaMacQueue用来维护一个数据包队列，存储从网络层收到的数据包， 直到到达它的传输时隙。可以修改这个类的属性是队列长度MacQueueLength 和数据包在队列中的持续时间MacQueueTimeo因此，在队列大小达到 MacQueueLength之后，所有试图进入队列的数据包被丢弃，并且存储在队列 中的数据包长于MacQueueTime的时间间隔也被丢弃。
TdmaControlIer负责协议的所有调度方面。它启动TDMA会话并授权节点 在其指定的时隙中传输。它用来给节点设置时隙持续的时间和控制全局时隙的 数目，作为节点在仿真开始时指定的属性。时隙默认值为UOOus,保护时间为 lOOuso
在仿真过程中主要包括两方面的过程，首先在仿真开始后TdmaControDer会 对每个节点分配各自的时隙。然后通过调度函数去不断地周期性轮询时隙来让 对应的节点发送数据在每次轮询到一个时隙则会调用TdmaCentralMac类中的 StartTransmission函数去发送数据，此时通过判断队列中是否有数据还需要判断 传输数据所需时间是否小于时隙剩余的时间，只有这两个方面同时成立才能讲 数据传输到TdmaMacLow进而传输到信道。当传输到目的节点时判断数据包传 输到距离是否超出了设定的通信范围，如果没有超出则像图5一样一步一步地向 上层传输。其次在节点有数据发送的时候，网络层讲数据发送给TdmaNetDevice 然后在发送到TdmaCentralMac类并不是将数据包直接发送出去，而是先存到队 列当中，这时候就用到了TdmaMacQueue来维护数据包队列，这个类中的功能 34
有出队，入队，清空队列，获取队列长度等。通过判断队列中数据的多少和每 个数据包存放的时间过期与否来删除数据包。
4.2.3	TDMA模块的调用
TDMA模块的调用，其实非常简单，只需要三部就可以完成。
1,首先需要引入 TDMA 模块#include "NS-3/simple-wireless-tdma-module.h",
2,通过简单无线信道中的属性MaxRange可以设置最大通信范围
Config::SetDefault(nNS-3::SimpleWirelessChannel::MaxRangeH, DoubleValue(txDistance));
3,给每个节点分配一个时隙，即节点数等于时隙数，然后通过这两个参数 获取 TdmaHelper, TdmaHelper 管理 TdmaController 和通过 install 函数给节点安 装tdma协议生成网络设备。
TdmaHelper tdma = TdmaHelper(nodeContainer.GetN()?
nodeContainer. GetN ());
TdmaContmller负责协议中的调度，需要设置的参数包括时隙时间，保护时 间，帧间时间。
TdmaControllerHelper controller;
controller.Set(MSlotTimeH, TimeValue(MicroSeconds(l 100)));
controller.Set(,,GaurdTimeH, TimeValue(MicroSeconds(100)));
controller.Set(HInterFranieTimen, TimeValue(MicroSeconds(0)));
tdma.SetTdmaControllerHelper(controller);
netDeviceContainer = tdma.Install(nodeContainer);
4.2.4	TDMA模块的验证
以上已经引入了 TDMA模块，分析了其设计架构，且简要介绍了其使用方 法的说明。本节将通过实例验证引入的TDMA模块的正确性。其中公共的参数 有：
表4・1基本参数表
参数类型	参数值
传输信道类型	Simple WirelessChannel
MAC类型	TdmaCentralMac
MAC队列模型	TdmaMacQueue
35
MAC队列长度	400
MAC队列最大时延	500ms
MAC队列丢包策略	DROP_NEWEST
路由协议类型	AODV
传输层协议类型	Udp
天线类型	OnmiAntenna
节点有效通信半径	110m
仿真场景一
场景中只有两个节点相距50m并且一直处于静止状态，节点2向节点1发 送数据。发送的速率从50packets/s至U 1000packets/s,间隔为50packets/s。下图 横坐标为发送速率，纵坐标为平均时延，从图中可以看出发包速率达到400 packets/s后时延很快趋近于0.5s。这是因为设置的数据包在队列存在的最长时间 为0.5s。因此验证了其的正确性。

0.8
0.6
0.4
0.2
0
0	200	400	600	800	1000
data rate (kb/s)
图4-6平均时延
仿真场景二
在这个场景中节点的数量从2个增加到10个，节点间的距离为50m且处 于静止状态。节点2向节点1发送数据包，发送速率为1 packets/s。下图横坐 标为时间，纵坐标为时延。从图中可以看出随着仿真场景中节点数的增加，数 据包传输的时延越来越大。这是由于每加入一个节点都会给其分配时隙，每次 轮询到节点去发送数据的时间就会增大，从而验证了其的正确性。
36
time (s)
图4-7每个包的时延
4.3	协议性能仿真分析与比较
4.3.1	NS-3平台功能改进
在NS-3中虽然已经有一些应用模块和移动模块并且它们实现了基本的功能, 供网络仿真用。但是针对不同场景的应用和采集的数据不同，这些已经实现的模 块灵活性并不强甚至在仿真中还出现了一些问题。本节主要改进的模块主要有两 部分，应用层的封装和移动模型的改进。并且将其运用于仿真系统，真实了其正 确性。
4.3.1.1	应用层实现
随着节点数的增加，发送端和接收端的增加，给节点设置发送和接收的应用 越来越繁琐，并且仿真的数据也不好管理，出于此原因，我创建了一个新模块， 用来封装应用。方便了发送端应用和接收端应用的创建，开启，停止。并通过结 果集收集仿真后的数据，便于仿真后的结果的呈现。
37
SJBSe0qer
public
void SetStartTimefUme start) void SetStopPme(Time stop)
private Ptr<Node> m_node Time m_startTime Time m_stoplime
private uint32J m_pktSize uint32_t m_numPkts Ptr<ConstantRcndomVariabie>m_interva! lpv4Address m_destAddress uint32_t m„destPort Ptr<Socket> m_socket std::vector<Ptr<ResultObject»m_sendList
public setDestination(lpv4Address address) std::vector<Ptr<ResultObject» getSendUstf) private void StortApplicationf) void Stop Application 0 void SendPacketO
^承
每个属性的set, gel方法
依赖/
Time m_timestamp
void SetTimeslampfnme time) Time GetTimestampf)
double mjeceivetime double m_deloy uint32J m_recelvePocketNurnPerSec uint32_t m_pocKetUid
依赖\

图4-8应用封装类图
图4-8展示了封装应用的类图结构，主要包含三部分：发送应用，接收应用， 时间戳，和仿真结果对象。
发送应用(SJBSender):可以设置目的ip地址，端口号，发送数据包的大小， 发送数据包总数，发送间隔。开启，停止应用，并可以获取发送数据包的集合。
接收应用(SJBReceiver)：可以设置监听端口，并能跟踪接收数据包。开启， 关闭应用，并能获取接收数据包的集合。
时间戳(SJBTimestampTag)：给数据包添加时间戳，当接收到包时，可以通 过时间戳计算出应用层的时延。
仿真结果对象(Resultobject)：是仿真对象的封装，其中包括数据包接收时 间、时延、每秒接收的数据包数，数据包id号。
创建新模块./create-module. py s jb-module,并在mode］文件夹下创建 SJBApplication. h, SJBApplication. cc, ResultObject. h, ResultObject.cc 四 个文件。其中ResultObject封装了仿真的结果信息。SJBApplication是对应用 层的实现，具体实现代码如下：
ttinclude <ostream>
38
^include "NS-3/core-module, h"
^include “NS-3/network-module, h”
Sinclude ，zNS-3/internet-module, h”
#include z，NS-3/stats-module. hz，
#include “SJBAppIication. h"
♦ include ^ResultOb ject. hzz
using namespace NS-3;
NS_LOG_COMPONENT_DEFINE ("SJBApplication");
//发送应用属性有：PacketSize传输包的大小，Destination目标主机ip 地址，Port端口，//NumPackets发送的包数，Interval数据包发送的时间间隔。
Typeld
SJBSender::GetTypeld (void) (
static Typeld tid = TypeTd ("SJBSender")
.SetParent<Applicati on> ()
.AddConstruetor<SJBSender> ()
.AddAttribute ("PacketSize”，〃The size of packets transmitted.，z, UintegerValue (64),
MakeUintegerAccessor (&SJBSender::m_pktSize), MakeUintegerChecker<uint32_t>(1))
.AddAttribute ("Destination", "Target host address. /z, Ipv4AddressValue ("255. 255. 255, 255”), MakeTpv4AddressAccessor
(&SJBSender::m_destAddr), MakeIpv4AddressChecker ())
.AddAttribute ("Port”, ^Destination app port.", UintegerValue (1603), MakeUintegerAccessor (&SJBSender::m_destPort), MakeUintegerChecker<uint32_t>())
.AddAttribute ("NumPackets", "Total number of packets to send. ”, UintegerValue (30), MakeUintegerAccessor (&SJBSender::m_numPkts), MakeUintegerChecker<uint32_t>(1))
.AddAttribute ("Interval", "Delay between transmissions.
39
StringValue	("NS -
3::ConstantRandomVariable[Constant=O. 5]"),
MakePointerAccessor (&SJBSender::m_interval), MakePointerChecker <RandomVari ableStream>()) .AddTraceSource ("Tx”, 〃A new packet is created and is sent”, MakeTraceSourceAccessor (&SJBSender::m_txTrace));
return tid;}
SJBSender::SJBSender () {NS_L0G_FUNCTI0N_N0ARGS (); m_interval 二 CreateObject<ConstantRandomVariable> (); m_socket = 0;}
SJBSender::〜SJBSender() {NS_LOG_FUNCTION_NOARGS ();) void SJBSender::DoDispose (void) {NS_LOG_FUNCTION_NOARGS ();
m_socket = 0;
Application::DoDispose ();}
〃发送端应用开始的入口，系统调用此函数，再通过SendPacket函数发送 数据
void SJBSender:rStartApplication () {NS_LOG_FUNCTION_NOARGS ();
if (m_socket == 0) {
Ptr<SocketFactory> socketFactory 二 GetNode ()->GetObject<SocketFactory> (UdpSocketFactory::GetTypeId 0); m__socket = socketFactory->CreateSocket (); m_socket->Bind ();} m_count = 0;
Simulator::Cancel (m_sendEvent);
m_sendEvent = Simulator::ScheduleNow (&SjBSender::SendPacket, this) ;} void SJBSender::StopApplication () {NS_LOG_FUNCTION_NOARGS ();
40
Simulator::Cancel (m_sendEvent);}
〃发送数据包并将仿真期间发送的数据存放到忆sendList.集合中，以便以 后使用
void SJBSender::SendPacket ()
{Ptr<Packet> packet = Greate<Packet>(m_pktS i ze);
S JBTimestanipTag time st amp;
times tamp, SetTimestamp (Simulator::Now ());
packet->AddByteTag (timestamp);
m_socket->SendTo (packet, 0, InetSocketAddress (m_destAddr, m_destPort));
Ptr<ResultObject> tempObject=CreateObject<ResultObject>(); tempObject->setPacketUid(packet->GetUid()); m_sendList. push_back(tempObject);
// Report the event to the trace.
m__txTrace (packet) ;	•
if (++m_count < m_numPkts) { nj_sendEvent = Simulator::Schedule (Seconds (m_interval->GetValue ()), &SJBSender::SendPacket, this) ;}} 〃设置目的地ip地址
void SJBSender::setDestination(Ipv4Address destAddr) { m__destAddr=destAddr;} //获取仿真中的发送信息集合 std::vector<Ptr<ResultObject> > SJBSender::getSendList(){
return m_sendList;}
〃接收应用，属性包括Port接收端监听的端口。
TypeTd
SJBReceiver::GetTypeId (void)
{static TypeId tid 二 TypeId ("SJBReceiver")
.SetParent<Application> ()
.AddConstructor<SJBReceiver> ()
.AddAttribute ("Port", "Listening port.”, UintegerValue (1603),
41
MakeUintegerAccessor (&SJBReceiver::m_port), MakeUintegerChecker<uint32_t>()) .AddTraceSource ("Rx”, 〃A packet is received”, MakeTraceSourceAccessor (&SJBReceiver::m_rxTrace));
return tid;}
SJBReceiver::SJBReceiver():
tn_calc (0),
m_delay (0) {NS_LOG_FUNCTION_NOARGS ();
m_socket = 0;}
SJBReceiver: &SJBReceiver() {NS_LOG„FUNCTION_NOARGS ();} void SJBReceiver::DoDispose (void) {NS_LOG_FUNCTION_NOARGS ();
m_socket = 0;
// chain up
Application::DoDispose () ;}
〃发送端开始的函数入口，并设置接收端的监听回调函数。
Void SJBReceiver:rStartApplication () {NS_LOG_FUNCTION_NOARGS ();
if (m_socket = 0) {
Ptr<SocketFactory> socketFactory 二
GetNode ()->Get0bject<SocketFactory> (UdpSocketFactory::GetTypeId ());
m_socket = socketFactory->CreateSocket ();
InetSocketAddress local 二
InetSocketAddress (Ipv4Address::GetAny (), m_port); m_socket->Bind (local);} m_socket->SetRecvCalIback (MakeCal1back (&SJBReceiver::Receive, this));} void SJBReceiver:zStopApplication () {NS__LOG_FUNCTION_NOARGS ();
if (m_socket != 0) { rn_socket->SetRecvCal Iback
42
(MakeNulICallback<void, Ptr<Socket> > ());}}
void SJBReceiver::SetCounter (Ptr<CounterCalculator<> > calc) {m_calc = calc;}
void	SJBReceiver::SetDelayTracker
(Ptr<TimeMinMaxAvgTotalCalculator> delay)
{m_delay - delay;}
〃获取接收端仿真期间的仿真结果数据集。
std::vector<Ptr<ResultObject> >
SJBReceiver::getReceiveTimeList()
{return m_receiveTimeList;}
〃接收数据，并往接收数据集合中增加仿真数据，以便呈现仿真结果。
Void SJBReceiver::Receive (Ptr<Socket> socket)
{ Ptr<Packet> packet;
Address from;
while ((packet = socket-〉RecvFrom (from))) { if (InetSocketAddress::IsMatchingType (from)) { NS_LOG_INFO ("Received ” << packet->GetSize () << 〃 bytes from 〃 <<
InetSocketAddress::ConvertFrom (from). Getlpv4 () <<	-
“packetUid: zz<< packet->GetUid()«，z time: "〈〈Simulator::Now ());) SJBTimestampTag timestamp;
if (packet->FindFirstMatchingByteTag (timestamp)) {
Time tx = timestamp.GetTimestamp ();
if (m_delay != 0) {
Time now= Simulator::Now ();
m_delay->Update (now - tx);
Ptr<ResultObject> tempObject=Create()bject<Result()bject> ();
tempObject->setReceiveTime(now. GetSeconds ());
tempObject->setDelay((now-tx). GetSeconds ());
tempObject->setSendMacQueueSize(packet->getSendQueueSize());
tempObject->setPacketUid(packet->GetUid ());
m_receiveTimeList. push__back (tempObject) ;}} m_rxTrace(packet);
if (m_calc !- 0) {
43
m_calc->Update ();
NS.LOGJEBUG (，zrn_calcz，«m„calc->GetCount ());}}}
//时间戳对象，用来标识发送数据和接收数据时刻的时间，通过这两个数据 就可以分析发送〃数据的时延
Typeld SJBTimestanipTag: :GetTypeId (void)
{static Typeld tid = Typeld ("SJBTimestampTag")
.SetParent<Tag> ()
.AddConstructor<SJBTimestampTag> ()
.AddAttribute ("Timestamp”,
“Some momentous point in time!”, EmptyAttributeValue (), MakeTimeAccessor
(&SJBTimestampTag::GetTimestamp),
MakeTimeChecker 0)；
return tid;)
Typeld
SJBTimestampTag::GetInstanceTypeId (void) const
{return GetTypeld () ;}
uint32_t SJBTimestampTag::GetSerializedSize (void) const
{ return 8;}
void SJBTimestanipTag: Serialize (TagBuffer i) const
{int64_t t = m_timestamp. GetNanoSeconds ();
i.	Write ((const uint8_t *)&t, 8) ;}
void SJBTimestampTag::Deserialize (TagBuffer i)
{int64_t t;
i.	Read ((uint8_t *)&t, 8);
m_timestamp = NanoSeconds (t);}
void SJBTimestampTag::SetTimestamp (Time time)
{m_timestamp = time;}
Time SJBTimestampTag::GetTimestamp (void) const
{return m_timestamp;}
void SJBTimestampTag::Print (std:rostream &os) const {os <<	<< m_timestamp;}
44
431.2移动模型的改进
修改源码中二维随机游走模型，目录在mobile/ random-walk-2d-mobility-model.cc
修改原因：如果移动的节点跑出设定的边界，程序则停止无法继续执行。由 于此移动模型是方向随机、速度随机的，如果边界设定的比较小，则很容易结束 程序。
修改逻辑：
判断如果向右移动最大速度乘以持续时间超出了右边界则让节点向左移动。 判断如果向左移动最大速度乘以持续时间超出了左边界则让节点向右移动。 判断如果向上移动最大速度乘以持续时间超出了上边界则让节点向下移动。 判断如果向下移动最大速度乘以持续时间超出了下边界则让节点向上移动。 代码如下：
void RandomWalk2dMobilityModel::DoWalk (Time delayLeft)
{Vector position = m_helper.GetCurrentPosition ();
Vector speed = m_helper.GetVelocity ();
Vector nextPosition = position;
if(m_bounds.xMax<nextPosition.x+m_speed->GetValue()*m_modeTime.GetSe conds()){
nextPosition.x ・=m_speed->GetValue()*m_modeTime.GetSeconds();
}else	if(m_bounds.xMin>nextPosition.x-
m_speed->GetValue()*m__rnodeTime.GetSeconds()){
nextPosition.x += m_speed->GetValue()*m_modeTime.GetSeconds();
}else{nextPosition.x += speed.x * delayLeft.GetSeconds ();}
if(m_bounds.yMax<nextPosition.y+m_speed->GetValue()*in_modeTime.GetSe conds()){nextPosition.y -= m_speed->GetValue()*m_modeTime.GetSeconds();}
else	if(m_bounds.yMin>nextPosition.y-
m_speed->GetValue()*m_modeTime.GetSeconds()){
nextPosition.y += m_speed->GetValue()*m_modeTime.GetSeconds();
}else{nextPosition.y += speed.y * delayLeft.GetSeconds ();)
if(nextPosition.x<0){ nextPosition.x-nextPosition.x;) if(nextPosition.y<0){nextPosition.y=-nextPosition.yJ if (m_bounds.lslnside (nextPosition))
45
{m_event=Simulator::Schedule(delayLeft5
&Random Walk2dMobilityModel: :DoInitializePri vate, this);}
else{nextPosition = m_bounds.CalculateIntersection (position, speed);
Time delay = Seconds ((nextPosition.x - position.x) / speed.x);
m_event= Simulator:: Schedule
(delay, &RandomWalk2dMobilityModel::Rebound, this,
delayLeft- delay);}
NotifyCourseChange ();)
验证修改后正确性，验证场景：设置两个节点，节点0初始位置为(10, 10, 0),节点1的初始位置为(40, 40, 0),设置他们的移动模型都是随机游走模型
RandomWalk2dMobilityModel可移动的范围为x轴从0到50米,y轴从0到 50米，移动速度为16m/s,移动方向随机，随机触发模式为时间，每0.1s经行随 机改变方向。运行时间为1000s,以下是节点移动模型的设置。
Ptr<ListPositionAllocator> positionAlloc = CreateObject<
ListPositionAllocator>();
positionAlloc->Add(Vector( 10, 10, 0.0));
positionAlloc->Add(Vector(40, 40, 0.0));
mobility.SetPositionAllocator(positionAlloc);
mobility.SetMobilityModel(,,NS-3::RandomWalk2dMobilityModer,, "Bounds",
RectangleValue(Rectangle(O, 50, 0, 50)),
"Time", TimeValue(Seconds(0.1))? nModen,
EnumValue(RandomWalk2dMobilityModel::MODE„TIME)
,,'DirectionM?StringValue(,,NS3::UnifbrmRandomVariable[Min=0.0|Max=6.2831 84]n)；,Speedn?StringValue(,,NS-3::UniformRandomVariable[Min=16.0|Max=16.0]H
);
mobility.Install(nodeContainer);
通过NetAnim软件可以显示节点的运行轨迹，如下图所示。虽然在图中看 到了一些范围外的轨迹，但是我通过此软件的动画发现节点并没有运行在范围外 的轨迹上，可见两个节点的运行轨迹在设置的范围内，验证成功。
46
图4-9 节点移动轨迹
4.3.2仿真场景设计
表4-2公共仿真参数
参数类型	参数值
传输信道类型	YansWifiChannel/SimpleWirelessChannel
传播损耗模型	FriisPropagationLossModel/5£
传播时延模型	ConstantSpeedPropagationDelayModel/5€
物理层协议类型	YansWifiPhy/5t
MAC类型	AdhocWifiMac/TdmaCentralMac
MAC队列模型	WiHMacQueue/TdmaMacQueue
MAC队列长度	400
MAC队列最大时延	5()0ms
MAC队列丢包策略	DROP_NEWEST
路由协议类型	AODV
传输层协议类型	Udp
天线类型	OmniAntenna
节点有效通信半径	110m
表4-3仿真参数
参数	参数值
节点个数	8
运行速率	1 6(m/s)
数据包大小	1 024(Byte)
47
传输速率	50,100...1000(packet/s)
发送间隔	0.02,0.01...0.001(s)
仿真时长	50(s)
节点运动范围	200m*200m

图4-10节点拓扑结构
图4-10使用了 NetAnim来展示节点的拓扑结构，图中含有8个节点分布在 两行，每行节点含有4个节点。这个拓扑结构就是以下仿真场景一和二的网络拓 扑结构。
仿真场景一
两个节点以16m/s的速度在通信范围内随机运动，节点6向节点0发送数 据，比较802.1 la协议和TDMA MAC协议，在不同数据包发送速率的条件下对 网络性能的影响，如：时延，丢包率和吞吐量。
仿真场景二
8个节点以16m/s的速度在通信范围内随机运动，节点4向节点0发送数 据，节点5向节点1发送数据，节点6向节点2发送数据，节点7向节点3发送 数据，比较802.1 la协议和TDMA MAC协议，在不同数据包发送速率的条件下 对网络性能的影响，如：时延，丢包率和吞吐量。
48
4.3.3仿真结果分析
4.3.3.1仿真场景一的仿真结果及分析
在仿真场景一中紫色的点划线代表802.11a MAC协议，绿色的代表TDMA MAC协议。通过将不同的数据发送速率得到的仿真结果连接成一条线来展示不 同协议对网络性能影响的差异。
1 I	1	।	।	i	t
802.1 la —'—
TDMA
0.2
200	400	600	800	1000
data rate (kb/s)
0
图4-II 802」la和TDMA平均时延随发送速率的变化
横坐标为数据包发送的速率，纵坐标为平均时延。从上图可以看出TDMA 协议在速率到达400kb/s以后时延逐渐增加，最终达到0.5秒，802.1 la协议在速 率到达600kb/s以后时延逐渐增加，最终同样达到0.5秒。
时延最终达到0.5秒是因为MAC队列设置的最大时延为500ms,时延超过 500ms的数据包就会被丢弃. TDMA产生时延的原因是节点等到了自己的时隙 才发送数据，并且在自己的时隙时如果剩下的时间不够发送数据包，则会再次到 达自己的时隙再发送数据包。802.11a产牛时延的原因是因为wifi模块使用的是 载波监听多路访问/冲突检漫方法是一种争用型的介质访问控制协议，使用了退 避算法。从图中可以看出在时延方面802.1 la协议比TDMA协议好。
49
8 6 4 2 o o o O ogf 9SQI S3CNUC5C1
0
0
200
400	600	800	1000
data rate (kb/s)
图4-12 802.1 la和TDMA丢包率随发送速率的变化
横坐标为数据包发送的速率，纵坐标为丢包率。从上图可以看出TDMA协 议在速率到达400kb/s以后丢包率逐渐增加，802.1 la协议在速率到达600kb/s以 后时延逐渐增加。
发生丢包是因为当发送数据包速率增加的时候,MAC队列的长度逐渐增大, 速率到400kb/s时TDMA的MAC队列变满了。继续增加发送速率，当新的包准 备入队时发现MAC队列已经满了就会直接丢弃。速率到600kb/s时802.11a的 MAC队列变满了，丢弃策略同样是丢弃最新的数据包。
50
o o o o O o o o o O
0 8 6 4 2
(s户GXOBd)户 ndqmno匚一口
0
600
800
1000
400
200
0
data rate (kb/s)
图4-13 8O2.Ha和TDMA吞吐量随发送速率的变化
横坐标为数据包发送的速率，纵坐标为吞吐量。从上图可以看出TDMA协 议在速率到达400kb/s以后吞吐量达到了恒定的值400packets/s, 802.11a协议在 速率到达600kb/s以后吞吐量达到了恒定的值600packets/so可见802<la的吞吐 量比TDMA高。
4.3.3.2仿真场景二的仿真结果分析
在仿真场景一中只有一对节点在通信，由此可以通过增加通信的节点数量分 析两种协议对网络性能的影响。在仿真场景二中有四对通信节点，其中节点0, 1，2, 3为接收节点其它的是发送节点。其中紫色代表节点4和节点0之间的通 信，绿色为节点5和节点1之间的通信，蓝色代表节点6和节点2之间的通信， 橙色代表节点7和节点3之间的通信。
51
0.8
0.6
0.4
0.2
data rate (kb/s)
图4・14 TDMA多通信平均时延
1000
400
600
800
200
data rate (kb/s)
200
400
600
800
1000
图4-15 802.11a多节点平均时延
52
o 8 6 4 2 0 o o o o
200	400	600	800	1000
data rate (kb/s)
图4・16 TDMA多节点通信丢包率
11
OQEL SSOI SA①*opa
8 6 o o
o
2 o
o
Vode lode 7ode Vode
4--»Node
5--»Node
6--»Node
7--»Node
0 -
1 —
2
3	11111・',
200	400	600	800	1000
data rate (kb/s)
图 4-17 802.1 la
多节点通信丢包率
53
(s 'saGNocod ) a nckanojlw
o o o o o o o o o o o o
0 8 6 4 2
200	400	600	800	1000
data rate (kb/s)
图4-18 TDMA多节点通信吞吐量
o o o o o o o o o o o
0 8 6 4 2
lx

o
200	400	600	800	1000
data rate (kb/s)
图4・19 802.11a多节点通信吞吐量
54
图4-14和4-15对比了两个协议对四组通信的平均网络时延的影响，图4-16 和4-17对比了两种协议对网络丢包率的影响。图4-18和4-19代表了两种协议对 吞吐量的影响。和仿真场景1随着通信数量的增加网络的性能也在下降。但是整 体看来802.11a协议还是比TDMA的性能好。
TDMA：随着节点数的增加，时隙数量也在增加，轮到自己的发送时隙的时 间就会变长，从而时延就会增大，MAC队列的增长的速度也会加快从而更短的 时间队列就会变满，丢包率就会增加。
802.11a：随着通信数量的增加发生冲突的概率就会变大，从而退避算法的时 间就会加大，从而使时延变大，MAC队列的增长的速度也会加快从而更短的时 间队列就会变满，丢包率就会增加。
4.4小结
本章主要的工作内容：
1,介绍wifi 802.11 MAC层的主要的工作原理，并分析了 NS-3仿真平台上 对wifi模块的设计和实现方法，以及使用方法。
2,介绍了 TDMAMAC协议的工作原理。由于NS-3仿真平台中没有单独的 TDMAMAC协议，所以引入了外部的一个静态的TDMA模块，并经过调试使其 融入NS-3仿真平台。分析和介绍了这个模块的设计和实现方法，以及使用方法。
3,由于仿真的需要，本章改进了 NS-3仿真平台中的随机游走移动模型。封 装了一个发送器和接收器，可以更灵活地安装给多个节点，还可以跟踪仿真结果 最终绘制出网络性能的统计图。
4,最后设计了两种仿真场景，根据发送速率的不同和通信数量的不同，绘 制出了仿真后的统计结果图。比较和分析了不同的MAC协议对网络性能带来的 影响。
55
第五章总结与展望
5.1工作总结
无人机由于其小巧，灵活，精准，高效的特点越来越受各个领域欢迎如，军 事，民用，农业工业等。在受灾环境中同样发挥了不可替代的角色，在本文第一 章中己经例举了无人机在各种受灾的环境中发挥了多种不同的作用。当发生灾难 后，许多通信的基础设施会被破坏，道路堵塞,从而给救援人员增加了很多困难。 而无人机可以通过自组网来解决通信问题，并且可以通过拍摄受灾路况，为救援 方案提供信息。可以预见，无人机将会在不同的领域使用越来越广泛。本文在搭 建了无人机自组织网络，在网络层采用了经典的AODV路由协议，在MAC层 分别采用了 wifi 802.1 la的CSMA/CA协议和引入的静态TDMA协议。通过NS-3仿真平台建立网络模型，节点模型和应用模型，并通过设置不同的无人机数量， 移动速度，发送速率，通信个数等对不同的MAC协议所组成的自组织网络的性 能做了比较。
本文的主要内容如下：
1,通过分析文献，查找资料，总结了国内外对无人机自组网的研究现状。 详细的介绍了无人机可靠自组网的关键技术，如路由协议和MAC协议等。
2,详细介绍分析了 NS-3仿真平台。列举了几个仿真常用的模块，对其经行 了介绍和使用的说明。通过仿真样例介绍了 NS-3的仿真流程。
3,介绍了 NS-3中的wifi模块，并介绍了它的体系结构和使用方法。由于 NS-3没有TOMA模块，本文引入了 TDMA模块，并介绍了其体系结构和使用 方法。由于本文仿真的需要，对NS-3仿真平台中的随机游走移动模型做了改进， 设计出了有助于统计仿真结果的接收器和发送器。
4,通过仿真结果可以看出802.11a协议比引入的静态TDMA协议性能好。
5.2未来展望
在本文的研究中，在其他参数都相同的情况下，随着数据的发送速率的增加， wifi的各项性能都比静态TDMA协议的性能要好，同样随着通信数量的增加， 相比之下还是wifi的性能要好些。但是由于引入的是静态的TDMA并没有做任 何优化和改善。而且，时隙的大小并没有根据发送数据的大小动态的改变来减少 时延。所以如何修改现有的静态TDMA为动态TDMA并且可以通过发送数据的 56
第五章总结与展望
大小动态的修改时隙的大小有待研究。由于wifi的mac协议是竞争类的MAC协 议，而TDMA是分配类的MAC协议，本文原本的目的是对比TDMA和OFDM 分配类的MAC协议。但是NS-3仿真平台上缺少OFDM MAC协议，而作者在 编写OFDM MAC协议的时候遇到了些问题，比如发送的信号如何在信道中叠 加，然后再被载波解调。所以，在NS-3仿真平台上设计编写OFDM分配类MAC 协议同样有待研究。
在地震发生后，由于通信系统的基础设施的破坏，如何通过无人机自组织网 络快速的恢复通信，并且如何将快速建立的自组织网络和其他网络进行融合，相 信这些也将会成为一个研究点。无人机的发展将会把人的思维从地面升入天空， 我们的生活空间将会变的更大，更立体!每件事情都有两面性，在无人机快速发 展的同时，也出现了许多问题。最让人们关注的就是安全和隐私了。国家政府也 会提出快速，准确的应对方案来维护人民的安全和隐私。任何事情都不是一蹴而 就的，需要广大科研工作者的研究和积累，相信在快速发展的今天，无人机自组 织网的未来将会很快到来。希望本文能给各位读者提供有用的信息，月时也希望 自己的研究可以给社会的进步做一点点贡献。	舞
57
参考文献
[1]	. Spaho E, Ikeda M, Barolli L, et al. Performance Evaluation of OLSR and AODV Protocols in a VANET Crossroad Scenario[C]// IEEE, International Conference on Advanced Information NETWORKING and Applications. IEEE, 2013:577-582.
[2]	. Zheng Y Wang Y, Li Z, et al. A Mobility and Load aware OLSR routing protocol for UAV mobile ad-hoc networks[C]// International Conference on Information and Communications Technologies. 2014:1.019-1.019.
[3]	. Marimuthu M, Krishnamurthi I. Enhanced OLSR for defense against DOS attack in ad hoc networks[J], Journal of Communications & Networks, 2013, 15(1):31-37.
[4]	.郑伟明.OLSR路由协议研究及仿真[D].电子科技大学，2011.
[5]	. Anamalamudi S, Jin M. Low rate common control channel based AODV routing protocol for cognitive radio ad-hoc networks[C]// Fifth International Conference on Ubiquitous and Future Networks. 2013:625-630.
[6]	. Li J, Zhou Y, Lamont L. Communication architectures and protocols fbr networking unmanned aerial vehicles[C]// IEEE GLOBECOM Workshops. IEEE, 2013:1415-1420.
[7]	. Gupta L, Jain R, Vkszkun G. Survey of Important Issues in UAV Communication Networks[J], IEEE Communications Surveys & Tutorials, 2016, 18(2):1123-1152.
[8]	. Cai Y, Yu F R, Li J, et al. Medium Access Control fbr Unmanned Aerial Vehicle (UAV) Ad-Hoc Networks With Full-Duplex Radios and Multipacket Reception Capability [J]. IEEE Transactions on Vehicular Technology, 2013, 62(1):390-394.
[9]	. Grodi R? Rawat D B, Bajracharya C. Performance evaluation of Unmanned Aerial Vehicle ad hoc networks[C]// Southeastcon. IEEE, 2012:1-4.
[10]	. Bouachir O. Abrassart A, Garcia F? et al. A mobility model fbr UAV ad hoc network[C]// International Conference on Unmanned Aircraft Systems. IEEE, 2014:383-388.
[11]	. Gburzynski P, Kaminska B, Olesinski W. A tiny and efficient wireless ad-hoc protocol fbr low-cost sensor networks[C]// Design, Automation & Test in Europe Conference & Exhibition. IEEE, 2007:1557-1562.
[12], Liu J, Ren F, Miao L, et al. A-ADHOC: An Adaptive Real-time Distributed MAC Protocol for Vehicular Ad Hoc Networks[J]. Mobile Networks and Applications, 2011, 16(5):576-585.
[13]	. Wang Q, Liu G, Li Z, et al. An adaptive forwarding protocol for three dimensional Flying Ad Hoc Networks[C]// International Conference on Electronics Information and Emergency Communication. 2015:142-145.
[14]	. Bekmezci I, Ermis M, Kaplan S, Connected multi UAV task planning fbr Flying Ad Hoc Networks[C]// IEEE International Black Sea Conference on Communications and NETWORKING. IEEE, 2014:28-32.
[15]	. Pereira A J, Pharris PA, Oursler J N, et al. Distributed aerial Reconnaissance Ad-hoc networking protocol[C]// Military Communications Conference, 2012 - Milcom. IEEE? 2012:1-6.
[16]	. Rosati S, Kruzelecki K, Heitz G, et al. Dynamic Routing for Flying Ad Hoc
58
Networks[J]. IEEE Transactions on Vehicular Technology, 2015, 65(3): 1.
[17]	. Marconato E A. IEEE 802.1 In vs. IEEE 802.15.4: A Study on Communication QoS to Provide Safe FANETs[C]// leee/ifip International Conference on Dependable Systems and Networks Workshop. IEEE Computer Society, 2016:184-191.
[18]	. Hasan Tareque M, Shohrab Hossain M, Atiquzzaman M. On the routing in Flying Ad Hoc Networks[C]// Federated Conference on Computer Science and Information Systems. 2015:1-9.
[19]	. Jean-Aime Maxa, Mohamed-Slim Ben Mahmoud, Larrieu N. Secure Routing Protocol Design for UAV Ad Hoc Networks[J]. 2015.
[20]	. Mohammed F, Jawhar I, Mohamed N, et al. Towards Trusted and Efficient UAV-Based Communication©" IEEE, International Conference on Big Data Security on Cloud. IEEE, 2016:388-393.
[21]	. Oubbati O S, Lakas A, Lagraa N, et al. An Intersection UAV-Assisted VANET Routing Protocol [C]// IEEE Wireless Communications and NETWORKING Conference. IEEE, 2016.
[22]	.郑艺.无人机自组织网络路由算法研究[D].电子科技大学,2014.
[23]	. El-Bazzal, Z, El-Ahmadieh? K, Merhi, Z, et al. A cross layered routing protocol for ad hoc networks[C]// Information Technology and e-Services (ICITeS), 2012 International Conference on. IEEE, 2012:1-6,	噂
[24]	. Mucchi L? Chisci L, Giovannetti G, et al. Robust cross-layer routing protocol for Mobile Ad hoc NETworks[C]// IEEE, International Symposium on Personal, Indoor and Mobile Radio Communications. 2012:278-284.
[25]	. Weng C C, Chen C W, Chen P Y, et al. Design of an energy-efficient cross-layer protocol for mobile ad hoc networks[J]. let Communications, 2013, 7(3):217-228.
[26]	. Quang K N, Nguyen V D, Nguyen T D. Optimized MAC and network cross layer protocol for OFDMA based ad-hoc networks [J]. 2013:718-723,	海
[27]	. Hoang Q T, Xuan N T. Improved cross-layer cooperative MAC protocol for wireless ad hoc networks[C]// Asia-Pacific Signal and Information Processing Association, 2014 Summit and Conference. IEEE, 2014:1-7.
[28]	. Gawas M A, Gudino L J, Anupama K R. Cross Layer Best effort QoS aware routing protocol for Ad Hoc Network[C]// International Conference on Advances in Computing, Communications and Informatics. 2015:999-1005.
[30]	. Tsuboi T, Ito T, Hitsu C, et al. Proposed multi-channel Ad-hoc network with crosslayer design of MAC and routing protocols[C]// IEEE, 2015:1-3.
[31]	. Alshbatat A I, Dong L. Cross layer design for mobile Ad-Hoc Unmanned Aerial Vehicle communication networks[C]// International Conference on Networking, Sensing and Control. IEEE, 2010:331-336.
[32]	.谢科，黄成兵.基于无线自组网的跨层设计研究[J].科技视界，2013(2):30-31.
[33]	.张永忠，冯穗力.无线mesh网的跨层设计及其应用[J].电讯技术，2016, 56(5):517-524.
[34],黄晓斌.移动自组网跨层设计的路由/MAC协议[D].中国科学技术大学, 2011.
[35].韩培韬.移动自组网中的跨层路由算法设计[D].哈尔滨工业大学,2009.
59
[36],李政，李德英.无线自组织网络中能量有效的广播与组播[J].软件学报, 2010,21(8):2023-2036.
[37],张秀娟，禹继国.无线网络拓扑控制中支撑图构造算法[J]软件学报,2015, 26(4):904-926.
[38],刘昕.军用无人机自组网技术研究[D].南京理工大学,2014.
[39],卓琨，张衡阳，郑博，等.无人机自组网研究进展综述[J].电信科学，2015, 31(4):128-138.
[40]	.王东，张广政，穆武第.多无人机协同作战通信自组网技术[J].飞航导弹, 2012(1):59-63.
[41]	.王世锋.基于AODV协议的Ad Hoc网络路由安全设计与实现研究[D].国 防科学技术大学,2009.
[42]	. Riley G F, Henderson T R. The ns-3 Network Simulator [J]. Modeling & Tools for Network Simulation, 2010:15-34.
60
