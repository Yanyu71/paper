第一章.绪论
1.1背景及问题提出
恶意程序是指在未经授权的情况下，为达到不正当目的而自动在系统中执行 的程序。恶意程序一般可以分为木马、僵尸程序、蠕虫、病毒以及其他共五类。 2013年，国家互联网应急中心(CNCERT/CC)共接收境内外报告的网络安荃事件 达31655起，与2012年相比增长65.5%o其中，境外报告的网络安全事件则为971 起，与2012年相比下降了 19.1%0接收的网络安全事件中，排名前三位的分别是 漏洞(34.5%)、网页仿冒(33.4%)和网页篡改(14.4%)o另外，2013年。^£貝17(3。 共成功处理各类网络安全事件31180件，同2012年18805件相比大幅增长65.8%。 其中，漏洞事件(34.9%)、网页仿冒事件(32.7%)、网页篡改类事件(14.6%)等处理 较多⑴。下图所示为2003年到2013年捕获的恶意成熟数量走势图：
单位(个)
80000(X)0
7W)0CX)()
6(X)00000
50000000
40000W0
300(X0)0
10000(X)0
0
从上图可以看出从2008年开始恶意程序呈爆发式增长。当前市面上鲜有共享 开放的恶意代码库，各大病毒软件厂商鲜有公开自己的恶意代码特征库。由此可 见，传统的创建过程会比较依赖经验，手工检测也是其中的重要组成部分，这导 致恶意代码特征库的创建过程较为缓慢，创建周期很长。目前传统的静态分析有 两种：一种是对可执行文件进行反汇编、反编译，然后提取出公用二进制代码构 成恶意代码特征库；另一种是对源代码中的字符串逐个进行匹配从而提取出公用 串并最终构成恶意代码特征库。然而恶意代码一般是以可执行文件的形式发现并
进行传播的，仅从这点来看，静态分析中的第二种方法具有极大的局限性，并不 适用于实际情况。另外，调换汇编指令的顺序依然可以执行原来的功能。所以， 静态分析的第一种方法适用范围也大幅受限，攻击者仅需更改指令序列的顺序即 可轻易躲过恶意特征库的匹配，实施攻击破坏行为。鉴于上述分析与静态分析的 局限性，本课题试图通过引入流程图来弥补以往创建恶意代码特征库的不足。
只有准确分析正常行为才能检测恶意程序，目前对于可执行文件正常行为的 分析主要有两种方法：一是通过训练集来学习，二是使用静态分析方法。训练集 学习的方法又存在以下方面的问题：训练集的样本数目必须足够大，否则无法获 取整体的特征。但是训练集数据的收集工作是相当困难的，所以只能通过降低检 测标准来达到目标，很大程度上影响了检测的准确性。静态分析方法主要是在不 运行程序样本的前提下，通过对样本代码进行分析获取程序行为，静态分析方法 的主要代表有控制流模型(Control Flow Graph)和抽象栈模型(Abstract Stack),这 两个模型主要在分析样本程序的源代码的基础上，通过建立有限自动机来定义样 本程序的行为。以上两种方法存在以下几方面的问题：
(1)分析过程需要样本的源程序，适用性很差；
(2)依赖指令地址定位模型，未能解决动态链接库等问题；
(3)由于采用了非确定性有限自动机，所以分析效率低。
相应的，其结果也分以下几种情况：序列包含于恶意系统调用序列集的直接 定性为恶意文件；完全包含于正常序列集中的则为正常文件；具有正常序列集以 往的，且不在恶意序列集中的为未知文件，需要动态检测等其他方式进行检测。 紧随当前恶意代码检测技术的发展浪潮，针对当前的恶意代码呈现多样化，恶意 攻击严重化，更新换代周期短，特别是对刻意制造冗余恶意分支等问题，本题基 于静态分析理论，结合当前比较流行的系统调用流程图方法，依托国家互联网应 急中心的资源优势，提出了针对Windows可执行文件的恶意代码的测试特征库的 创建方法，能在一定程度上弥补传统静态分析的不足，较为快速高效的生成恶意 代码特征库，紧随当前恶意代码快速发展的形势，满足高时效性的需求，具有一 定的参考价值。传统的手工测试很难找出上述问题的解决方法，而通过静态测试 则能较好地处理这些问题。静态检测的方法通过获取恶意代码的执行流程得出用 于检测该恶意代码的静态特征。但这些系统仍存在诸多不足：
*
一是分类慢，传统的基于字节流的扫描检测方法无法及时处理反病毒公司日 常面临的海量新增样本。许多恶意程序在发布初期感染速度极快，但伴随反病毒 公司提取出恶意程序的签名(signature),相应的恶意程序感染速度便迅速降低， 破坏性也大幅下降。因此，为了避开各种反病毒扫描引擎的检测，恶意程序设计 者会采用诸如重定位、加密、程序演化等技术使同一种恶意程序以千差万别的姿
2 态出现在传播过程中，恶意程序也呈现多样化发展的态势，这些都将直接或间接 导致反病毒软件的高漏报率。以往单独使用一种技术的检测方法越来越无法满足 检测标准。为保证检测结果准确有效，需要全方位地对恶意程序进行分析，所以 在静态分析之后还需要对恶意样本进行动态分析。动态分析就是通过在设限环境 下运行样本，监测其运行行为来获取程序的行为特征，这些行为一般包含进程操 作、注册表操作、文件操作、网络操作等。动态分析相比于静态分析较为直观， 但是也存在诸多问题，例如完整记录一个恶意程序的全部行为需要消耗大量的程 序运行时间。如何应对海量增加的恶意程序，不仅对静态分析是一项挑战，对动 态分析同样也是棘手问题。
二是扩展性差，由于反病毒软件对训练集中的样本进行分析，其分析结果受 限于训练集样本，未经训练的类别无法被识别。对于反恶意程序软件公司收集到 的大量恶意程序样本，不同的反恶意程序软件给出的分析结果各有不同，命名规 则也没有统一的标准，即使名称相同也不一定是同一个家族的样本。使用少量反 恶意程序软件对恶意程序进行分析，其实际效果往往不尽人意。通过人工手段对 收集到的海量恶意程序逐一归类分析的可行性更差。
三是准确率低，由于反恶意软件使用的传统检测方法提取出的特征难以覆盖 样本的完整行为，或者所釆用的检测方法本身具有一定的局限性。在恶意代码检 测中，特征的选取对检测的准确性往往具有决定性的影响，所以特征的选取在恶 意代码的分析过程中具有极高的权重。在特征提取过程中，抽象层次越高，越能 过滤无关细节，屏蔽样本间细节上的差异，因而越能反映出恶意家族的本质行为 特征，检测效果越好，但是相应的，特征的提取过程也越趋复杂。在实际检测过 程中，需要对样本的多个特征间进行权衡，从中选取出最具代表性的特征，应用 相关技术对恶意程序进行检测。据统计，新增恶意代码中的大部分是在己知恶意 代码基础上经过异构变换等处理生成的。为了避免被反病毒软件识别，恶意代码 制造者在原代码基础上进行一系列的修改变换。所以，这些新生成的恶意代码与 已知恶意代码之间存在交集，并且这些新生成的恶意代码之间也存在很多共性。 若能精确有效地提取这些公共特征，那么反痼毒软件将能更好的处理大量新生的 恶意代码。

图1-2 2007-2013年捕获恶意程序样本数目走势图

图1-2所示为从2007年到2013年间捕获的恶意样本数目的走势图。从图中可 以看到，虽然有大量增长的恶意程序，但是新增恶意程序的比例却较低。由此可 知，新增的大量恶意程序中主要是已知恶意家族的变种。如何应对恶意程序的这 一趋势称为反病毒厂商关注的重点，这也是本文的背景。本文在此背景下将提出 应对方案。
紧随当前恶意代码检测技术的发展浪潮，针对当前的恶意代码呈现多样化， 恶意攻击严重化，更新换代周期短等问题，特别是对刻意制造冗余恶意分支等情 况；在当前新增恶意程序呈井喷式增长的背景下，在可控时间内达到较高检测率 的要求下本文旨在设计出一套具有参考价值的检测系统。为此，本题基于静态分 析理论，结合当前比较流行的流程图方法，依托国家互联网应急中心的资源优势， 提出了基于Windows API的恶意代码测试方法。
1.2研究现状
分析恶意代码的功能是恶意代码分析的基础，目前常规的恶意代码分析方法 分为静态分析和动态分析两种。动态分析是指在一个可控的环境内运行恶意代码, 分析恶意代码与运行环境之间交互行为的方法。该方法通过比较环境在运行样本 前后产生的变化，从多个方面给出样本的指令以及系统调用的描述来大致还原恶 意代码实际功能。动态分析实质上就是运行程序，再根据各种寄存器、变量等的 变化来描述其行为。用户可以直接对这些寄存器、变量进行观察，也可以使用一 些辅助工具。这些辅助工具一般会在样本程序中加入部分代码来实现动态监视功
4 能。常见的动态检测工具有CWSandbox⑵,Norman Sandbox⑶,Joebox囹,Anubis⑸， ThreatExpert[6]等。静态分析方法是指不运行恶意程序而是通过文件结构进行分析 的方法。一般而言，静态分析需要首先对可执行文件或源代码进行反汇编、反编 译等方法进行处理，然后再做相应的分析。和动态分析相反，静态分析不编译运 行程序，而是通过对程序源代码进行分析以发现其中的错误。静态分析一般是作 为动态分析的补充来施行的，程序的运行时间可能远超预期，如果每次分析都完 整运行整个程序的成本过高，并且由于未对其进行静态分析，程序的不可预见性 也大大提高。这些都是不利于动态分析的。在程序运行前尽可能多地发现其中的 错误就显得很有必要。事实上，任何成熟的系统中都还有很多未知错误。手工测 试需要做大量重复冗余的操作，检测效果可能也并不尽如人意，而通过静态分析 方法则发现了现存系统中的很多错误。由于有些分支条件在实际执行中极难满足, 而使用静态分析方法可以了解恶意代码在执行中极难获取的分支细节，能够提炼 出恶意代码的静态特征。1996年，Forrest等人提出了一种具有里程碑式意义的入 侵检测模型，这一模型基于系统调用⑺：N-gram模型是基于进程行为的入侵检测 技术的典型代表。由于系统调用在操作系统中具有重要作用，系统调用的相关属 性常用来描述进程行为，检测程序的入侵行为也常使用这些系数。受Forrest等人 工作的启发，后续出现了大量优秀成果，包括Vt-Path模型、FSA模型和Var_gram 模型等。但这些系统仍存在诸多问题，例如进程行为建模不够准确，检测率随环 境变化较大，系统实时性较差等，这些问题仍有待完善。
另外，词法分析技术和二进制比对技术是静态检测中常用的两种专门针对软 件代码审查的检测技术。这类针对代码审查的检测技术普遍具有简单高效的特点, 但是只针对代码本身特征的检测并不能很好的检测出代码语义层级的缺陷，虽然 可以对其中引入模式识别来加强检查特征的匹配类型，但这只能略微突岀其检测 的特征，实际检测效果的提升并不明显；下面介绍的几种检测方法一定程度的客 服了上述两种方法的缺点。规则检查(Rule Check)对于已知类型的漏洞具有极高 的检测率，并且对于已知类型的漏洞检测效率颇高，但规则检测对未知类型的漏 洞就无能为力了。类型推导(Type Inference)的自动化程度较高，是一种专门针对 编程语言的检测技术，但这种检查只对与控制流无关的漏洞具有较高的检测率。 模型检测(Model Detection)主要检测涉及时序的漏洞，是一种比较成熟的形式化 检测方法，但这种检测方法的资源开销较大，并且对内存相关漏洞类型的支持度 不高。定理证明(Theorem Proving)与符号执行(Symbolic Execution)则使用严格的 数学推理来进行检测，这两种方法偏重于理论证明，目前还没有与能够实际应用 的算法。静态分析在实际使用时非常复杂，而且也可能得不到精确的数字。为了 找出能够显著降低生成过程合同信息的填充测试代码，静态分析有时会得出某种
语义，而这种语义对于代码本身是不相关的。目前优化合同分析的步骤大致如下： 首先，检测程序创建一个特殊的初始配置并启用基于此配置的静态检查，定期地 获取反馈并利用这一反馈进行基本分析。这一步骤完成之后，检测程序将转移到 无需处理额外负担的静态分析的解决方案。然后，检测程序可以尝试使用合同规 约对代码进行逐段的处理并进行深层分析。
1.3系统预期效果
本文提出了针对可执行文件静态分析的检测模型，并对这种模型中使用的关 键技术进行了研究讨论与综合分析。构造模型的基本思想是将输入的可执行文件 进行反汇编得出汇编指令序列，然后提取出其中所有的系统调用归纳出此样本的 系统调用集合，再将此样本的系统调用同数据库中的家族签名进行比对分析。具 体分析过程大概如下，首先对可执行文件进行反汇编，然后从函数的入口地址开 始顺序扫描可执行代码，之后通过RET、JMP、JXX（除JMP外的其他跳转指令） •和CALL四种类型的指令建立函数整体的执行流程图。在建立流程图的时候，通 过适当过滤一些分支进行一定的简化与处理，从而得到比较直观地流程图，方便 比对等操作。由于理解应用程序的语义是非常复杂的，为了高效地分析程序，此 处只关注系统调用函数而忽略其他调用操作。为了分析应用程序的系统调用的偏 序关系，需要以应用程序各个函数的系统调用图为基础构建样本程序的流程图， 为了过滤冗余信息，提取样本的本质特征，并且方便后续处理，此过程之后会对 所有的系统调用进行一步映射操作，即将系统调用函数分解为一个二元组，此二 元组中的一元表示系统调用中影响的资源，即类型元，另外一元表示此系统调用 的具体操作，即操作元。不同于单纯的文法分析，本课题借助动态分析的思想， 引入了系统调用流程图。相对于传统的文法分析，提升了恶意代码静态检测的精 确度，对部分Windows系统的可执行文件恶意代码测试特征库的生成提出了较 为完整的解决方案并预期获得以下成果：
1.获得恶意家族特征并构建对应的特征库。	一
2.实现特征矩阵相似性比对算法。
3.实现基于Windows API的恶意代码检测系统。
在实际使用中把未知的可执行文件作为输入进行检测，通过对输入文件进行 预处理然后与训练生成的签名进行匹配得出测试结果。通过整合处理这些序列生 成误报率较低、漏报率较低的恶意代码测试特征库，为恶意代码检测提出快捷简 便的特征库生成方案。本题预期发表论文一篇，创建恶意代码测试特征库一个并 实现基于Windows API的恶意代码检测系统，生成测试报告。
1.4论文主要内容
全文共分六个部分：
第一章绪论，介绍该课题设计的相关背景，研究的意义以及国内外的研究 现状，并根据以上问题提出当前存在的问题，根据问题，选择对应的技术，并进 行相关技术的说明。
第二章相关知识概述，对恶意代码使用的技术以及反恶意软件使用的技术 做了深入阐述。
第三章特征选择与特征库的构建，本章介绍该课题如何选择特征以及如何 构建特征库。
第四章 基于Windows API的恶意代码检测系统的设计与实现，本章介绍该 课题的设计原则。包括系统设计和功能结构设计。
第五章系统测试与结果分析，对检测系统的准确性进行度量，并对实验结 果进行分析。
第六章总结与展望。总结论文的完成情况，以及个人在论文编纂中的心得 体会，并对基于Windows API的恶意代码检测系统的待改进之处进行了说明，并 讨论了下一步的工作重点。
第二章.相关技术
当前恶意代码的数量急剧增长，传统的恶意代码手工分析方式已经难于应付 无时不在更新变化的大量增长的恶意代码，自动分析技术因为其在处理海量数据 上的优势而逐渐成为恶意代码分析的研究热点。相应的，恶意代码也逐渐发展出 大量方法来应对反恶意技术。恶意代码伪装技术就是在这种背景下出现和不断发 展的，恶意程序通过不断更新换代来绕开反病毒软性的识别。在此消彼长的过程 中恶意代码技术与反恶意代码技术共同发展。本章将分别从正反两个角度对恶意 代码的相关技术进行介绍，重点对恶意代码伪装技术和主流的恶意代码分析技术 进行深入探讨，并对图相似性对比的相关知识进行介绍。
2.1恶意代码伪装技术
随着反恶意代码的技术不断发展，为了避免反病毒软件的检测和逆向分析， 恶意代码的相关技术也在不断更新，恶意代码伪装技术主要包括反跟踪技术、加 密技术、加壳技术、模糊变换技术和自动生产技术5种同，下面将依次对这些技 术进行介绍。
2.1.1反跟踪技术
反跟踪技术是恶意代码大量釆用的技术。反跟踪技术能够提升恶意代码的伪 装能力并能大幅提高其被破译的难度，同时增加检测与清除恶意代码的成本。以 Debug为例，它是较常见的调试器，Debug调试器在跟踪程序和逐条运行程序时 使用了断点中断和单步中断。其他跟踪调试软件也主要通过这两个中断来调试程 序。所以只要能够在程序中破坏这两种中断，类似Debug的调试器将无法跟踪调 试这个程序，破坏程序中的断点中断和单步中断就是反跟踪技术的两种具体实现。 目前常用的反跟踪技术又分为反动态跟踪技术和反静态分析技术两类。
2.1.1.1反动态跟踪技术
反动态跟踪技术主要涵盖四方面的内容，它们分别是破坏调试工具运行所需 环境、禁止跟踪中断、检测跟踪法和其他技术，下面将分别进行介绍：
1.破坏各种调试工具运行时所需的环境。这种方法反跟踪较为彻底，也可以 通过锁定键盘输入和屏幕显示来防止程序被跟踪。
2.禁止跟踪中断。由于调试分析工具通过断点中断和单步中断来进行跟踪调 试，所以只需要破坏中断就能达到反跟踪的目的。禁止跟踪中断一般是通过修改
8
中断的入口地址来破坏中断的。
3.检测跟踪法。这种方法也是破坏了中断来避免被跟踪的。运行状态下的程 序和调试执行下的程序在中断的入口地址以及环境变量等方面存在差异,利用这 些差异可以釆取相应的措施使得程序难以被跟踪，从而达到保护程序的目的。检 测跟踪法又能分为以下三种：
a.中断检测法。通过检査程序的断点中断和单步中断的入口地址相同与 否可以判断当前程序是否被跟踪，这是因为若一个执行程序未被跟踪，那么 盛不程序的断点中断和单步中断的入口地址相同，反之不同。
b.定时检测法。定时检测法就是每隔固定时间检测程序的运行状况。由 于正常执行和被跟踪执行时，程序的执行时间以及系统的环境变量是不同的, 所以通过检测程序运行状况即可判断程序是否使用了检测跟踪法。
c.破坏中断向量表。Dos提供了从00H到FFH的256个中断调用。这些中 断调用驻留在内存的低地址中，每个中断的入口地址，即中断向量表是由4 个字节组成的。跟踪调试软件中广泛使用了中断调用。所以，破坏中断向量 表就是破坏了跟踪调试软件的运行环境。
4,其它反跟踪技术，如逆指令流法、指令流队列法等。
2.1.1.2反静态分析技术
反静态分析技术主要包括两方面内容：
1.对程序代码分块加密。将程序代码以分块的密文形式装入内存，以此来 防止程序代码通过反汇编等方式进行静态分析，而在程序执行时则由解密程序对 密文进行解码，一旦解码的代码执行完毕立即将其删除，这就使分析者无法在某 一时刻获得程序的完整代码。
2.Junk Code。JunkCode是指在指令中插入无用指令，静态反汇编工具由于 无法得到正常的程序指令而不能得到准确的恶意程序特征码，这将使传统的基于 字节流进行匹配的静态分析方法无法正常检测。例如“1527”是一种Win32平台 下变形处理的病毒，编译器每次编译都能生成大量的无用代码，即达到了变形的 效果，实现了反跟踪的目的。下图中左边是“1527”病毒的汇编指令以及提取出 的签名，右边是插入JunkCode的汇编指令以及提取出的新签名。


图2-1 JunkCode处理前后“1527"病毒代码对比与提取的签名对比
2.1.2加密技术
使用加密技术是恶意代码伪装技术的一种重要手段，加密技术能够同多种其 他技术混合使用。经过加密处理的恶意代码的可读性急剧下降，甚至无法正常编 译，这又导致其特征码难于提取。按加密对象的不同可以将加密技术划分为代码 加密、数据加密和信息加密三种。主流加密技术的对象是恶意代码对程序体本身， 此外还有极少数恶意代码对被感染的文件进行加密。
2.1.3加壳技术
壳(shell)是指在一些计算机软件里专门负责保护软件不被非法修改或反编译 的程序。壳一般都是先于程序运行的，它首先获得程序的控制权，然后完成它们 保护软件的任务。加壳技术和加密技术密不可分，在加壳技术出现初期，由于当 时的加密技术也才起步，所以大多数经过加壳软件和(或)加密软件处理所生成的 程序在原始程序与壳之间存在一条明显的分界线。随着软件加密技术与加壳技术 的发展，越来越多的加壳程序能使加壳的恶意程序不被跟踪和反编译，如ASPack、 PECompact, DBPE、MESS、HACKSTOP> UPX等。加壳技术是利用一些特殊 算法，对可执行文件(exe)或动态链接库文件(dll)里的资源进行压缩处理。经过加
10
壳处理的程序虽然可以直接运行，但是直接对加壳后的程序进行反汇编是无法得 到汇编指令序列的，要经过脱壳等预处理操作才可以得到汇编指令序列。加壳处 理后的程序代码在磁盘中是以加密的形式存在的，加密的代码执行时在内存中通 过解密算法还原，执行之后则会立即删除。这样就能防止程序被静态反编译，并 能有效地防止破解者对程序文件的非法修改。由于加壳后的程序难以被检测，加 壳技术被广泛应用于恶意代码隐藏和反检测保护上。下面简述软件加壳的过程:

图2-2壳的装载过程

1获取壳自身所需的API地址。通过PE工具比对加壳前后的输入表近乎无交 集，加壳后的程序API调用函数极少，有些可能只有GetProcAddress()函数或者 Kemel32.dll动态链接库。为了更好地伪装恶意程序，壳会调用GetModuleHandle。、 GetProcAddress()和LoadLibrary。等API来掩饰程序的目的。
2解密原程序中各个区块的数据。出于保护程序代码和数据的目的，加壳程 序一般会将原程序文件的各个区块加密。在程序执行时解壳程序会对这些区块数 据解密，让程序能够正常运行。壳一般是按照程序的结构进行分块的，例如一个 程序是由若干子函数(Subroutine)构成的，那么壳就以子函数为划分的最小单位将 程序进行分块，再将每块中的程序进行加密。在这种情况下每段子函数的加密过 程是独立的。
3重定位。将被加载到指定内存地址中，这个内存地址称为基地址。由于系 统每次运行程序的初始状态不同，运行环境也不同，所以每次运行恶意程序时文 件执行时的基地址一般不同。因此每次执行恶意程序代码都需要重新定位其在内 存中的基地址。
4 HOOK-APL由于系统无法保证每次运行程序都能提供完全相同的初始状 态，所以程序每次运行时都会动态生成程序的入口地址以及IAT。壳通过模拟操 作系统自动将IAT和入口地址进行赋值。完成赋值操作后壳便完成了自己的使命,
11
将控制权交还给恶意程序。
5跳转到程序原入口点(OEP)。这时候壳的任务就完成了，它会把控制权交 还给原始程序。过去加壳后的文件往往具有一条明显的“分界线”，但随着加壳 与加密技术的提高，现在的壳己经没有这条“分界线"了。
2.1.4模糊变换技术
一种恶意代码通过模糊变换技术可以衍生出无穷多的不同变种.，并且这些代 码之间的相似性并不直观，传统的基于字节序列比对的检测方法无法有效检测这 类使用模糊变换技术的恶意代码。随着模糊变换技术的发展，使用这种技术的恶 意代码迅速更新换代，传统的反病毒软件己无法应对当前的严峻形式。目前常见 的模糊变换技术主要分为以下5种：
1.指令替换技术。模糊变换引擎(Mutation Engine)对恶意代码的二进制代码 进行反汇编得出程序的汇编指令序列，然后将操作数与操作对应存储，再将指令 进行对换。例如，将寄存器1和寄存器2进行互换等。
2.指令压缩技术。指令压缩技术会改变指令的长度，通过分析指令得出与• 其同义的指令，并做压缩处理，此举可以将程序的长度缩短。
3.指令扩展技术。指令扩展技术就是把每一条汇编指令进行同义扩展，一 般而言，使用压缩技术变换的指令大都可以釆用指令扩展技术进行逆变换。扩展 技术变换的维度比指令压缩技术大得多，并且有些指令甚至可以扩展出无穷多的 异构变换。由于指令扩展技术可能会改变恶意代码的长度，所以使用指令扩展技 术的恶意代码每次运行恶意代码时都需要进行重定位。
4.重编译技术。釆用重编译技术的恶意代码中携带恶意代码的源码，每次 运行这段恶意代码前都需要进行编译，由于这类恶意代码每次运行前都会重新编 译，所以具备较好的系统兼容性。宏病毒和脚本恶意代码是典型的采用这类技术 变形的恶意代码。
5.伪指令技术。伪指令技术主要是在恶意代码程序体中插入无效指令来模 糊代码，如NOP指令。
2.1.5多态技术
多态(Polymorphism)技术是一种加密方法，它通过变换静态二进制代码而非 运行时代码来躲避基于签名的恶意代码扫描器。变换了内容的恶意代码能够躲避 扫描器的识别是因为由原始恶意代码生成的签名字节序列无法匹配现有的文件 [9]o下图展示了多态技术的典型示例，即通过多态引擎对恶意代码进行自我复制。
12
入口点

图2-3 Polymorphic处理流程

1从入口点进入。宿主机的应用程序可能会先行开始，但执行到某时刻多态 引擎将开始控制CPU。
2执行转换函数。多态引擎把在感染主机上转换后的恶意代码解码为本地操 作码，在这个过程中使用了•在感染主机的文件中的多态密钥。
3载入可执行文件。多态引擎把本地操作码写入内存用于执行。
4运行。当多态引擎完成了加密操作后就会跳到解码后的恶意代码起始处， 然后开始执行这段代码。
5执行恶意代码。恶意代码能够完成一些行为如设置病毒后门，设置一个键 盘记录器或窃取个人信息。
6生成一个新的密钥。对于多态引擎生成新的变种，必须首先生成一个新的 密钥，然后存储新变种的版本信息。
7执行逆分发函数。这个逆向过程函数把可执行文件转换为变异的代码。但 是一些信息必须被清楚地记录在类似多态引擎跳转变换函数。
每次执行代码的时候，多态技术会使用不同的密钥来对自身代码进行变异然 后写入到被感染主机中，这导致每次新的拷贝都会生成新的签名。当多态引擎把 恶意代码进行解码并载入到内存中运行时，操作码对于每个实例都是有相同语义 的，即多态引擎不会显著地改变内存中运行的操作码。所以当恶意代码在运行的 时候使用签名检测方法是可行的。另一种检测效果良好的方法是使用神经模式识 别。
13
2.1.6变形技术
每当运行变形技术(Metamorphism)处理的恶意代码时，它将改变装入内存的操 作码并且写入新版本的恶意代码到宿主机。恶意代码依然保持具有恶意行为，但 是其字节序列却与在内存中的原始操作码不同。所以常规的基于签名的方法需要 用百万个签名来扫描恶意代码。变形技术根据是否使用交互通道可以分为开放型 和闭合型两种。
1.开放型变形技术。开放型可以和网站进行交互并自动下载更新。2008年 Con^cker蠕虫迅速蔓延，被感染的主机大都使用了开放式交互，即微软的RPC漏 洞。Conficker利用50000个域和500个URL建立了一套完整的指挥和控制结构卩°】。
2,闭合型变形技术。闭合型并不依赖外部的交互来进行变异。在变化过程 中，可执行文件自行变异它自身或使用伪码来展示新变异生成的恶意代码。在32 位系统下的Apparition就是第一个使用闭合型变形技术的病毒。
一旦感染宿主机，恶意代码制造者就能利用多种策略来对恶意代码进行变形, 包括给每个访问过恶意网站的访客一个不同的模糊处理的病毒或变异的病毒。通 过感染主机传播的恶意软件必须支持自发变异来躲避检测。然而，开放型恶意软 件能够根据一些新特征自动进行更新，例如新代码支持变异，并且每次运行都能 够生成新版本。这也常被称作动态代码模糊。变形技术与其他恶意代码伪装技术 相比更为复杂，其执行可以分为下述五步：
首先，用反汇编器解析操作码。Windows是~*个IA-32(Intel Architecture,32 位)的处理器。也就是说它有丰富的指令集，并且许多操作码结合大量的操作数 和操作，可以执行完全相同的任务。另外，IA-32支持变长和扩展的操作码，导 致打包和解码操作码与操作数变得异常复杂；然后，为防止代码的持续增长，用 一个压缩程序压缩反汇编的代码。剩下未被压缩的代码将会成因太占空间而被剔 除出去；第三，置换程序会把原始指令以随机的顺序重新排布，并以jmp操作码 来进行连接，寄存器和操作码也被替换；第四，用扩展程序将原始操作码指令进 行重新编码，例如加入良性操作码nop。每次运行变形程序都会执行这一步，由 此生成新的恶意代码；最后，汇编程序会重新编码恶意代码，计算新加入的jmp 和call指令，并且重新计算jmp和call指令的地址。对于一段伪码，汇编程序会将 上述内容反汇编到目标操作码中。’
14


图2-4变形前后的库函数操作码对比

图2.4所示为kemel32动态链接库中的GetModuleHandle()函数，其中左边的为 原始代码，右边的为变形转化的代码，从图中可见，变形前后操作码的差异极大， 使用基于签名的扫描器进行检测难以应对变形处理的恶意代码，对于这种恶意代 码伪装技术，有必要引入新的检测方法。本文提出的检测方法即是在这种背景下 产生的，对于变形化的代码具有较好的检测效果。
2.2恶意代码分析技术
恶意代码分析的主要目的是通过对恶意代码进行分析提取出其特征，为下一 步的恶意代码检测和匹配提供依据。当前恶意代码分析主要分为两种：静态分析 和动态分析。反病毒软件经历了四个阶段，遇到的恶意代码伪装技术越发复杂， 检测难度也越发增加。下图所示为恶意代码分析的各个阶段图：
15


反病毒软件经历了四个阶段。图2.4所示的(a)阶段为系统通过各种渠道被感 染；(b)阶段中基于签名的扫描器遇到了恶意软件打包的问题；(c)阶段中静态 分析遇到了多态(Polymorphism)恶意软件；(d)阶段中动态分析遇到了变形 (Metamorphic)恶意软件図。
2.2.1静态分析技术
静态分析并不运行恶意代码，而是通过对文件进行反编译、反汇编等静态手 段来对恶意代码进行分析。通过静态分析可以提取出恶意代码的控制流图，进而 能够提取用于检测和查杀恶意代码的特征代码段或特征字符串。根据提取的特征 类型，静态分析技术又可分为两种：
1.特征码提取技术
恶意代码的特征码是指某个恶意代码所具有的区别于非恶意(benign)程序以 及其他恶意代码的数据或指令序列。特征码提取技术的输入集主要来自大量数据 的统计结果。特征码提取技术一般应用于精确匹配，如果恶專代码经过异构转换 特征码提取技术便失去作用。多态(Polymorphic)和变形(Metamorphic)技术是当前 恶意代码中常用的模糊技术，恶意代码经过多态或变形处理能产生海量异构代码, 因此特征码提取技术的实用性较差。
2.程序结构特征提取技术
特征提取技术的基本思想是对恶意代码进行反汇编能够对恶意代码的内部
16

结构与流程进行深入分析，提取出程序的流程图，并在此基础上进一步分析提取 出唯一标识恶意代码作为程序的特征码。本文即采用了这种方法。首先使用反汇 编工具IDA Pro对恶意代码进行反汇编，然后提取出恶意代码的控制流图(CFG), 再进行后续分析步骤。白莉莉等人提出一种基于关键应用编程接口图的恶意程序 检测方法卩七这种方法的流程是，首先对程序进行反汇编并提取出程序的控制流 图，在此基础上提取API构建恶意程序检测模型进行检测。使用反汇编或反编译 的方法能够将程序所有可能的路径都提取出来，能够较为全面的分析恶意代码， 但是使用这些方法的前提是程序本身同内存中运行时是一致的，对于未脱壳的程 序还需要先进行脱壳处理。下图所示为Netsky恶意家族的一个变种的控制流图：



图2-6所示为通过IDA Pro生成的控制流图，其中蓝色的方块表示库函数，黑 色的方块表示中断，绿色方块表示程序的入口点。由图可见，一段程序的CFG图 可能异常复杂，在分析的时候直接分析其调用的库函数可能及其困难，所以本文 讨论的检测方法屏蔽了这些复杂的细节，对这些调用的库函数做了一次预处理， 得到屏蔽大量冗余信息的二元组，方便后续分析。
2.2.2动态分析技术
动态分析通常在一个隔离的、可控的环境中运行恶意代码，在运行的过程中 通过监视程序寄存器、内存状态来分析恶意代码对操作系统所引发的行为活动， 相比于静态分析，动态分析并不关注程序代码本身，通过运行分析代码的恶意行 为，非常直观有效的获取程序的行为特征。由于动态分析不关注程序代码本身， 这种分析技术能有效地应对采用了加壳、多态和变形技术进行伪装的恶意代码。 动态分析技术的适用范围较广。按照在时间上使用策略的不同，动态分析技术可 分为动态追踪法和状态对比法〔⑵。
1.状态对比法。恶意代码在运行前后会对系统造成一定的影响，状态对比
17
法就是在这个基础上进行讨论的。该方法只考虑恶意代码的运行始末两个点系统 环境的变化，忽略了其运行过程这条线中系统环境动态连续的改变。因此，状态 对比法不能完整全面的反映恶意代码运行过程中任意时间片系统状态的变化情 况，所得到的分析结果非常片面，无法准确全面地反映恶意代码的真实行为。虽 然状态对比法所得到的恶意代码行为特征的信息量有限，但是这种方法在实现上 比较简单，易于实现。
2.动态追踪法。和状态对比法不同，动态追踪法在恶意代码的执行过程中 进行全程监视。与状态对比法相比，这种方法可以完整记录恶意代码执行过程中 任意时刻系统环境变量与状态的变化，能够准确完整地反映恶意代码的行为特征。 相应的，动态追踪法的实现难度较大。按采用行为监测技术的不同，动态追踪法 分为基于用户态的监测技术、基于内核态的监测技术和基于指令集模拟器的检测 技术三种，下面将依次介绍：
(1)基于用户态的监测技术。基于用户态的监测技术是指利用系统提供的编 程接口进行钩挂，切入检测程序，然后通过监测恶意代码执行过程中的系统API 调用及其输入输出来提取恶意代码的行为。基于用户态的检测技术容易实现，但 该技术的不足之处在于无法分析和截取直接请求系统内核服务调用的行为。基于 该技术实现的恶意代码自动分析工具有：Norman Sandbox、CWSandBox和Joebox 等。Norman Sandbox和CWSandBox是运行于虚拟操作系统环境中的沙箱工具， 因为这两种沙箱工具使用系统快照(Snapshots),能够很快恢复系统的初始状态， 分析中将运行过程分片进行监测，将时间片划分为较小粒度即能近似获得系统任 意时刻的系统环境变化。然而虚拟机技术较易被恶意代码识别。与前两种沙箱不 同，Joebox使用真实操作系统环境对恶意代码进行动态分析，整个分析过程并未 使用仿真模拟，Joebox最明显的优势是它能够有效处理具备仿真识别功能的恶意 代码，相应的，这种沙箱技术恢复初始状态较为复杂，恢复时间长。
(2)基于内核态的监测技术。与基于用户态的监测技术相对，基于内核态的 监测技术是基于内核态的API Hooking来对恶意代码的行为进行监测的一种技术。 基于内核态的监测技术主要通过修改内核的系统服务分发表SSDT(System Service Dispatch Table)中系统服务函数的地址来实现对恶意程序的检测功能。另 夕卜，用户态函数与内核态函数一般是多对一的关系，基于用户态监测技术的挂钩 多并且分布较为混乱，而实现同样功能的内核态监测技术则使用少而集中的挂钩。 基于内核态的监测技术工作于操作系统内核态，监测能力强，但是实现难度较大， 使用基于内核态监测技术的自动化分析工具有MwDAS和Capture等。
(3)基于指令集模拟器的监测技术。指令集模拟器(Instruction Set Simulator, 简称ISS)是在主机上模拟被侵入的主机的指令集来对恶意程序的侵入过程进行
18
仿真。按实现方法进行划分，基于指令集的模拟器可分为解释型和编译型指令集 模拟器两种。解释型模拟器由于是对每条程序指令解释执行的，所以其性能相对 于编译型模拟器低。基于指令集模拟器实现的主流恶意代码分析工具有 TTAnalyze、Zero Wine、Panorama等。
2.3 Windows API 概述
Windows API(Application Programming Interface,简称 WinAPI)是微软对于 Windows操作系统中可用的核心应用程序编程接口的称法，包括函数、结构、消 息、宏及接口等。Windows API能被各种语言调用，也是应用程序与Windows 系统最常使用的交互方式。Native API可以为大多数驱动程序提供更低层次的访 问接口，具体映射关系情况因版本而异。为方便程序员开发使用Windows API 的软件，微软专门为程序员开发了一套软件开发包(Software Development Kit,简 -称SDK)',并提供了相应的文档和其他软件卩3］。在实际开发时，由于不同版本 的系统提供的Windows API存在差异，而程序中经常会使用这些Windows APL 所以程序的开发依赖底层平台。
近年来，由于不断更新补丁、替换版本，Windows操作系统越发强大，相应 的，Windows API也随之改变。一方面Windows API的数目增加了，另一方面 Windows API也进行了一些扩展，比如1.0版本的Windows API只提供了不到 450个函数调用(Subroutine),而现在的版本则提供了数千个函数调用。不过总体 而言，Windows API还是保持了较好的一致性，兼容性较好。Windows API按功 能可以分为七类tl4］：
1.基础服务(Base Services)。可用的基础资源访问接口即是由基础服务提供 的，这些基础资源包括文件系统(file system)>外部设备(device)、错误处理机制 (error handling mechanism)> 进程(process)、线程(thread)以及访问注册表(registry) 等。这些功能接口在可执行文件和动态链接库中大量分布，例如在16位Windows 系统下(winl6),基础服务 API 存在于 kemel.exe、kml286.exe 和 kml386.exe 系统 文档中。而在32位Windows系统(Win32)下则存在于kemel32.dll和advapi32.dll 中。
2.图形设备接口(GDI),将图形内容输出到外设上的功能就是由图形设备接 口进行定义的。在winl6下，图形设备接口存在于gdi.exe。而在Win32下，图 形设备接口存在于gdi32.dll中。
3.图形化用户界面(GUI),系统中大部分基本控件的各项操作都是由图形化 界面接口进行定义的。这些控件包括屏幕、按钮和滚动条等，鼠标的输入信号与 键盘的输入也是交由图形化用户界面接口进行处理的。图形化用户界面接口在
19
winl6下存在于user.exe中，而在Win32下存在于user32.dll0在最近版本的 Windows系统下，图形化界面接口存在于comctl32.dll中。
4.通用对话框链接库(Common Dialog Box Library),对话框的各项操作就是 由通用对话框链接库定义的，这些操作包含打开、关闭、新建和保存等。通用对 话框链接库在winl6下存在于commdlg.dll中，而在Win32下通用对话框链接库 则存在于comdlg32.dll中。这一链接库被归类为用户接口 APL
5.通用控件锥接库(Common Control Library),操作高级控件的功能就是由 通用控件链接库定义的。这些高级控件包含工具栏、进度条、状态栏和标签等。 这个链接库在winl6下存在于commctrl.dll中，而在Win32下存在于comctl32.dll 中。通用控件链接库属于用户接口 API。
6.Windows 外壳(Windows Shell), Windows 外壳的接 口就是由 Windows 外 壳定义的。Windows外壳在winl6下存在于shell.dll中，而在Win32下存在于 shell32.dll 中(Windows 95 则在 shlwapi.dll 中)oWindows 外壳属于用户接口 .API。
7.网络服务(NetworkServices),系统中的网络功能就是由网络服务提供的。 这些功能有 NetDDE、Winsock、RPC 和 NetBIOS 等。
2.4图相似性分析概述
为了提取能够区别于非恶意(Benign)程序和其他恶意程序的特征码，需要对 恶意程序进行相似性比较，所以引入了聚类分析的概念。而聚类分析经常根据对 象间控制流图的相似性来进行分类，相似性一般有两种度量标准，它们分别是距 离函数和相似系数，下面将分别对其进行具体介绍：
2.4.1编辑距离
编辑距离(Edit Distance),是指两个不同的字符串A和B,从A(B)转换成B(A) 的最少编辑次数。其中，编辑操作包括替换字符、插入字符和删除字符三种操作 字符°T.Lee等人以编辑距离为依据，通过最近邻分类算法对恶意程序进行分类， 并构造聚类算法分类器ns】。
2.4.2归一化压缩距离
归_化压缩距离(Normalized Compression Distance,简称NCD)。P. Vitanyi等人 最早提出了归一化压缩距离的概念［峋。后来Chen Xin等人又提出了基于NCD的相 似性检测算法［切。字符串x与y之间的NCD定义为：
20

NCD(X,y) max(C(x),C(y))
公式2-1中，x+y表示字符串x和y的并集，C(x)表示使用zlib对x字符串进行 压缩的字符串长度。NCD(x,y)表示字符串x与y的相似程度。M. Bailey等人以NCD 方法作为度量方法，通过对比恶意程序运行前后系统发生的变化作为恶意程序的 特征卩司。S.Wehner等人同样使用了NCD方法来对蠕虫进行分类【"I。
2.4.3欧氏距离
欧式距离(Euclidean Distance)即是釆用相似性进行度量的一种聚类算法。 K.Rieck与P. Trinius等人以欧氏距离方法作为相似性度量标准，利用CWSandbox 工具获取恶意程序的WinAPI调用序列［2°】，在此基础上又对原始模型进行改进, 对样本进行分类和聚类。
2.4.4 Jaccard 系数
Jaccard系数(Jaccard Index)也是一种相似性的计算方法。下面使用Jaccard系数 对样本a与b进行相似性度量，那么样本a与b的Jaccard系数即可定义为：
J(a,b)=翳	公式 2-2
若J(a,b)=l则说明这两个样本具有相同的行为。
2.5相关工具
本章将就ACS系统中使用到的各种工具进行介绍。
2.5.1IDA Pro
IDA Pro(lnteractive Disassembler Professional)是目前广泛使用的静态反 汇编工具，它已经成为分析恶意代码、研究漏洞攻击的主要工具。这款软件具有 高交互、可编程、可扩展等诸多优点，支持各种处理器和平台，功能非常强大。 本文选用IDA Pro就是基于其具有上述优点。
2.5.2PEiD
PEiD(PE Identifier)是一款目前常用的查壳软件，它适用于大多数编译语言, 能够识别病毒以及加密的壳。PEiD可以他侧大多数PE文件的封包器、加密器 和编译器，并且能够探测600多种不同的签名。本文使用PEiD来对可执行文件 进行脱壳处理。
21
2.6小结
本章具体分三部分对恶意代码的相关技术做了介绍，它们分别是恶意代码伪 装技术、恶意代码检测技术以及相似性检测技术。恶意代码伪装技术部分首先从 恶意代码的起源说起，介绍恶意代码的基本畦以及各种恶意代码伪装技术的. 模型。这些内容作为本论文的基础知识，让我们更形象深刻地认识到恶意代码的 伪装原理以及不同伪装技术对应的基本结构。然后介绍恶意代码常见的分析技术 及每种技术对应的典型模型和原理。这些内容同样作为本论文的基础知识，从反 病毒的角度展示了恶意代码的各种识别技术及其对应的基本结构。前两节从正反 两个角度向我们展示了恶意代码的发展历程及应对方法，提供了充足的知识背景 另外，本章还介绍了部分聚类分析的知识，为后文做了知识储备。
22
第三章.恶意代码检测系统的设计
3.1系统设计思想
本系统基于Windows APL主要针对使用Polymorphic和Metamorphic技术模 糊竺豊的恶意家族变种，通过构建特征库来匹配未知文件进行检测。
Christodorescu和Jha等人在中通过分析一个恶意家族不同变种之间共 有的行为得出反映恶意特征的指令组成的检测恶意变种模板。他们在模糊化处理 样本中找出语义上反映恶意代码行为特征，即执行结果接近签名的代码段。 Kolbitsch和Comparetti等人在㈣中使用了行为方法来检测恶意代码。首先，他 们在模拟环境中执行样本恶意程序，然后建立由相互依赖API调用组成的，能够 反映行为特征的调用图模型，这种图也被称作行为图。在处理未知程序的时候， 他们的扫描器就来匹配反映出行为的API调用图"如果匹配一致，那么这个程序 就被视为恶意程序。作者提出这一方法不会受到API调用被乱序处理的影响，同 样的，增加空操作等无用的函数调用和类似的模糊化处理也不会影响这种方法的 检测率。
本文假设在恶意代码M中出现的API调用序列S同样出现在恶意变种M，中。 这是因为M程序经过代码模糊化处理后，在字节序列上可能与变种M，会有很大不 同，但是其语义上应该非常接近，而API调用序列正反应了这种语义上的逻辑关 系。所以经过模糊处理的代码之间在API调用上不会存在极大差异。另外，在这 大量的API调用中有很多的执行结果是相近的，所以可以进一步将Windows API 提炼为更一般的形式。匹配时需要对比两个矩阵的相似性，所以引入图相似性比 对的算法。
3.2系统功能需求
基于上述讨论，基于Windows API恶意代祖检测系统需要满足应满足以下需 求：
1、	恶意代码收集与初步分析。考虑到恶意样本可能经过加壳或加密处理， 在分析的时候极有可能出现运行异常情况，故在分析前需要对样本进行相应的脱 壳和解密操作。
2、	提取特征并构建特征知识库。对样本进行反汇编，提取出样本的Windows API调用序列作为其特征。将所得到的样本的Windows API调用信息添加到数据
23

库，在这步中对API调用信息进行了处理，将调用信息抽象化为对象和操作共同 标识的二元组，构建恶意样本特征知识库。
3、提取恶意代码的行为特征并归纳其家族的原型特征。首先，对WinAPI 进行二元组的映射，然后构建样本的二元组矩阵，随后进行迭代，归纳生成恶意 家族的特征矩阵。
3.3系统结构设计
ACS的总体设计思路是通过对可执行文件进行分析与抽象，得出相应格式的 矩阵，此矩阵能够反映此样本的行为特征，此矩阵即为对应样本的签名。然后将 此签名同签名数据库中的恶意家族签名进行对比，通过图相似性匹配算法得出与 特定恶意家族的相似性，再根据训练集中样本的相似度区间将此样本进行划分, 得出检测结果。训练集数据进行反汇编整理生成API调用矩阵，结合恶意与非恶 意文件得出能够有效识别恶意文件的API调用权值矩阵，这一矩阵就是本恶意家 族的签名(signature)o理论上，生成的签名能够有.效区分本家族变种和非恶意文 件。具体又可以分为两步，即数据预处理和图相似性比对。系统的总流程图如下



如图3-1所示，ACS系统的执行流程如下：输入可执行文件，然后进行数据 预处理得到库函数调用矩阵和权值矩阵，分别将两个矩阵同签名数据库中的恶意 家族签名进行比较，执行图相似性比对子过程，最终得到判定结果。
本系统使用的数据库为MySQL,开发语言为python,开发环境为Eclipse,辅
24
助开发工具有IDA Pro、PEiD,开发的操作系统为32位win 7系统。另外，本系统 使用的训练集的文件格式均为exe可执行文件。
3.3.1二元组的初始化与API映射
程序的库函数调用关系非常复杂，直接对其进行分析不仅繁琐，而且极易产 生新的错误，如果能够进行提炼将大幅简化后续工作，并能剔除函数的冗余信息, 从更抽象的层次获取程序行为：在此我们增加了一步处理操作以实现上述目的。 由于库函数调用名千差万别，但是本质操作可能是相似的，所以，我们把增加了 一步化简操作，即将每个Windows API分成一个二元组，其中之一是具体类型， 另一部分是执行动作。具体类型即常见的API调用资源，ACS系统只关注常见的 APE 根据MSDN, ACS将Windows API的调用资源分为32种，如memory, register, mutex等。操作动作又分为打开、关闭、读和写共4种，所以API调用即被分成128 种(32*4)。例如，malloc()函数可以转换为memory + writeo这样处理能够屏蔽 API中大量的非关键和冗余信息，提炼出语义层级的抽象含义。实践证明，这一 处理过程极大克服了一般静态检测的缺陷，检测模糊化处理的恶意文件具有较好 的适用性。具体映射表如下：
表3-1类型映射表
类型映射码	0	　1	　　　2	3	　　4
具体类型	application	　　　■ Hg	　　　、、，' ，i	driver	　　event
类型映射码	5	　6	　　　7	8	　　9
具体，.	?圣	' handle	　　　heap		　　iDsiaLu..'e
类型映射码	10	　11	　　　12	13	　　14
裝类型	job
]5	　mailslots
1 A			　　i - ：技:籍
.大生,liA.月J
「丄	mod it?.e	　　' -ex .		　　、z	　　register
类型映射斤\	20		　　　2。	23	　　24
r'egistiy	<cnirce		　　ivi.ce	　　session
类型映射码	25	　26	　　　77	28
具体类型	socket	storage	　　　thread	timer	token
类型映射例 30	31
.具体类型**	window	密"霉籌套WWS

表3-1展示了二元组的操作类型映射关系，其中操作类型依据MSDN,每个操作
类型都有一个对应的操作类型映射码，映射码的范围为0-31。
表3-2动作映射表
动作映射码 0	.	1	2	3
25
表3-2展示了二元组的动作映射关系，其中具体动作为打开、关闭、读和写，分 别对应一个映射码，依次为0、1、2、3。
表3-3常见API映射表（操作类型映射码+动作映射码）
API映射码	130	　　　132	　　132	132	　　132	　　　133
API	malloc	　　　sirchr	　　strlen	strenip	　　strstr	　　　a ton
API映射码	133	　　　133	　　•ICC	133	　　133	　　　133
htonl	　　　htons	　　memset	inemcpy	　　strcat	'寥，饗戀復警愆笠渗
strepy
AP诫射码	]3 3
API	sircat	•' ''I/*--' 'i’a ；；

表3-3展示了一些常见API的映射关系，由于在类型映射表和动作映射表中都没有 明确对应关系，因此提取出一些常见的API并列出其对应的映射码，API映射码 由具体类型码和动作类型码两部分组成，前者占两位，后者占一位，具体对应关 系如表3-3所示。
表3-4常见类型映射表
类型映射码 5	13	13	13	13	13
具体类型 ic	is	region str	mem arg

类型映射码	13	13	13	14	25	wsa
具体类整 ffjfllll___:兰―tab、." "" _亠

表3-4展示了一些常见的类型映射关系，由于在表3-1中并未出现，所以需要单独 进行设置，具体对应关系见上表。
表3-5常见动作映射表
动作映射码	00111
具体动作	alloc	start	exit	terminate	fi*ee
动作映射矶	2	2	2	3	3
具体动作	is	find	get	set	init
动作映射码 3	3	3'
具体动作create	cpy	m

表3-5展示了一些常见动作的映射关系，由于在表3-2中并未出现，所以此处对其 进行了单独的设置，具体对应关系见上表。
3.3.2特征选择与特征库的构建
特征，本文亦称之为签名，是指能从语义层级反映一段恶意代码行为特征的 一段代码。由于签名反映了恶意代码的行为特征，并且同属一个恶意家族的不同 26

变种具有相近的行为特征，所以本文基于这样的背景试图通过分析各变种的特征 归纳出恶意家族的整体特征，并按照二元组的方式进行映射处理，方便后续的比 较等操作。ACS系统的输入集合分为训练集和测试集，分别用于生成签名和进行 后续的测试。签名的生成依赖训练集，ACS系统通过对训练集的分析学习最终得 到恶意家族的签名。ACS系统使用的训练集中有Netsky恶意变种58个，这些样本 取自VX Heaven"签名的生成流程如下所示：


如图3-2所示，签名的生成步骤分为4步：首先，将exe格式的训练集样本文 件进行脱壳处理，本系统使用的脱壳工具为PEiD；然后，使用反汇编工具IDA Pro 将脱壳后的exe文件进行反汇编，得到程序的汇编指令；之后提取汇编指令中的 call指令，并将操作数进行存储，同时进行映射处理，具体映射关系见表3.1-表3.5； 再根据API调用的偏序关系构建系统调用矩阵图。其中系统调用矩阵即是二元组 映射步骤中提到的128*128的抽象化的矩阵，其中第i行j列中元素的含义是第i条 命令与第j条命令的偏序对在程序中出现的数量。将同属一个恶意家族的变种作 为输入多次迭代，即能得出相应恶意家族的签名。
27
3.3.2.1签名迭代生成算法
签名的生成过程中最后一步迭代生成恶意家族的签名，这一步迭代过程中用 到了ACS系统中重要的签名迭代算法。迭代算法的输入为多个权值矩阵，每个权 值矩阵表示一种样本的库函数调用偏序关系,ACS系统中对权值的度量是以出现 次数作为基准的，即变种k对应的权值矩阵Mk中第i行j列的元素Vij的含义是第i条 命令与第j条命令的偏序对在程序中的权重，其计算公式如下：
% = Nj /潇％ £醫林	公式3-1
公式3-1中，Nj表示在当前样本中第i条命令与第j条命令的偏序对出现的次数, 分母表示为当前样本中偏序对的总数。公式3-1中的权值为每个样本的权值。同 样的，每种恶意家族都有一个对应的权值矩阵，其中的每个元素综合体现了每个 样本相应位置的值，恶意家族权值矩阵M中第i行j列的元素Vij的含义是第i条命令 与第j条命令的偏序对的权值，其计算公式如下：
Vy „ew = Vy Q + Vi]old ( 1 - Q )	公式3-2
由于恶意家族权值矩阵是由每个样本对应位置的矩阵元素迭代计算产生的， 在公式3-2中通过new与old进行识别。另外：公式3-2中，0 = l/(n+l), 〃为当 前己处理恶意文件的数量。恶意家族权值矩阵各边权值随新增样本对应边的权值 而改变。由于本实验是建立在统计的基础上，所以误差不可避免。样本选取的差 异、匹配库的选取等环节都可能引入误差引入权值矩阵的主要目的是提升测试结 果的准确性，在相似性比对过程中做了详细的阐述。下图所示为签名迭代算法的 流程图：
28

计算矩阵各 位置的权值



图3-3迭代算法流程图

图3-3表示恶意家族签名的生成流程，先通过公式3-1分开计算同属一个家族 的每个变种的权值矩阵，然后再根据公式3-2,迭代的进行计算，最终获得整个 恶意家族的权值矩阵。此权值矩阵包含了相应恶意家族中各个变种的完整信息， 全面体现了整个家族的行为特征，故此权值矩阵即是恶意家族的签名。下面将给 出迭代算法的伪代码：
SIGNATURE-RECURSIVE-GENERATION
1for i in m line
2for j in m row
3dom[i]|j] = m[i]|j]/sum
4for each sample(k) in training set
5for m in m line
6for n in m row
7do m[m][n] = m[m][n] * — + m(k)[m][n]*—
3.3.3数据预处理
ACS系统使用的输入集分为两部分，分别为训练集和测试集，且其文件格式
29
均为exe格式。训练集用于对系统训练学习，分析恶意家族行为特征并生成恶意 家族签名，测试集用于对系统进行测试，通过误报率与漏报率来对系统使用的算 法进行验证，用以检测其进行恶意检测的准确性。数据预处理使用的样本均来自 训练集。由于样本的获取途径有限，本系统使用的Netsky样本均取自VX Heaven<> 这些样本普遍经过模糊处理，直接分析极难获取有用信息.考虑到恶意样本极有 可能经过加壳等处理，在分析的时候如果不先行进行分析，运行时存在很大可能 出现异常状况，所以在对样本进行分析前需要首先对这些样本进行相应的脱壳和 解密操作。ACS系统使用PEiD对样本进行脱壳操作。由于预处理阶段的处理流程 较为繁杂，故本系统将其单独划编一节进行讨论。数据预处理的具体流程如下图 所示：
可执行
文件
脱壳处理
/子函数
偏序图
库函数
调用集



如图3-4所示，首先对输入文件进行脱壳处理；然后将脱壳处理后的文件进 行反汇编，得到程序的汇编指令；之后取出汇编指令中的call语句，此处将分两 个分支继续进行，其中一支将call语句的操作数提取出来得到库函数调用集，并 根据另一支则提取出子函数的调用关系，得到其偏序集合；最后，将上述两个集
30
合合并起来即可获得一个能够反映时序关系的库函数调用关系，即是此变种的权 值矩阵。
本文的数据预处理阶段提出的检测方法提取了程序的语义层面的信息，一定 程度地克服了原始的静态检测方法的缺陷，与基于字节序列签名反病毒检测技术 相比具有一定的优势。本系统使用训练集对数据进行预处理，并通过训练集生成 恶意家族的签名。然后通过训练集对原始签名进行迭代增量分析，使用图相似性 比对算法将各变种的特征增加到家族签名中。最后通过测试集对本系统进行测试, 验证本文使用算法的有效性。本文使用典型恶意家族Netsky对ACS检测方法进 行评估。
3.3.4图相似性分析	'
每一个新的样本经过预处理都会生成一个此样本的权值矩阵。图的相似性比 对的目的是通过对比样本同签名数据库中的恶意家族权值矩阵的相似度来判断 此样本是否属于相应的恶意家族。图相似性比对过程又细分为以下两步：
首先，经过数据预处理，得到样本文件的权值矩阵，把这个矩阵同恶意家族 权值矩阵进行匹配,分别计算样本文件与签名库中各恶意家族签名矩阵的相似性, 此处使用样本的库函数调用矩阵。样本矩阵中的元素Wij的值为：
"=｛摄端	公式3-3
恶意家族F的库函数调用矩阵中相同位置的元素的j(F)的值为：
衙(月=備當	公式3-4
此处的相似性计算使用了 Jaccard系数，具体对应公式2,其中a与b交集的计 算公式为：
\anb\=薩鴛(Wij+啄F))/2
a与b并集的计算公式为：
|aub| =(辭眨田(Wij* 缁j(F)))/(窮:球：(Wij+%(F))) 恶意样本同每个恶意蹇族F的签名相似性SF的计算公式为：
s 」血1
F ~\aub\
SF >= 20%,则认为此样本可能具有相应的恶意特征，否则不具备这样的特征。 下面将通过伪代码的形式对相似性比较进行描述。
SIMILARITY-COMPARE
1for i inm line
2for j inmrow
3ifm[i]B]>0
4do = 1
5ifm(F)[i][j]>0
6—	dom(F)[i][j]，= l
7do mixedm[i][j]	= (m[i][j],+m(F)[i][j],)/2
8unionm[i][j] = (m[i] [j]，+m(F)[i] [j] ?)%2
9for i in m line
10for j inmrow
11do mixedSum += mixedm[i][j]
12unionSum += unionm[i][j]	.
13return mixedSum/unionSum
然后，若相似度(公共部分所占比例)大于20%,那么将计算这个样本相对于 恶意家族权值矩阵的偏移量。由于正常程序可能与恶意代码共享部分代码，所以 本系统引入了偏移量的概念。偏移量的思想体现了样本的波动性。若干大小接近 的样本在具有相同公共比例代码的前提下，若其偏移量过大，则表明此样本的波 动性较大，检测结果具有较大起伏，相应的，其检测的准确性也会较低。具体到 ACS系统中，通过计算样本权值矩阵与恶意家族权值矩阵每个对应位置元素对 应边的偏差值来计算总体的偏移量O,其计算公式如下：
o =羽驾塁聳(Vij - Vy sS 2	公式3-8
在公式3-8中，。是样本的偏移量，为是恶意家族签名矩阵中第i条命令与第j 条命令偏序的权值，Vijsample是待测样本签名矩阵中第i条命令与第j条命令的偏 序数目。我们需要统计每个恶意样本相对于恶意家族权值矩阵的偏移量，最终得 到恶意变种的置信区间(。湖，0gx)，若样本按照偏移算法得出的偏移量在这个 范围内，则说明样本可能具有恶意特征，如若不然，则说明样本的偏差过大，不 属于此恶意家族。相似性比对的流程图如下所示：
32


图3-5图相似性比对流程图

由图3-5所示，图相似性比对主要分两步执行。首先，样本的库函数调用矩 阵与恶意家族k的库函数调用矩阵进行相似性比对，若相似性小于20%则将样本 的库函数矩阵同数据库中的下一个恶意家族库函数调用矩阵进行比较，重复这一 步骤；若相似性大于20%,则计算样本的偏移量，若此偏移量落在由训练集训练 生成的置信区间，则可判定此样本属于第k个恶意家族，退出比较程序。相反， 若此偏移量落在训练集生成的置信区间之外，则继续与下一个恶意家族的库函数 调用矩阵进行对比。
3.4小结
本章是论文的核心章节，主要对ACS系统整伝进行了分析与设计，并且就 其中用到的关键算法进行了详尽阐述。下面进行具体介绍。
第一部分主要描述了系统的总体设计思想，根据需求提出了整体的设计思 路。
第二部分主要描述了系统的功能需求。ACS系统主要分为三部分：恶意代
33
码收集与初步分析、特征提取和构建特征知识库以及基于聚类算法构建恶意代码 的基准类别及其家族的原型特征。
第三部分主要描述了系统的结构设计。更具体地对第二部分进行了阐述， 这部分又分为四部分：二元组的初始化与API映射、特征选择与特征库的构建、 数据预处理和图相似性分析。在本章每个小节中都对各部分的流程进行了介绍, 并对各个功能模块中使用的算法进行了详尽描述。在特征选择与特征库的构建这 一节中对ACS系统的关键算法签名迭代算法进行了深入分析。.
34
第四章.恶意代码检测系统的实现
基于第三章的讨论，基于Windows API流程图的恶意代码检测系统需要满足 应满足以下需求：
1、	恶意代码收集与初步分析。考虑到恶意样本可能经过加壳或加密处理， 在分析的时候极有可能出现运行异常情况，故在分析前需要对样本进行相应的脱 壳和解密操作。
2、	提取特征并构建特征知识库。对样本进行反汇编，提取出样本的Windows API调用序列作为其特征。将所得到的样本的Windows API调用信息添加到数据 库，在这步中对API调用信息进行了处理，将调用信息抽象化为对象和操作共同 标识的二元组，构建恶意样本特征知识库。
3、	提取恶意代码的行为特征并归纳其家族的原型特征。首先，对Windows API进行二元组的映射，然后构建样本的二元组矩阵，随后进行迭代，归纳生成 恶意家族的特征矩阵。
所以，系统的实现将围绕这三个需求点进行具体实现，下面将分模块进行具 体介绍。基于上述需求，本文对其进行实现，ACS系统即为本文所述方案的具 体实现。ACS系统的实现语言是python,版本为2.7； ACS系统使用的数据库为 MySQL； ACS系统使用的编译器为Eclipse。下图所示为程序的目录结构：
35
愣 PyDev Package Explorer U B 籌 | 券。c
，malDetec
丄白config
甬]conf.cFg
IS description
H He"
U Files_dbw
Uj Instructioninfo
R]	obyect_operationMap
4 百 graph
>易 callFlowGraph
>& flowGraph
皀 _ nu__exception_handler.gdl
、 画 CallGraph.gdl
S]	fflushgraph.gdl
项；netsky_a_>vin m a in_cfg. g d I
Mj netsky_a_V</inMainl6.gdl
』百info
U IDA_testFunc.txt
国 ID A_te sti n g API .txt
，> util
0 _init_.py
0 痢 extractPaths.py
>S getAttrl.py
l> 嬉 getAttrs.py
A 屈 models.py
i> 回 refinedData,py
>0 similar.py
b ■ python (D:\Progr ... thon27\python.exe)
图4-1 ACS系统的目录结构
由图4-1可知，系统总体分为四个部分，分别是config、graph、info和 utilo下面对这四个文件夹依次进行介绍。
Config文件夹主要用于程序各项系数的配置，这些系数包括二元组映射码 表、输入文件名、输入文件类型、家族后缀等。
Graph文件夹中包含所有系统的输入文件。ACS系统中主要使用两种文件作 为输入，它们均是由I DA Pro生成的，后缀均为gdl。这两种文件分别是函数调 用图(Function Call)和控制流图(Flow Chart),其中前者用于获取子程序中调 用的Windows APL后者用于获取样本程序的子程序调用偏序，将二者结合分析 即可得出样本整体调用Windows API的偏序关系。
Info文件夹包含ACS系统的描述信息，这些信息具体包含IDA Pro提取 Windows API的签名库信息、系统的功能描述信息等。
Util文件夹中包含主要的处理函数以及主要的数据结构，数据结构分布于 models, py和refinedData. py两个文件中，前者存储基本的顶点、边等数据结 构；后者存储权值矩阵等数据结构，主要用来进行相似性分析。处理函数则分布
36
于getAttrl. py, getAttrs. py以及similar, py中，前两个文件主要提供数据预 处理函数，后一个文件主要提供相似性比对处理函数。下面将就数据预处理、图 相似性分析两个需求点分别进行具体介绍。
4.1数据预处理模块
样本的可执行文件经过PEiD脱壳后，通过IDA Pro进行反汇编处理，得到 样本总体的函觐园用图(Function Call)和各个子程序(Subroutine)的控制流图(flow graph)的调用关系。得出的输出文件为IDA Pro软件自定义的Graph Definition Files,函数调用图和控制流图的文件后缀为gdl。其中函数调用图中可以提取出 子程序的调用偏序关系，每个子程序的控制流图中可以提取岀子程序的库函数调 用关系，两者结合即可得出程序整体的库函数调用偏序关系。通过数据预处理, 得岀程序的权值矩阵进行后续分析。
4.1.1数据结构
1.顶点
在函数调用图和控制流图中都有顶点结构体，在函数调用图中的顶点子函数 而在控制流图中的顶点表示的是库函数。其中的title字段用于表示此顶点在 文件中的ID, label字段用于表示此顶点在文件中的名字。由于顶点结构体 即可表示函数调用图中的子函数，又能表示控制流图中的库函数，所以加入 vertextype字段来进行区分。另外还有两个字段indegree和outdegree分别表 示此顶点的入度和出度。其具体封装形式和字段描述表如下：
class Vertex(object):
def  	_init (self, title, label, vertextype, indegree, outdegree):
self title = title
self.label = label
self.vertextype = vertextype	-
self.indegree = indegree
self.outdegree = outdegree
37
表4-1顶点的表结构
字段名	存储类型	允许为空	默认值	描述
ID	INTEGER	否	1	主键，自增变量
title	INTEGER	否	无	表示此顶点在文件中
的ID
label	VARCHAR(50)	否	无	表示此顶点在文件中 的名字
vertextype	VARCHAR(20)	否	无	用于区分函数调用图 中的子函数，又能表示 控制流图中的库函数
indegree	INTEGER	是	-	0	顶点的入度
outdegree	INTEGER	是	0	顶点的出度

1.边
同顶点类也对应两种实体。在控制流图中的边表示子函数的偏序关系, 而在子函数的控制流图中则表示库函数的偏序关系。其中的fromlD字段表 示源的ID, toID字段则表示端的ID,只在控制流图中type字段有效，它表 示操作码，默认为0。其具体封装形式和字段描述表如下：
class Edge(object):
def  	init (sel£ fromlD, toID, type=0): self.fromlD = fromlD selftoID = toID self.type = type
表4-2边的表结构
字段名	存储类型	允许为空	默认值	描述
ID	INTEGER	否	1	主键，自增变量
fromlD	INTEGER	否	无	源的ID
toID	INTEGER	否	无	端的ID
type	INTEGER	是	0	操作码，仅在控制流文件中 有效

1.系统调用
系统调用对应着程序中的所有库函数调用信息。其中objID字段为此系统调
38
用对应的32种类型映射码之一,optID字段则表示此系统调用对应的4种操 作映射码之一，sysCallName字段则表示此系统调用的名称。系统调用结构 体的具体封装形式和字段描述表如下：
class SystemCall(obj ect):
def  	init (self objID, optID, sysCallName):
self.objlD = objID
self.optlD = optID
self.sysCallName = sysCallName
表4-3系统调用的表结构
字段名	存储类型	允许为空	默认值	描述
ID	INTEGER	否	1	主键,自增变量
objID	INTEGER	否	无	表示此库函数调用 对应的类型映射码
optID	INTEGER	否	无	表示此库函数调用 对应的操作映射码
sysCallName	VARCHAR(50)	否	无	表示此库函数调用 的名称
2.精简指令
精简指令就是封装化的库函数映射码。其中objID表示类型映射码，optED 字段表示操作映射码，objectName字段表示类型名称，operation字段表示操 作名称。其具体封装形式如下：

class Extractedlnstruction(object):
def init 	(self, objID, optID, objectName, operation): self.objlD = objID self.optlD = optID
selfobjectName = objectName selfoperation = operation
39
表4-4精简指令的表结构
字段名	存储类型	允许为空	默认值1	描述
ID	INTEGER	否	1	主键，自增变量
objID	INTEGER	否	无	类型映射码
optID	INTEGER	否	无	操作映射码
objectName	VARCHAR(50)	否	无	类型名称
operation	VARCHAR(50)	否	无	操作名称

3,类型实体
这个结构体定义了系统层级的类型实体信息。ID字段即为其唯一标识的字段。 name字段表示实体名。description字段为此实体的描述信息。其具体封装形 式和字段描述表如下：
class Objectltem(object):
def  	init 	(self, ID, name, description):
selfllD = ID
self.name = name
self.description = description
表4-5类型实体的表结构
字段名.	存储类型	允许为空	默认值	描述
ID	INTEGER	否	无	主键，唯一标识类型 实体
name	VARCHAR(50)	否	无	类型实体名
description	VARCHAR(200)	是	G，	类型实体的描述信息

6.操作实体
同类型实体类似，这个结构体定义了系统层级的操作实体信息。ID字段唯一 标识操作实体，name字段表示操作名，description字段为描述字段，描述操 作实体的基本信息。其具体的封装形式和字段描述表如下：
class Operationltem(object):
def  	init 	(sel£ ID, name, description):
selfLID = ID
selfname = name
selfdescription = description
40
表4-6操作实体的表结构
字段名	存储类型..	允许为空	默认值	描述
ID	INTEGER	否	无	用于唯一标识操作实 体(自增主键)
name	VARCHAR(20)	否	无	操作实体名
description	VARCHAR(100)	是		操作实体的描述信息

7.子函数系统调用
子函数系统调用结构体用来表示各个子程序中调用的库函数关系。其中有两 个字段，callerID字段表，示当前作为调用者的子函数(subroutine)的ID, calleelD字段则表示被调用的库函数调用ID。其具体封装形式和字段描述表 如下：
class CallSys(objeet):
def  	init (self, callerID, calleelD):
selfcallerlD = callerID
self.calleelD = calleelD
表4-7子函数系统调用的表结构
字段名	存储类型	允许为空	默认值	描述
ID	INTEGER	否	1	主键，自增变量
callerID	INTEGER	否	无	调用者的subroutine 对应的ID
calleelD	INTEGER	否	无	被调用的库函数ID

8.子函数调用
子函数调用结构体用于表示子函数(subroutine)之间的调用关系，相当于一条 有向边，并且这条边的源和目的均为子函数(subroutine)..子函数调用的具体 封装形式以及字段描述表如下：
class CallSub(object):
def  	init (self, callerID, calleelD):
self.callerlD = callerID
self.calleelD = calleelD
41
表4-8子函数调用的表结构
字段名	存储类型	允许为空	默认值	描述
ID	INTEGER	否	1	主键，自增变量
callerID	INTEGER	否	无	源子函数的ID
calleelD	INTEGER	否	无	目的子函数的ID

4.1.2映射码初始化
映射码初始化即是将二元组进行初始化并将其存储到数据库中。其具体实现 函数是initMapQ,实现步骤如下：首先从配置文件中读取映射文件，然后从映射 文件中获取操作映射码和类型映射码，并将其进行组合，存储到数据库中。最后 将数据库中的数据与映射文件中的数据进行匹配，得到总体的映射码。其流程图 如下：





图4-2映射码初始化流程图
42
下图所示为initMap()的部分代码：
def	•filename,mapFile):
Ext ractedCa.il (filename) t	. .	•.
models.Extractedinstruction«createTable()
conf = self, get File (filenafne)
■For i in range(0,4):
self. extractedOperations[i] = conf. get ( "operation% i) for j in range(0,32):
self. extractedObjects[ j]=conf.get(	"慈庁"% j)
• for k in range(0z4):
for m in range(0J32):
extInstruction = \ models ・ Extractedlnstruction\ (m, k> self. ext r a ct e dOb j ect s. get (m), \ set/.extractedOperations.get(k)) extInstruction» addData()
mapfile = open(mapFile) lines = mapfile«readlines() ■flag = -1	'
-For eachtine in lines:
i-F tr[instruction] *r in eachLine:
flag = 0
elif ^[object]"" in eachLine:
flag = I
elif *YoperationJ" in eachLine:
^lag = 2
else:
豪 源版 instruction
if flag==O:
splitPos = eachLine .-Find( specInstruction = eachLine[rsplitPos] specNumber = int(eachLine[splitPos+l:]) ^prin-t "渝汶 instruction number are:** Sprint."绥％ %d>!驚 C spec In struct Mn.
:--•- ~•….•-  工，…….…...	T-.. . ' •，” '	."”
图4-3 initMap()函数的部分代码
4.1.3库函数映射函数
库函数映射函数是将具体样本中的所有库函数映射到数据库中的二元组中 的值，其具体实现函数是sysToExtMap()。实现步骤如下：从样本文件提取其中 调用的所有库函数，然后从数据库中提取类型映射码进行匹配，匹配成功置类型 旗帜变量为true,否则置false；随后从数据库中提取操作映射码进行匹配，匹配 成功置操作旗帜变量为true,否则置false；之后根据前两个旗帜变量的值再做最 后一次匹配，匹配比对的对象是一些具体二元映射码，匹配成功置二元映射码旗 帜变量为true,否则为false；最后根据二元映射码旗帜变量的值决定是否保留当 前匹配结果。其流程图如下：
43


图4-4库函数映射函数流程图
下图所示为sysToExtMapO函数的主要实现代码：
def sysToExtMap(se£f^filename):
print "QltSysCuUs length is 初"% sei/.allSysCalls._len_()
print self.extractedCbjects
models, SystenjCall. createT able (filename)
if (sei/.allSysCalls. 	len 	()!=2) and len(sei/.extractedQbjects)>S:
cursor = 0
objectFlag = False operationFlag = False flaginstruct = False while cursor < len(self.allSysCalls): objectFlag = False operationFlag = False objOnlyFlag = False objCursor = -1 optCursor = -1 print "踏皿& is e,+5etf.allSy5Calls[cursor] for j in range(0,32):
-if re.search(str(seiy.extractedObjects.get(j)) , seif.all5ysCalls[cursor], re.IGNORECASE): self .objectKap[j].append(cursor) objectFlag = True objCursor = j
if (2>=set/. allSysCalls [cur sor]. 	len 	() - self, extract edObjects. get (j). 	len 	()>=0): objOnlyflag = True
print 喩X 钮 或霍£说?費	>
break
for j in range(0,4)-
if re.search(str(se£f,extractedOperations.get(j)) , seif.allSysCalls[cursor], re.IGNORECASE): set/.operation^ap[j].append(cursor) operationFlag = True cptCursor = j
print in operatiGn^Q
break
if objectFlag == False or operationFlag == False:
图4-5 sysToExtMap()函数的主要代码
44
4.1.4顶点与边的初始化函数
顶点与边的初始化函数主要用来对一个样本的子函数调用的函数调用图和 每个子函数的控制流图进行初始化。其实现函数是edge_vertexlnit()o其实现流 程是：首先初始化边的入度出度以及边的源顶点和目的顶点；然后获取样本文件 的边和顶点信息；之后将边信息和顶点信息融合存储值数据库中。其流程图如下:
初始化边
信息
初始化顶点
信息
获取样本的边
信息
获取样本的
顶点信息
/ 格式化的边信 7
/ 息与顶点信息/
图4-6顶点与边的初始化流程图
由于本文所讨论的恶意代码检测方法的匹配算法并非直接将恶意样本 进行匹配，而是需要将其进行预处理，所以ACS系统首先会将恶意样本进行 预处理，处理结果即为一个128*128的矩阵，以Netsky恶意家族为例，下 表即是对Netsky家族处理所得的矩阵。
45
表4-9 Netsky家族的权值矩阵的子矩阵



表4-9为Netsky恶意家族的权值矩^^的子矩阵,其中行列中的数值与二元 组映射码相对应。例如53表示类型码为13,操作码为0的二元组(13*4+1=53), 依此类推，即可得到恶意家族的完整权值矩阵。
4.2图相似性分析模块
样本的可执行文件经过PEiD脱壳后，通过IDA Pro进行反汇编处理，得 到样本总体的函数调用S(function call)和各个子程序(Subroutine)的控制流图
(flow graph)的调用关系。其中函数调用图中可以提取出子程序的调用偏序关系, 每个子程序的控制流图中可以提取出子程序的库函数调用关系，两者结合即可 得出程序整体的库函数调用偏序关系。得到程序整体的库函数调用偏序关系后 即可进行图相似性分析。下面将从数据结构和具体函数入手分别对图相似性模 块做相应介绍。
4.2.1数据结构
图相似性分析模块中使用的数据结构主要有数据预处理模块中用到的顶点
(Vertex)和边(Edge)。下面将分别介绍：
在函数调用图和控制流图中都有顶点结构体，在函数调用图中的顶点子函数, 而在控制流图中的顶点表示的是库函数。其中的title字段用于表示此顶点在文件 中的ID, label字段用于表示此顶点在文件中的名字。由于顶点结构体即可表示 函数调用图中的子函数，又能表示控制流图中的库函数，所以加入vertextype字
46 段来进行区分。另外还有两个字段indegree和outdegree分别表示此顶点的入度 和出度。入度的含义是以此顶点为目的节点的数目。出度的含义是以此顶点为源 节点的数目。其具体封装形式和字段描述表如下：
class Vertex(object):
def init (sel£ title, label, vertextype, indegree, outdegree):
selftitle = title	'
self.label = label
self, vertextype = vertextype
self indegree = indegree
self.outdegree = outdegree
表4-10顶点的表结构
字段名	存储类型	允许为空	默认值	描述
ID	INTEGER	否	1	主键，自增变量
title	INTEGER	否	无	表示此顶点在文件中的
ID
label	VARCHAR(50)	否	无	表示此顶点在文件中的 名字
vertextype	VARCHAR(20)	否	无	用于区分函数调用图中 的子函数，又能表示控制 流图中的库函数
indegree	INTEGER	是	0	顶点的入度，即以此顶点 为目的节点的数量
outdegree	INTEGER	是	0	顶点的出度，即以此顶点 为源节点的数量

2.边
同顶点类似，边也对应两种实体。在控制流,中的边表示子函数的偏序关系, 而在子函数的控制流图中则表示库函数的偏序圭系。其中的fromID字段表示源 的ID, toID字段则表示端的ID,只在控制流图中type字段有效，它表示操作码， 默认为0。其具体封装形式和字段描述表如下：
47
class Edge(object):
def  	init (self, fromID, toID, type=O): selffromlD = fromlD self.toID = toID selftype = type
表4-11边的表结构
字段名	存储类型	充许为空	默认值	描述
ID	INTEGER	否	1	主键，自增变量
fromlD	INTEGER	否	无	源的ID
toID	INTEGER	否	无	端的ID
type	INTEGER	是	0	操作码，仅在控制流文件中有 效，有三种可能取值，0表示非 条件跳转，即无条件判断直接 跳转，-1表示fhlse分支，1表 示true分支。默认值为0。

4.2.2相似性比较函数
相似性比较函数，函数的输入为两个矩阵，其中之一是样本的库函数调用 矩阵，另一个是恶意家族数据库中一个家族的库函数调用矩阵。函数的功能是 找到最大的公共部分占总体的比例，其中实现了公式3-7。具体执行过程是： 首先遍历比较矩阵中的相同部分，此过程实现了公式3-5；然后计算两个矩阵 的并集，此过程实现了公式3-6；最后将上述两个步骤中的数值相除得出两个 矩阵的Jaccard系数，以此来判断两个矩阵的相似性。此函数的实现函数名为 getMaxSimitarQo其具体执行流程图如下所示：
48


输入样本文
件



图4-7相似性比较函数流程图
下图所示即为getMaxSimilar()函数的具体实现代码：
def getMaxSimilar(sel/? matrixA^ matrixB):
matrix = [[0 for j in range(0>128)] for i in range(。，128)]
for k in (0,128):
cursor = 0
if matrixA[k]. 	len 	( ) >0 or matrixBfk]. 	len 	() > 0: for eachA in matrixA[k]:
if eachA in matrixB[k]:
# get the common element
matrixfk][cursor] = eachA
cursor += 1
return matrix
图 4-8 getMaxSimilar()函数
如图4-8所示，getMaxSimilar()函数将对A矩阵与B矩阵的相同位置依次进 行比较，最终返回两个矩阵的交集矩阵。
49
4.2.3偏移计算函数
偏移计算函数的主要功能是计算两个矩阵的偏移量，偏移量体现了数据的 波动性，本函数的目的是挑选出偏移量在可控范围内的矩阵。其具体流程如下： 首先通过数据预处理得到样本文件的权值矩阵，从数据库中依次使用恶意家族 权值矩阵得到两个权值矩阵，这两个矩阵作为程序的输入；然后程序具体实现 了公式3-8,计算出样本程序的偏移量；最后，将此偏移量同数据库中存储的 恶意家族偏移量进行比较，若落在此范围内则将此样本程序判定为属于此恶意 家族。偏移计算函数的流程图如下：
输入样本文
件
(签名库Q
/恶矗族/
7权值短阵/
计挤偏移	、/偏移量A
量	飞普 U
rz
〔结束)
图4-9偏移计算函数流程图
下面将给出计算偏移量函数的函数体：
def getOffset(set/, matrixSource, matrixTarget):
offset = 0
for i in range(0J128):
for j in range(0>128):
offset += (matrixSource[i][j]-matrixTarget[i][j])*\ (matrixSource[i][j]-matrixTarget[i][j]) return offset
图 4-10 getOffset 0 函数
50
如图4-10所示，getOffsetO函数将对源矩阵matrixSource与目标矩阵 matrixTarget在相同位置上的元素的差方进行累加，最终返回这个累加值offset 作为样本target相对于source的偏移量。
43小结
本章从具体实现的角度介绍了基于Windows API检测系统。与第三章相对 应，本章灰数据预处理和图相似性分析两个方向分别介绍了 ACS系统的具体实 现。数据预处理模块从使用的数据结构与具体函数的实现两个方面进行了介绍。 图相似性分析模块也从这两个方面进行了介绍。
51
第五章.系统测试
本章对系统进行一系列测试，测试按目的分为两种，一种是功能性测试，主 要用来测试系统的各个功能是否能够按照预期正常执行；另一种是算法对比测试, 通过与同类检测算法进行横向对比，验证此系统使用的方法是否具备优势。
5.1测试样本
试验中的测试样本分为训练集样本和测试集样本，共选取2361个，其中训 练集样本501个，分为10种，测试集样本1679个，分为3类。训练集样本主要 用来提取恶意家族特征码以及生成相应恶意家族的偏移量;测试集则主要用来对 系统的准确性进行评估，并在和其他方法横向对比的过程中验证本系统的实际检 测效果。本文中的恶意代码的来源有两部分，第一部分来自VX Heaven病毒实 验室，另一部分来自国家互联网应急中心(CNCERTZCC)o
5.1.1训练集样本
训练集样本的作用是通过行为分析等手段提取恶意代码家族的特征码，并且 本系统使用训练集生成恶意家族的偏移量从而得到恶意家族偏移量的置信区间。 具体的训练集样本的相关信息如下表所示：
表5-1训练集样本信息表
序号	家族名称	数量(个)
1	Worm.Win32.Netsky	132
2	DangerousObject.Multi.Generic	52
3	Trojan. Win32.Generic	63
4	Trojan.Win32.AutoRun.gen	37
5	Virus*Win32.Sality.gen	80
6	Exploit. Win32.CVE-2010-2568.gen	26
7	AdWare.Win32.DelBar.a	34
8	Troj an. Win32. Starter.lgb	18
52

续上表
序号	家族名称	数量（个）
9	Virus.Win32.Nimnul.a	47
10	Worm.Win32.Debris.a	12
5.1.2测试集样本

测试集样本总共有3类，分别是恶意程序、非恶意程序和其他，测试集样本 中的恶意程序中有273个是从训练集中随机抽取的，还有102个是从VX Heaven 病毒实验室下载的；其中的非恶意程序样本则选取了常见应用程序；其他则是从 CNCERT/CC出获得的未知类型的文件。下表所示为部分测试集样本：
表5-2部分测试集样本
程序名	是否恶意	描述
IE8-x86	否	32位的IE8浏览器
Firefbx34.0.5.5443	否	32位的Firefox浏览器
Ipv6.exe	否	Windows系统文件
netstat.exe	否	Windows系统文件
Putty.exe	否	_种 telnet/SSH 工具
md5sum.exe	否	MD5检测程序
Trojan.Win32.AVKill.a	是	一种流行的木马
Trojan.Win32.Bagle.i	是	Bagle蠕虫的一个变种
Virus. Win32.Kido.ih	是	即熟知的ConBcker病毒
Virus.Win32.Zmist	是	—种 metamorphic 病毒
Virus.Win32.Sality.d	是	Sality的一个变种

5.2测试方法
53
本系统的特征库是由训练集进行训练学习的结果，所以根据测试集样本的识 别率以及准确率作为测试的标准。测试分为两部分，其一是功能性测试，功能性 测试用于检测系统各个模块的准确性，另一部分是横向比较测试，将使用另外三 种算法，这三种算法较多应用于静态检测，这三种算法分别是启发式算法 (Heuristic Approximate)> N-gram 算法和最优路径算法(Optimal Distance)0
5.3测试结果
基于Windows API的恶意代码检测系统的测试内容主要包括功能测试与算 法对比测试，功能测试主要针对程序的功能的准确性进行测试；算法对比测试则 将本算法同另外三种静态测试算法进行对比，下面将分别进行描述。	、
5.3.1测试环境
系统的测试环境由两部分组成，分别是硬件环境和软件环境，下面将对其进 行详细描述：
CPU	Intel(R) Core(TM) Duo 15
运行内存	8G
操作系统	Windows 7
软件	Eclipse> IDA Pro, PEiD、MySQL

5.3.2功能测试
基于Windows API的恶意代码检测系统的功能测试主要覆盖数据预处理模 块和图相似性分析模块，下面将分数据预处理模块和图相似性分析模块进行测试。
1.数据预处理模块测试用例
用例标识	Vertex_Edge_init
功能名称	顶点初始化功能
功能描述	顶点与边的初始化函数主要用来对一个样本的子函数调用的函数调 用曲和每个子函数的控制流图进行初始化
用例目的	测试顶点与边初始化功能正确性
前提条件	映射码与库函数映射函数均己初始化
输入/动作	期望的输出	实际情况
54


输入/动作	期望的输出	实际情况；
将 sub_4010A4.gdl 文件配 置为碗入文件	数据库屮存储 edge_a_ sub_4010A4_fg	与 vertex_a_
sub 4010A4 fc 表	与预期一致
测试结果	}	通过
:测试A」」	王超	测试时间	2014-9-1
:审核人:"	王超	亩核时间	2014-9-10-

本文将通过Netsky恶意家族来对数据预处理模块进行测试，以此检验预处
理模块是否达到预期目标。



图 5-1 数据库中的 edge_a_sub_4010A4_fg 表
图5-1所示为将sub_4010A4.gdl文件配置为输入文件，在数据库中存储的边 信息表。由图可知，程序能够对边信息正确进行初始化。
55


图5-2数据原中的vertex a sub 4010A4 fc表
图5-2所示为以sub_4010A4.gdl文件配置为输入文件，在数据库中存储的节 点信息表。由图可知，程序可以对点信息进行正确的初始化。
2.图相似性分析模块测试用例

用例标识	Maxsimilarity
功能名称	最大似然函数
功能描述	找到样本同库中恶意家族库函数调用矩阵最大的公共部分占总体的比例，
用例目的	测试最大似然函数功能的正确性
前提条件	恶意家族库函数调用数据库已经过初始化
输入/动作	期望的输出/相应	实际情况
将Netsky-a变种的子函数 sub_4010a4提取权值矩阵， 和無意家族数据库中的 matrix_ sub_4010a4 进行对 比	100%	与预期一致
'M 'if 単	通过

图5-3所示为将Netsky-a变种的子函数sub_4010a4提取权值矩阵，和恶意家族 数据库中的matrix.sub_4010a4进行对比。由图可知，程序能够对边信息正确进行 初始化。图5-3 sub_4010a4子函数的相似性比对结果将Netsky-a变种的子函数

sub_4010a4提取权值矩阵，和恶意家族数据库中的matrix_ sub_4010a4进行对 比的结果。数据库中存储的matrix_sub_4010a4矩阵是在训练集进行训练过程 中生成的Netsky恶意家族中的子矩阵。由图可知，相似性比较函数能够正确 对两个矩阵的相似性进行计算。5.3.3算法对比测试
验证恶意代码检测算法有两种途径，一种是使用多种恶意样本检测使用此检 测方法的误报率与漏报率，另一种是使用多种算法进行比较。表5-3所示即为使 用基于Windows API的恶意代码检测系统的各恶意家族的检测结果。
表5-3 ACS系统的检测结果
^(%)
恶意样本	误报率	漏报率
W orm>Win3 2 .Netsky	11.8	29.2
DangerousObj ect.Multi. Generic	27.9	40.0
Trojan.Win32.Generic	38.0	23.1	•
Trojan.Win32.AutoRun.gen	23.9	33.5
Virus. Win32. Sality. gen	40.7	30.6
Exploit. Win32.CVE-2010-2568.gen	8.7	17.4
AdWare. Win32.DelBar.a	19.6	20.8
Trojan.Win32.Starter.lgb	51.9	27.3

续上表
测率(%)
恶意样本	误报率	漏报率
Virus.Win32.Nimnul.a	11.5	49.2
Worm. Win32. Debris, a	31.8	12.9
下表所示为算法间的平行对比，其中使用的测试恶意家族为Netsky,其中最 后的API Calling即为本系统使用的算法。

57
北京邮电大学工学硕士学位论文 表5-4各算法的对比测试
测试结藁冰、	Heuristic
Approximate	N-Grams	Optimal
Distance	API Calling
误报率	16.6	19.1	23.3	4.5
漏报率	21.5	12.3	37.6	12.4

表5-4中列举了几种检测算法用作测试结果的对比分析，输入的样本由 Netsky恶意变种、非Netsky恶意样本和正常程序样本三部分组成，其中Netsky 恶意变种163个，非Netsky恶意样本从训练集中随机取出223个，正常程序从 测试集中随机抽取正常程序样本398个。由表2可得API调用算法在检测Netsky 恶意家族具有较高的检测率，检测效果较好。
58
第六章.总结与展望
6.1个人工作总结
本文讨论了通过提取恶意家族API调用矩阵来识别样本的方法。ACS依然归 属于静态检测范畴，但由于对样本进行抽象提炼获取API调用，故ACS又体现 了程序部分语义层级的特点，所以ACS相较传统的静态检测方法具备一定的优 势。另外，ACS增加了样本同恶意家族权值矩阵的偏移量计算步骤，通过增加 偏移量的计算能够一定程度地过滤检测过程中的不确定性因素进而提升检测的 准确性。本文论述的是对一个恶意家族的检测，由于家族特征相较于单个恶意样 本具备一定的统计学规律，所以需要降低样本不稳定性对于整体实验结果的影响, 引入偏移量就是从这一角度入手，通过减少样本差异性对整体的影响得到更一般 的家族特征。事实证明，增加偏移量计算步骤在不显著影响漏报率的前提下降低 了误报率，故这种方法是值得推荐的，尤其对于模糊化样本的检测具有一定参考 价值。
6.2系统待改进之处
本文所论述的方法还有很多局限首先，ACS的实验数据集均为PE可执行 文件，只能运行在Windows环境下，所以无法顾及其他操作系统。其次，本实 验数据预处理阶段使用的脱壳工具和反汇编软件只能针对部分可执行文件进行 解析，增加的解析操作过程本身又可能引入新的问题，例如反汇编过程中不同lib 库的选择可能导致解析结果偏差甚至错误。另外，API调用的划分可能不尽合理， 这可能一定程度地影响实验结果的准确性0下一阶段笔者将在API调用的选取与 分类上进行平衡以获得更高的准确性。
59
参考文献
[1]黄澄清，云晓春，刘欣然等.2013年中国互联网网络安全报告[R],北京：
国家互联网应急中心,2014.4:73-94
[2]CWSandbox. [EB/OL]. http://www.sunbeltsecurity.com/sandbox/, 2011
[3]Norman Sandbox. [EB/OL]
http://www.norman.eom/security_j:eiitei/security_tools/, 2011.
[4]JoeBox. [EB/OL] http://wwwjoesecurity.org/, 2011
[5]Anubis. [EB/OL] http://anubis.iseclab.org/, 2011
[6]ThreatExpert. [EB/OL] http://www.threatexpert.com/, 2011.
[7]S. Forrest, S. A. Hofineyr and A. Somayaji. A sense of self for unix processes
[A], in Proc. IEEE Symp. On Security and Privacy, 1996: 120-128
[8]方志鹤.恶意代码分类的研究与实现[D],湖南：国防科学技术大学， 2011
[9]Philip O'Kane, Sakir Sezer, and Kieran McLaughlin. Obfuscation: The Hidden Malware [R]. Belfast: Queen's University, 2011
[10]R. Livintz. Conficker-One Year After [EB/OL]
http ://www.malwarecity. com/blog/conficker-one-year-after-part-one-672±t ml
.[11] 1莉莉，庞建民，张一弛等.基于关键应用编程接口图的恶意代码检测. 计算机工程[J],郑州，2010.5,36(9):139-141
[12]姜晓新，段海新，管云涛.恶意代码自动分析技术研究[C].北京，第六届 中国信息和通信安全学术会议(CCICS2009), 2009:615-621
[13]Windows API [EB/OL] httD：〃zh・wikipedia.org/wiki/Windows_APL 2013
[14]Microsoft Developer Network. Overview of the Windows API, 2005
[15]T. Lee and J. J. Mody. Behavioral classification[C]. in Proc, of EICAR 2006, 2006:1-17
[16]M. Li and P. Vitanyi. An Introduction to Kolmogorov Complexity and Its Applications[J]. Springer, 1997
[17]Li Ming, Chen Xin, Li Xin, Ma Bin et al. The similarity metric[A]. Philadelphia, PA, USA: In SODA 03: Proceedings of the fourteenth annual ACM-SIAM symposium on Discrete algorithms, 2003:863-872
[18]M. Bailey, J. Oberheide, J. Andersen et al. Automated classification and analysis of internet malware [A]. USA, In Proceedings of the 10th Symposium on Recent Advances in Intrusion Detection (RAID507), 2007:178-197
[19]S. Wehner. Analyzing worms and network traffic using compression [J] USA, Journal of Computer Security, 2007.8,15(3):303-320
60
[20]K. Rieck, P. Trinius, C. Willems, T. Holz. Automatic Analysis of Malware Behavior using Machine learning [A]. 2009.
[21]Christodorescu Mihai, Jha Somesh, Seshia Sanjit A. Semantics-aware malware detection [C]. IEEE Symposium on Security and Privacy, 2005
[22]Kyo chang Jeong, Heejo Lee. Code Graph for Malware Detection [C]. 25th Annual ACM Symposium on Applied Computing, 2010
[23]VX heaven Laboratory [EB/OL]. http:〃www・vxheaven.org, 2014
61
