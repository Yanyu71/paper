
第一章绪论
1.1研究背景
物联网(Internet of Things),指的是将各种信息传感设备，如传感器、激光扫描器、 射频识别器、定位系统、红外感应器等装置与互联网结合而形成的一个巨大网络。物联 网服务系统可以自动的、实时的对物体进行识别、定位、追踪、监控并触发相应的事件。 随着物联网技术的迅速发展，其应用领域已经覆盖人们生活的各个方面。目前物联网的 应用领域主要包括射频识别、传感器网络、M2M和两化融合(信息化与工业化的高层 次深度结合)。与此对应的，出现了非常多的物联网应用系统，包括监控系统、智能家 居、锅炉房监控系统等。如此众多的监控设备，导致了海量物理传感数据的产生。
面对海量数据，如何有效地处理、组织和查询数据是物联网的重要问题。因此，首 先需要对数据进行有效的知识表示，通过将数据知识化屏蔽数据之前的差异。在此方面， 已有的物联网资源框架通过建模屏蔽数据的底层差异，通过描述资源的领域信息，对资 源进行标准化的描述，将物联网的信息分层次分类别进行描述，生成资源，实体，属性 以及概念的实例化数据等元素，最终生成资源模型。另一方面，物联网系统当前大都釆 用事件驱动的方式对信息进行响应处理，如何在事件流中抽取有价值的复杂事件是当前 物联网系统迫切需要解决的问题。事件具有海量性、异构性、实时性等特点，所以事件 同样需要建模。资源模型是物联网知识的载体，为了方便管理者与使用者利用已有的物 联网资源知识，需要一个统一的物联网系统知识管理方案，包括物联网资源模型与实例 的管理、刻画物理对象运行规律的函数知识管理、事件的知识定义、事件与资源的知识 映射管理、以及抽取的复杂事件知识管理等。
在物联网知识系统基础上，为了对实时爭件流进行响应处理，需要实现知识发现和 知识抽取等动态知识管理功能。如何基于物联网资源模型，対实时事件流进行处理并计 算隐藏在资源模型和事件背后有价值的复杂事件是?个非常值得研究的问题。
已有的资源框架主要釆用本体来对物联网资源进行建模，利用本体来表示物联网资 源、属性、以及相互之间的关系。本体起源于哲学概念，概括来说是概念与概念间关系 的形式化表示。本体描述语言能描述复杂的关系，目前在语义网、医学信息共享、知识 管理、地理信息共享以及数字图书馆等领域有广泛的应用与研究。本体是构建在描述逻 辑的基础上的，可以作为一种能在知识和语义层次I：的描述物联网概念模型的建模工具。
物联网通常是在某种条件被满足时对事件进行响应，这个条件可称之为II标事件。 目标事件与物联网资源相关联，例如，温度过高报警、路状拥堵等。如何从高速的实时 事件流中有效的发现目标事件决定了能否实现高效的事件实时处理功能。在已有的资源 模型框架之上，结合本体的描述逻辑特性，如何利用推理进行事件处理是一个很值得研 究的问题，为此本论文提出了一个基于模型和目标事件的事件推理机制，通过定义目标 事件并且将目标事件知识化，结合资源模型转化成逻辑形式，每当事件到来，将事件与 已有模型和目标事件之间的关系同样处理成逻辑的形式，然后通过推理和证明来验证目 标事件是否成立，从而根据结果对事件进行响应处理。
1.2研究内容
本课题的主要研究内容是设计并实现一个物联网知识子系统。通过运用面向领域的 设计思想，实现统一的物联网系统知识管理。本论文主要进行以下几个工作：
1）	为了方便管理者与使用者利用已有的物联网资源知识进行复杂事件处理和 新应用的开发，需要设计与实现统一的物联网系统知识管理，包括物联网资 源模型与实例的管理、刻画物理对象运行规律的函数知识管理、事件的知识 定义、事件与资源的知识映射管理、以及抽取的复杂事件知识管理等。
2）	在既有物联网知识系统基础上，实现知识发现和知识抽取等动态知识管理， 即基于物联网资源模型，对实时事件流进行处理，计算隐藏在资源模型和事 件背后有价值的复杂事件。
3）	利用既有的物联网系统中发布订阅通信基础设施接口，将实时事件引入到知 识子系统中，完成事件格式转化，方便后续的事件知识化。另外，采用B/S 模式实现…个知识子系统人机管理界面。
事件整体处理流程如下：
首先，定义目标事件并解析，解析目标包括主题信息提取、知识对象映射、目标- 阶表达式生成等任务。
1）	提取主题信息，然后通过事件接入模块订阅相关主题信息以接收事件。
2）	知识对象映射，提取目标中的scope信息，通过映射生成知识对象。知识对象 对应知识库中的实例，也就是本体中类的实例。利用此对象查询本体知识库可以获取与 此对象实例相关的实例、数据属性、对象属性。这些关系和属性构成了一个包含概念， 属于描述逻辑中的包含范畴。然后利用描述逻辑与一阶逻辑的关系，通过翻译模块翻译 成为阶逻辑表达式。利川这些?阶逻辑关系可以推理新的事件知识对象是否属于目标 推理范围。
3）目标一阶表达式生成。主要将目标中的参数和相关约束处理成一阶逻辑表达式。 约束对应了一阶逻辑推理库中的算了函数。比如等于、大于等于、小于等于、大于、小 于等约束。
然后，每当事件来临，根据事件映射成为事件对象，这可以通过主题映射到事件结 构的方式实现，每一个主题对应一个schema,根据schema确定事件的携带信息结构， 解析生成具体的事件对象。事件对象需要与知识库内的知识相对应，这可根据事件对象 映射机制映射生成知识库中的知识对象，如果发现事件无法对应知识库中的知识则将事 件对象及时的销毁，节省内存使用。事件映射为知识对象之后，需要知道知识对象是否 处于目标推理的范围之内，只有属于推理范围内的事件才有意义，这可利用逻辑包含的 概念来实现。在描述逻辑中，包含概念是一种基本概念，在本体中定义也非常方便，比 如，一个类有多个部分组成，所以-?个类的实例也有多个组成部分，这是最为常见的一 种包含概念应用。在本体的构建中包含关系在本体中已经定义好，本体也存储在本体知 识库中。在目标解析过程中，通过查询知识库将目标对象包含的范围中的实例都查询出 来。事件对应的知识对象如果是这些实例中则说明属于推理的范围之内，如果不是则不 属于推理范围之内。
最后，前述用户的目标定义经过处理生成的一阶逻辑表达式会由对应的推理单元 Solver负责，事件处理之后生成的一阶逻辑表达式会依次添加到相关的Solver中，然后 调用Solver的check。接口获取推理结果值，并将结果存储在数据库中持久化。在此过 程中，历史生成实例均按其所属领域和时间线存储在持久库中，同时，对于最近的时间 段采用队列维护方式缓存一部分在内存之中。新的实例来临，根据队列的尾部数据可快 速的判断状态是否变化，若无变化则可不更新，从而节省时间和空间。如果状态发生变 化，贝U分别对应每个状态并根据当前的状态进行分类，取出时间顺序队列里的数据交给 推理模块执行。同时，新的实例会加入到时间顺序队列，并在-定的周期内写入到持久 库之中。
1.3论文结构
本论文共包括七章，每个章节的主要内容安排如下：
第一章是绪论，首先介绍了本论文的研究背景，然后明确了本文的研究内容，最后 对本论文的组织结构进行了说明。
第二章是相关技术，主要是对本课题中涉及到的相关技术逬行介绍，主要包括物联 网网络本体建模、描述逻辑到一阶逻辑的转化、Jena框架、理论求解器Z3等关键技术。
第三章是需求分析，对本论文中设计的系统进行了需求分析，对各个模块的需求进 行了具体的分析。
第三竟是概要设计，对本论文中设计的系统进行了概要设计，结合相关的需求分析, 通过流程图和结构图的形式对各个模块进行了具体的概要设计。
第五章是详细设计及实现，针对第三章提出的物联网知识子系统中的重点模块进行 详细设计和实现的说明，主要包括用户接口、知识管理模块、事件接入模块，推理功能 模块。
第六章为系统测试及验证，主要介绍针对物联网知识子系统的功能及性能的测试, 并给出测试结果分析。
第七章为总结与展望，主要对本文的研究工作进行了总结，并且对后续的研究工作 进行了展望。
第二章相关技术
本章内容是介绍本论文中所涉及到的相关概念和技术。其中包括：本体领域建模、 描述逻辑和一阶逻辑、Jena语义框架以及…阶逻辑推理器Z3。
2.1本体建模
在设计和实现物联网知识子系统的过程中，为了更方便的存储领域知识，可以采用 具有丰富表达能力的本体来作为领域知识的载体。为了解析资源模型的载体本体文件， 需要掌握网络本体语言库的使用。
2.1.1本体的定义和构建方法
本体［1］是一种知识的表示方法，本体的定义也不尽相同。Gruber121在1993年对本体 进行了定义：本体是概念的显示化表示。之后，Stuber131在这些基础上对本体进行了扩 展。他认为本体是共享概念模型的、明确的、形式化的规范说明。具体含义包括四个概 念：模型、明确性、形式化、共享。本体可获得公众对所描述领域相关知识共同理解， 从而确定该领域的知识及公认词汇。能够在不同层次上对这些词汇及关系进行明确的定 义，并实现一定程度上的知识重用和共享。
本体的构建方法囲当前还没有统一的标准方法，主要是基于本体来对信息进行集成, 是实现知识共享、信息交换以及解决涪义冲突的基础，通过构建统一术语和概念，使得 异构系统以及设备之间的互操作成为可能。其中Perez15'61等人提出了 5个本体建模原语。 原语的使用，使得本体能够顺利地表达知识。5个分别为公理、概念、函数、关系和实 例。F面对这些原语进行洋细介绍
（1）	公理：是永真命题，指的是定义在概念或关系上的规则。
（2）	概念：是对某?类对象集合的描述，可以指代任何事务。概念是对客观世界 个体的抽象，能够表示个体的集合。包括概念的名称及其描述。
（3）	函数：是一种特殊的关系，在这个关系中，前n-1个元素可唯一确定第n个 元素。
（4）	关系：指的是概念间的相互关系，与对象元组的集合相对应。关系包括定义 域和值域。在本体中，定义域是指…个概念，而值域既可以是概念也可以是具体的值。 本体包含以下基本关系：part-of、kind-oR instance-of 和 attribute-ofo
（5）	实例：是对概念的貝体化，代表了满足这个概念届性的元素。
当前相关研究文献中的本体构建方法⑺共有8种，分别是Uschold和Gruninger提 出的骨架法，Polytecnic大学研究人员提出METHONTOLOGY方法，KBSI公司提出的 IDEF5方法，斯坦福大学提出的七步法，DoulasLenat提出的CYC方法，TOVE方法, KACTUS方法，SENSUS方法。其中斯坦福大学的七步法⑺应用最广，该方法将构建本 体分为七个步骤，分别是确定本体领域范畴、考察已有的本体的复用性、列出本体中的 重要术语、定义类之间的等级体系结构、定义类的属性信息、定义属性的方面、创建实 例。本文主要釆用此方法进行本体建模。
2.1.2本体的描述语言
由于本体是知识表示的一种方式，所以需要用明确并且无歧义的语言来描述。因此 自然语言无法胜任此项任务。在本体的发展过程中，提出的描述语言多种多样。在物联 网和语义Web领域应用的最多的是OWL语言，而OWL是建立在RDF/RDFS基础之 上的，这里先介绍一下RDF/RDFS o
如图2-1所示：

图2-1本体描述语言结构图

1) RDF/RDFS, RDF是资源描述框架同，是用于表示互联网资信息的框架。主要 用来描述资源与资源之间关系的语言规范。RDF是W3C在XML的基础上制定一套标 准，其含义包括以下几个概念：资源、描述、框架。RDF本质上是定义了资源-属性-
属性值，用来描述Web J:的资源。同时在实现方面几乎所有的语义库都支持多种方式 的本体表示形式。
2) OWL191： Web Ontology Language的简称，是当前主流的本体描述语言，也是 W3C提出的语义网本体描述语言的标准。与RDF相比，提供了更多的形式语义的词汇， 表达能力强于RDFoOWL在表达能力上可依次分OWL Lite,OWL DL和OWL Full卩°心 三种子语言，其中OWL Lite的表达能力最弱，词汇也最少，所以在应用方面比较少。 OWL Full则有最少的限制，因此有着最强的表达能力，但是没有可计算性保证。到目 前为止，仍没有支持0WL Full的推理机。相比较而言，OWLDL在词汇上有一些额外 限制，例如类、个体、数据属性、对象属性等在OWL DL中是两两不同的，而在OWL Full中这些都可看作类来表示。因此，在OWL DL中对称、传递和反转关系是不能用 于数据属性冋的，同样基数限制也不能应用于可传递的属性。这都是为了保证OWL DL 是可被推理计算的。
2.1.3本体的构建工具
本体构建冋工具主要是辅助本体编辑、构建、开发和维护的软件。主要有基于特定 语言的软件如Ontolingua, OntoSaurus, WebOnto和WebODE等，独立于特定语言的工 具Protege. OntoEdit、OilEd,它们支持导入导出多种本体描述语言，比如OWL、XML、 RDF等。斯坦福大学医学中心开发的Protege是目前应最广的本体构建工具。本论文也 采用Protege作为本体构建的工具。Protege是一个跨平台、可扩展、独立于领域的本体 编辑软件，本论文使用最新的5.1.0版本。Protege开发界面非常友好，允许用户在概念 层次上设计实领域模型，文件的导入导出也支持几乎XML、OWL、RDF/RDFS等所有 格式。
2.2逻辑推理
2.2.1描述逻辑
描述逻拆⑶(Description Logic)是基「对象的知识表示的形式化，它吸取了 KL-ONE 的上要思想，是,阶谓讪逻辑3"啲.个可判定子集。除了知识表示以外，描述逻辑还 用在其它许多领域，它被认为是以对象为中心的表示语言的最为重要的归一形式卩叫描 述逻辑的重要特征是很强的表达能力和可判定性，它能保证推理算法总能停止【2%并返 回正确的结果。在众多知识表示的形式化方法中，描述逻辑在十多年来受到人们的特别 关注，主要原因在于它们有清晰的模型-理论机制，很适合于通过概念分类学來表小应 用领域，并提供了很多有用的推理服务。基亍这些特点，很多本体描述语吉都以描述逻 辑为基础。基「描述逻辑的本体，可以用如卜-公式进行表示：O=(T,A)o K'I'T表小概
念和关系集合，A表示断言集合。描述逻辑的语义是通过模型论来定义的，模型论形象 的说明了语法和领域模型的关系。
描述逻辑作为一阶逻辑的可判定子集，与一阶逻辑的对应关系如表所示：
表2-1 DL与FOL关系表
描述逻辑	—阶逻辑
概念	一元谓词
角色	二元谓词
实例	常量
构子	逻辑连接词、函数

根据表2-1的对应关系以及一阶逻辑公式的定义，Borgida提出了描述逻辑到一阶 逻辑的翻译。(a),为了简便，在一阶逻辑下依旧写成a。又如概念C,到一阶逻辑下应 该表示o(C(x)),省略翻译符号E这样表示对推理并无影响。
表2-2 DL与FOL翻译表
概念/角色/构子	描述逻辑语言	一阶逻辑语言
原子概念	C	C(x)
角色	R	R(x,y)
个体	O	a
合取概念	CnD	C(x)aD(x)
析取概念	CuD	C(x)vD(x)
否定概念	-C	「C(x)
存在概念	3RC	3y(R(x,y)AC(y))
任意概念	VR.C	Vy(R(x,y) — C(y))
定性数堇值概念	<nR.C	力1 …珈(yi * yj a R(x, y) a C(y)) Vjl ??-Vj/w((yi 产 yj	->R(x,y))a C(y))
概念包括、等价	CcD
C = D	Vx(C(x) -> D(x)) Vx(C(x) o D(x))
角色包括、等价	RcS
R = S	VxVy(R(x, y) -> S(x, y)) VxVy(R(x,y)0S(x, y))
概念断言	c⑶	C(a)
角色断言	R(a,b)	R(a,b)

本论文利用上表的转换规则来将描述逻辑翻译成一阶逻辑子句。
2.2.2本体推理器Hermit
Hermit本体推理器⑵必］是一个开源的java本体推理库，给定一个OWL本体文件， 通过Hermit可以快速验证本体文件是否一致，除此之外，还有根据已有的类关系推出 间接的类关系等功能。本体推理主要基于描述逻辑，描述逻辑是一阶逻辑的可判定子集。 Hermit的实现基于著名Hypertableu算法，提供了比以往任何本体推理器更快的推理能 力，把本体的分类时间从小时级提高到秒级，同时也是第一个能轻松分类以往一些被证 明是对任何推理系统都非常复杂的本体的推理器。
Hermit釆用OWL API编写，也是Web语义本体编辑软件Protege的默认推理器。 Hermit提供了多种对本体的加载接口，包括文件和输入流，其实质是先通过0WL API 的接口加载本体文件为一个本体表示对象，然后基于本体表示对象生成一个推理器，在 推理器的初始化中，会将本体表示对象的属性、关系翻译成DLClause对象，每一个 DLClause都对应一个关系或者属性。本论文通过分析Hermit的开源源码，得到Hermit 在处理OWL文件时的中间结果DLClauses,这样避免了手工加载解析和翻译OWL的 任务，方便处理成一阶逻辑的形式。
2.2.3理论求解器Z3
Z3是微软公司开源的一阶逻辑推理库，是目前最好的SMT求解器【24-25】之一，它支 持多种理论，主要的用途是软件验证和软件分析。Z3的原型工具参加了 2007年的SMT 竞赛，获得了 4个理论的冠军和7个理论的亚军，之后在陆续参加的SMT竞赛中获得 大多数理论的冠军。目前Z3已经被用于很多项目，比如Pex、HAVOC、Vigilante. Yogi 和 SLAM/SDV 等。

图2-2 Z3结构图
Z3的Simplifier采用了--个不完金，但是高效的简化策略回。它的Compiler是将 输入转换成内部的数据结构和congruence-closure |J点。CongruenceClosure Core接受来 自SAT solver的赋值，然后处理EUF和相关组合理论，它采用的方式称作 E-matching"28】。Theory Solver 主要包含 4 种：Linear arithmetic、BV、Arrays 和 Tupleso 理论求解器是建立在congruence-closure算法㈣上的，这也是日前大多数SMT求解器使 用的方式，也就是说，congruence-closure可以看作核心求解器，各个理论求解器是外围 求解器。
在Z3提供的Java API中，维护一个Context的概念。Context是一个类似封闭空间 的概念。可以通过Context定义Solver对象和创建BoolExpr对象，所有BoolExpr对象 表示的是一个布尔概念，只有两种取值：真和假，同时BoolExpr可以由多个Expr对象 通过与、或、非等方式组合起来表示复杂的表达式。Solver对象是用来推理和证明满足 性的主类，所有生成的BoolExpr都需要添加到Solver中，并且所有添加到Solver中的 BoolExpr是以并的形式进行推理的，调用Solver的check接「1可以得到当前整个Solver 中所有的BoolExpr的合取范式是否为真。
Solver有一个栈的概念，可以维护BoolExpr加入的顺序。后面加入的BoolExpr在 栈的上层。在任何时刻，Solver可以调用push。方法，在此后，如果Solver调用pop接 口，则会将上一次调用push()时到当前所有加入的BoolExpr移除。此方法可以更加高 效的利用Solver的推理功能，因为可能需要频繁的添加和移除BooExpro利用Z3的一 阶逻辑推理功能，可以快速验证已有一阶逻辑的可满足性，从而推出条件是否可满足。 进而推知目标条件是否成立，从而做出相应的反馈。
2.3语义库Jena
Apache Jena是Apache的--个开源的用于开发语义Web和Linked Data的Java框架。 此框架包括许多用于处理RDF数据的APL Jena提供丰富的本体处理API,方便使用 者加载，解析，生成本体文件，同时支持多种格式。OWL是知识表示形式，但是文件 载体可以是多种格式，在Protege的OWL本体生成保存格式中就包括RDF、OWL等多 种格式。Jena全面支持各种文件类型。
整个框架的的结构如图2-3所示：

图2-3 Apache Jena语义框架

2.3.1文件数据库TDB
TDB是Jena的一个组件，是~个基于文件系统的存储库。支持各种形式的Jena API 查询，提供非常高的性能。在本项目中，采用TDB作为持久化层，已有的本体文件通 过Jean提供的API存入TDB文件中。TDB同时结合了 Jena的ARQ SPARQL引擎，可 直接支持SPARQL查询。在TDB中，数据是以文件的形式持久化的。数据以数据集的 形式组织，每个数据集对应一个文件目录，这样可以以数据集的形式来实现知识库。
2.3.2 SPARQL查询语言
SPARQL[30]是W3C制定的一个语义网标准协议，是Web上或在一个RDF存储(RDF store)中查询和操作RDF图相关的一组推荐标准。它是在以前的比如rdfDB, RDQL 以及SeRQL的基础上开发的,W3C的官方文档对SPARQL有非常详细的介绍。SPARQL 将RDF看作一个数据图的形式，数据之间关系用Triple三元组⑶】的形式表示。SPARQL 包括 IRK literals lexical fornix plain literals language tag> typed literal、datatype IRL blank node等概念。在RDF模型中，基本对象是资源、属性和陈述。-个特定的资源 陈述由主体(subject)，谓词(predicate),客体(object)组成。SPARQL查询语言是基『图模 式匹配实现的，最简单的图模式是三元组模式，复杂图模式由简单图模式组合而成mi,
常见的复杂图模式是基本图模式、组合图模式、川,选择图模式、联合图模式、RDF数 据集图模式、值约束条件六种模式中的?种。
通过定义SPARQL查询语句，实现了 SPARQL协议的查询引擎可以返回三元组形 式的结果，并且在标准的SPARQL查魂结果XML格式［SPARQL-XML-Result］之外， SPARQL 1.1还提供了三种常见的格式来表达查询结果，即JSON、CSV (逗号分割值) 及TSV (制表符分割的值)。当前众多的语义Web库都对SPARQL有支持，例如Jena ARQ、SPARQL4J. Pellet 等等。
本论文采用SPARQL作为知识的查询语言，利用Jena的SPARQL引擎ARQ实现 对知识库的查询。首先要根据查询需求生成String类型的查询语句。然后利用工厂类 QueryFactory类的方法根据String类型的查询语句生成Query查询语句对象，然后再利 用Jena抽象工厂对象QueryExecutionFactory的create方法生成查询执行对象。生成执 行对象之后调用其exexSelectQ方法可获取查询结果，查询结果是Jena的结果集ResultSet 对象。ResultSet对象是一组三元组的集合，包含了查询语句返冋的所有三元组信息，通 过其提供的迭代器接口可以遍历这些三元组并进行相应的处理，也可以通过其 getResourceModel接口得到结果集的Model对象表示。
2.4发布订阅系统
发布订阅是一种信息发布模式，其中有两种角色，发布方和订阅方。消息的发送者 (publisher)不需要知道消息的接收者，只要在发布消息之时指明消息的标记类别，并将 消息发布到统一消息空间。相应的，消息的接收者只需指明消息的类别，当此类别的消 息被发布时，统一消息空间会将其发送给所有的此类消息的订阅者。发布订阅技术是一 种一对多的分布式消息中间件，其基于主题的形式有效的将发布和订阅两方解耦。已有 的基于主题实现的发布订阅系统内部就已经定义了许多的主题。这些主题在发布系统之 中都是以主题树的形式存储的，主题与主题之间是父子关系，如果向发布订阅系统订阅 了-个父主题时就会默认的不处理此父主题对应的所有子主题。发布订阅系统能够基于 事件收发消息，有非常好的耦合特性，是大规模分布式系统建立的有效方式。
发布订阅系统的核心技术是事件分发机制，具有高吞吐率、同时支持离线数据和实 时处理等特点。消息是通信的基本单位。由消息生产者(producer)发布关于某话题(topic) 的消息，此消息以一种物理方式被发送给了作为代理(broker)的服务器(可能是另外 -■机器)。若干的消息使用者(consumer)订阅(subscribe)某个话题，然后生产者 所发布的每条消息都会被发送给所有的使用者。发布订阅是个显式的分布式系统—— 生产者、使用者和代理都可以运行在作为一个逻辑单位的、进行相互协作的集群中不同 的机器上。
2.5 Echarts
Jetty是一个开源、基于标准、性能非常优秀的Servlet容器，并为基于Java的web 内容，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一 组JAR包的形式发布。开发人员可以将Jetty容器实例化成…个对象，可以迅速为一些 独立运行(stand-alone)的Java应用提供网络和web连接。Jetty可以用来作为一个传 统的web服务器来处理静态和动态网页，或者作为一个专用HTTP服务器的后台来处 理动态网页，就像Apache使用mod_proxy作为一个JAVA应用程序的内嵌组件。这种 灵活性意味着Jetty可以在多种场合使用。Jetty的特点是简单，Jetty的指导原则是“简单 不复杂% Jetty容易理解和使用,通过API或者XML文件配置，XML文件语法直接 了当地在POJOs上影射API操作，默认的配置文件可以使Jetty作为外盒(out-of-the-box), 只需少量行数的代码就可以嵌入一个Jetty实例。在异步的WEB2.0类型的应用程序中， 使用的技术，例如AJAX,连接停留时间要比处理一个静态页的时间长，线程和内存需 求可能急剧增长，底层必须优雅地处理这些问题。使用Jetty在高强度服务压力性能损 失少，在现有的web规范的框架下，能处理大用户负载，保证长时间会话的连续性。Jetty 是一个非常好的Web组件，很容易嵌入到一个应用程序中，适合用于轻量级的应用程 序之中。	，
ECharts, 一个纯Javascript的图表库，可以流畅的运行在PC和移动设备上，兼容 当前绝大部分浏览器(IE8/9/10/11, Chrome, Firefox, Safari等)，底层依赖轻量级的 Canvas类库ZRender,提供直观，生动，可交互，可高度个性化定制的数据可视化图表。 ECharts 3中加入了更多丰富的交互功能以及更多的可视化效果，并冃对移动端做了深 度的优化。ECharts提供了常规的折线图，柱状图，散点图，餅图，K线图，用于统计 的盒形图，用于地理数据可视化的地图，热力图，线图，用「关系数据叮视化的关系图， treemap,多维数据可视化的平行坐标，还有用于BI的漏斗图，仪表盘，并且支持图与 图之间的混搭。很多时候可能数据需要异步加载后再填入，ECharts中实现异步数据的 更新非常简单，在图表初始化后不管任何时候只要通过jQuery等工具异步获取数据后 通过setOption填入数据和配置项就可完成,Echarts会自动更新图表的数据并刷新界面。

2.6本章小结
本章主要对课题中涉及到的相关技术进行了介绍，为后续设计和实现部分打下基础。 首先介绍了语义Web相关知识，包括本体的定义，本体的描述语言和本体的构建工具。 其次介绍了本体的基础描述逻辑以及描述逻辑和-阶逻辑的关系和转换规则、基于 Hypertableu算法的Hermit本体推理器对本体的加载和分类机制、一阶逻辑推理库也即 微软公司的理论求解器Z3的相关信息及其主要功能和原理。随后讨论了语义Web框架 Jena,讨论了 Jena的文件数据库TDB和RDF查询语义SPARQL。最后介绍了物联网系 统的知识子系统中使用的发布订阅消息转发系统的机制。
第三章系统需求分析
本论文设计的知识子系统，构建在物联网系统基础之上，主要用于管理物联网已有 的资源模型等知识，并结合物联网系统已有的发布订阅子系统，为物联网系统用户提供 事件处理能力。
本章将需求进行细化，根据整个知识子系统的使用流程将知识了系统分为不同的功 能模块，将研究内容融入到整个使用流程之中，从系统的功能性需求和非功能性需求共 两个方面进需求分析。
3.1系统功能性需求分析
本论文重点是以模型为基础，结合事件駆:动模式和逻辑推理，设计和实现一个处理 能力强大，低耦合、高复用的物联网知识子系统。本论文所论述的物联网知识子系统搭 建在物联网平台上，需要在已有的物联网资源框架基础上设计并实现一个统一的物联网 系统知识子系统。在既有物联网知识子系统基础上，需要实现知识发现和知识抽取等动 态知识管理功能，即基于物联网资源模型，对实时事件流进行处理，计算隐蔵在资源模 型和事件背后有价值的复杂事件。
基于知识子系统的设计目标，系统功能主要包括知识管理和事件推理两大功能需求, 知识管理包括物联网资源模型与实例的管理、事件的知识定义、事件与资源的知识映射 管理、以及抽取的复杂事件知识管理。提供面向用户的知识增、删、改、查，这包括图 形化知识建模、知识存储、基于图的知识查询，片通过增加中间索引层，完成用户可视 化知识与底层存储的本体知识的分门别类的关联。事件推理包括设计与实现多推理单元 的并发调度、资源实例工作范围发现、资源实例与推理单兀的映射、事件的知识转化、 事件与推理单元的映射、目标事件的知识化、以及基于SMT证明的冃标事件发现。
以下进行各个模块功能性需求分析。
3.1.1用户接口定义
用户界面主要包括两大功能，一个是为了方便管理者与使用者利用已有的物联网资 源知识，需要提供面向用户的知识增、删、改、查，通过在已有的知识管理基础上，通 过增加中间索引层，完成用户可视化知识与底层存储的本体知识的美联，将诉件处理H 标与已有知识关联起来。
用户界面的另个功能则是提供用户'走义事件处理目标的功能，事件处理目标定义 功能主要涉及推理LI标(也即目标事件)定义，推理目标定义需要与事件以及资源模型 结合起来，所以在用户目标定义界面提供的选项需要与知识库中的信息相对应，因此这 需要后台提供映射功能，将I I标中的信息映射为知识库中相关的信息。用户在前端选择 相关的领域，并定义目标条件的参数，选择相关域的约束算子，然后输入参数值。完成 推理目标的定义之后，将请求送往服务器后台进行处理。服务器后台会根据推理目标进 行相关操作，包括分析推理冃标的事件接收主题来接收相关的实时的领域事件、对事件 进行推理处理并将推理结果写入数据库等操作。事件的推理结果需要在用户界面进行相 关的展示，因此需要响应用户的推理結果展示请求，将结果在界面以图表的形式动态的 展现出来。在Web前端推理界面，在用户提交了推理请求之后，用户可以选择推理结 果展示，这会触发结果展示功能，每隔一定时间通过Ajax技术向后台请求获取推理结 果，后台会对请求进行响应，获取推理结果信息后更新用户界面从而动态的展示结果。 例如，结合本课题使用的深圳出租车GPS数据，用户可以定义道路拥堵的条件：选择 相关的领域，包括选择具体道路、缓速定义、最少数据量、拥堵程度等，缓速定义表示 速度在多少之下可视为缓速，最少数据量表示至少需要在当前道路上观测到的数据，拥 堵程度则有严重、中度、轻微等情况，比如严重拥堵可以视为80%的车是缓速车，中度 拥堵对应60%的车是缓速车，轻微拥堵则对应40%的车是缓速车，通过将这些参数定 义提交给后台，由后台进行相关的处理并存储结果。具体的需求描述如下：
(1)需求划分
基本知识管理包括添加操作、删除操作、备份操作、查询操作。用户目标定义包括 选择领域、约束定义、结果展示，其中约束定义又包括参数选择、算子选择和数据输入。 具体的UML用例图如图3-1所示：


(2)需求描述
A.添加操作：
该功能主要包含添加数据集功能。用户输入要新增的知识库名，选择持久化模式进 行新建。
B.删除操作：
该功能主要涉及知识库的删除功能，在知识库管理界面，用户选择所要删除的的知 识库并确认，从而将选中知识库删除。
C.备份操作：
此功能主要涉及知识库的备份功能，在知识库管理界面，用户选择所要备份的的知 识库并确认，从而将选中数据集备份。
D.査询操作：
该功能主要涉及对知识库查询功能，采用SPARQL查询语言实现对本体的査询功 能，针对某一知识库，通过编写SPARQL査询语句，返回对应的知识信息，完成查询 功能。
E.选择领域：用户可以从领域选项中选择某一领域，然后会自动根据用户选取的 领域从后台知识库获取目标定义信息渲染界面，主要是选择目标定义选项。
F.约束定义：
■用户可以在界面上展示的选项中进行操作。
■对「简m的参数输入，选项给予-定的范围选择。
■对「复杂的函数选项，选项提供用户友好的函数命名。
G.结果展示：用户点击结果展示按钮之后，利用Ajax动态的获取后台推理结果， 并实时的将结果展示给用户。
3.1.2知识库的组织管理
结合本章研究内容，知识库是本课题的基础模块。事件的处理需要结合已有的知识 和规则，这需要把物联网资源模型与实例、事件知识管理起来。首先需要对资源建模， 建模分为两部分，一个是对物联网资源、环境的建模，一个是对物联网动态事件的建模。 物联网资源环境是静态的，变化比较少，所以可以提前建立好资源模型，而事件是动态 的，随着时间的改变事件很可能会发生改变，因此需要能够动态的反映事件变化的机制。 根据物联网资源环境静态特点，可以采用本体来建模表示，而物联网事件是异构的、动 态变化的，每个事件都包含事件的属性，领域等信息，所以事件建模需要采用动态的建 模表示，要能够有效的处理事件的异构性、多样性等特性。例如结合本课题使用的深圳 出租车数据，事件包含名字、时间、经度、纬度、车速、方向、空车与否等字段，可以 通过编码实现对应的事件抽象类来表示事件，事件类包含事件对应的字段，如果为空则 对应字段不存在，同时结合面向对象的思想，对于同一领域的事件可提供抽象父类接口 来提取事件公共的字段，提高代码可重用性。
在实现资源和事件的建模之后，需要依据领域信息将已有的模型进行分类、管理， 便于用户的查询和使用。同时，由于本课题利用一阶逻辑推理来进行事件的处理，事件 的处理方式由用户定义的目标来决定，而用户定义的目标由多个约束组成，这些约束多 种多样，所以为了方便用户的使用，需要提供基本的算子函数来方便用户定义约束。这 些算子函数也是知识的一部分，所以也需要管理起来。知识库的管理需要根据特定的领 域进行分类，同时要兼顾知识领域的大小，不能划分过大，这样会导致一个知识库里的 知识过于庞大，从而导致管理和查询时的系统运行负载过大而使效率降低，因此在领域 划分的同时需要兼顾领域的大小，做--些权衡，使得每个知识库只包括特定领域内的信 息。对于本体知识库，由于知识都是以本体文件的形式保存，所以关键是对本体文件进 行分类管理。对于事件和算子知识库的管理，由于事件和算子最终都是以代码对象的形 式存在，所以只需结合面向对象的编程思想和设计模式，将事件类和算子以代码形式实 现，并提供映射机制，将事件和算子映射到具体的对象和函数。
结合以上分析，知识管理功能需求用例图如下图3-2所示：


图3-2知识库管理模块用例图

3.1.3事件接入
物联网平台最重要的特点就是事件，在前面提出了基于模型的事件推理机制，使得 推理功能具有了事件驱动的特性。但是推理本身是不具有所要订阅的一些事件和主题的, 因此这就需要一个可以提供获取主题和事件的模块。已有的基于主题实现的发布订阅系 统内部就已经定义了许多的主题。这些主题在发布系统之中都是以主题树的形式存储的， 主题与主题之间是父子关系，如果向发布订阅系统订阅了一个父主题时就会默认的不处 理此父主题对应的所有子主题。发布订阅系统能够基于事件收发消息，具有非常好的耦 合特性，是大规模分布式系统建立的有效方式，所以需要将基于模型的事件推理模块与 发布订阅相连。
在实现推理功能模块与发布订阅系统相连的时候，使用开发的事件接入模块来实现, 也即先使推理功能模块与事件接入模块相连，然后事件接入模块将订阅消息、发布和取 消订阅等消息中转，通过消息发送给发布订阅系统。虽然目前推理功能模块中Client 的数量比较少，理论上他们直接与发布订阅系统相连实现，实现订阅、收发消息是可以 的，但是当Client数量很多，多个事件处理服务同时向发布订阅系统订阅或者发消息的 时候就可能因为吞吐量不够，导致系统性能降低，所以釆用事件接入模块中转是有必要 的。除此之外事件接入模块还可以管理订阅者的地址，端口号，这主要是为客户端查询 订阅者地址提供方便，还可以实现对订阅主题进行管理，它可以从WSN发布订阅系统 那边获取主题树，如果事件接入模块服务所订阅的主题在发布订阅中不存在，那么事件接入模块会创建相应的主题，并且发布订阅系统那边也会添加相应的主题满足订阅者的 需求。图3-3为系统对推理功能模块与发布订阅系统相连的用例图。

图3-3数据接入用例图

3.1.4基于推理的事件处理
结合前面的分析，用户的推理目标在前端定义完成之后，会通过HTTP请求的形式 到达后台服务器。因此，我们需要根据HTTP请求参数生成目标对象。此目标对象包含 领域信息、推理范围、推理约束等信息。领域信息主要包括订阅的事件主题，主要用于 事件的订阅。推理范围则是指推理涉及的范围信息，对应了知识库中的知识实例。推理 约束则是目标参数以及相应参数的数值约束，其中参数约束主要包括最大值约束、最小 值约束、均值约束、比例约束等等，对应了相应的计算函数算子。通过目标解析，将用 户推理目标进行处理，最终会成为SMT理论求解器中的一阶逻辑表达式，并生成相应 的推理对象，一个推理对象对应一个一阶逻辑表达式。当推理请求中包含多个推理目标 时，需要生成多个推理对象，每个推理对象负责推理一个推理目标。
本模块的主要子功能包括推理目标转化功能、推理对象生成功能、事件推理功能以 及结果处理功能。用例图如图3-4所示：

图3-4逻辑推理用例图

在实现了事件接入的功能之后，需要将事件进行转化处理。结合前面的分析，对于 每一个新来的事件，为了拿到与事件相关的领域信息，需要分析事件自身携带的信息。 因此，需要提前对事件进行建模，釆用事件模型来描述事件包含的各个字段信息，包括 事件发生的时间、地点、环境等信息。利用这些事件信息描述，可在事件到来时将事件 转化成事件对象。图3-5是事件转化用例图。	“

因为目标推理需要有一定的推理范围，只有在推理范围内的对象才被推理，而不在 此范围内的事件则不被考虑，因此需要利用已有的知识来判断事件是否在推理范围之内, 这就涉及到范围包含的概念。范围包含的关系可在本体模型中定义好，通过将定义好的 本体知识转化一阶逻辑形式，然后将事件映射的知识对象与目标知识对象同样转化为一 阶逻辑表达式，并利用推理判断事件是否属于目标推理的范围。如果是则继续处理，如 果不是则将事件对象和转化生成的知识对象销毁，这样不仅可以过滤无用事件，同时可 以为系统节约内存，从而提高事件的处理性能。范围推理用例图如下所求：


如图所示，对事件进行范围推理之后，如果一个事件经过包含推理证明属于某推理 对象的推理范围之内，则将事件对象和事件对应的知识对象一起交给推理对象进行推理, 同时更新推理结果，并将推理结果存储到设计好的数据库中，以便后续结果展示时获取。
3.2系统非功能性需求分析
响应速度：系统要求能够在用户可以接受的时间内对用户提出的网络请求进行 响应。其中关键的性能指标包括知识库的查询性能和事件的推理处理性能。
可使用性：系统要求容易使用，界面友好，能够尽可能的符合用户的操作习惯。
并发性：系统能够同时支持多个用户进行使用，并支持多个目标进行推理。

3.3本章小结
本章在前两章研究背景和相关技术介绍的前提下，介绍了基于物联网平台的知识子 系统的需求分析。主要介绍了用户接口、知识库的管理和查询、与发布订阅的互连、基 于模型的一阶逻辑推理等需求。从功能性和非功能性两个角度，分析了系统的主要需求, 为后续的设计和实现提供了明确的目标。

(C) 1994-2022 China Academic Journal Electronic Publishing House. All rights reserved.


第四章 系统概要设计
4.1系统架构设计
本论文在前面章节介绍的相关背景以及相关技术基础之上，提出了可行性的需求分 析。针对上章所述的系统提供的主要功能，本章对各个模块进行概要设计。
物联网知识子系统搭建在物联网平台之上，结合发布订阅子系统进行事件接入，并 基于已有的物联网资源框架进行建模。通过对资源模型进行分门别类的管理，提供方便 的查询功能，同时结合一阶逻辑推理提供事件处理功能。
用户使用本系统的基本流程为：用户使用用户界面定义目标，然后后台会解析用户 定义的目标。解析用户目标会首先根据事件主题信息订阅事件，然后根据用户定义的推 理范围查询知识库获取与范围相关的本体知识，利用这些本体知识转化生成相应的一阶 逻辑表达式，并生成相应的范围推理器对象，范围推理器对象利用这些 阶表达式来进 行范围推理，最后利用目标中的约束信息生成目标一阶逻辑表达式，并生成相应的目标 推理器对象，用于验证目标是否成立。目标解析完成之后开始接收事件，每当订阅的事 件到来时，依据事件的领域信息获取事件模型并解析事件，然后生成事件对象。利用范 围推理判断事件是否是在推理的范围之内，如果属于推理范围之内则将事件和与之相关 的知识处理成一阶逻辑表达式，反之则不予处理并销毁对象。最后，将此一阶逻辑表达 式与目标…阶逻辑表达式一起利用目标推理器进行推理证明，根据目标能否被证明来对 事件进行相应的反馈，并进行结果的存储。推理完成之后，再将结果渲染呈现给用户。
是于以上流程，本论文将知识子系统分为用户接1丨、知识管理、卵:件接入、推理四 个模块。图4-1是系统架构图。

图4-1系统结构图

从功能角度分析，此系统各模块需要实现以下功能：
1）	用户接口，用户接口主要提供用户一个直观的使用界面。主要包括知识的基本 管理和目标事件定义两个功能，提供面向用户的知识增、删、改、查，通过增加中间索 引层，完成用户可视化知识与底层存储的本体知识关联。
2）	知识管理模块，知识管理模块包括物联网资源模型与实例的管理、事件的知识 定义、事件与资源的知识映射管理、以及抽取的复杂事件知识管理，其功能包括图形化 知识建模、知识存储、基于图的知识查询。
3）	事件接入模块，需要实现数据的接入功能，在已有的发布订阅消息中间件的基 础上实现事件的主题订阅、主题取消、事件转发、事件对象生成等功能。为了获取事件， 需要和发布订阅系统连接，从WSN获取主题树信息，判断订阅者订阅主题是否存在， 如果不存在可以及时建立主题以待订阅，获取主题之后根据订阅的主题列表获取事件。
4）	推理模块,实现知识发现和知识抽取等动态知识管理，即基于物联网资源模型， 对实时事件流进行处理，计算隐藏在资源模型和事件背后有价值的复杂事件。这包括目 标事件的解析、事件的知识转化、事件与推理单元的映射、资源实例与推理单元的映射、 资源实例工作范围推理、多推理单元的调度以及基于SMT证明的目标事件发现。
下面进行各功能模块的概要设计。
4.2用户接口概要设计
用户界面模块提供用户一个直观的Web用户界面，用于定义推理目标、推理结果 展示和简单的知识库査询管理，因此包括前端和和应用后端两部分。结合需求分析，前 后端的的交互主要釆用Json数据格式，同时由于本应用属于轻应用，所以选择Jetty作 为Web后台。
用户可进行的基本的知识管理操作包括知识库的添加、删除、备份和查询操作。通 过在界面提供相应的页面和功能实现，用户的操作会经过处理发送到后台，然后后台根 据操作的不同进行相应的响应。基本流程图如图4-2所示：

图4-2前端基本管理流程图

推理目标界面主要提供用户参数的可选输入项，用户通过选择这些参数项进行目标 定义，这些参数与知识库中的概念实例相对应。

在用户界面规则定义界而，首先用户选择知识库，将知识范围限定在选中的知识库 中。然后，为了将事件与知识库中的知识映射起来，需要进行知识对象和事件之间的映 射定义，系统提供…些用户可以选择的映射机制，系统会根据用户选择的选项采取不同 的映射机制，这样动态的可以事件与知识库中对象映射起来。与此对应，在用户界面， 用户接口会根据用户选择的知识库获取知识库中的知识对象，以列表的形式供用户选择。 事件方面，用户可以选择领域信息，此领域信息包含事件主题，接口会根据此主题信息 获取事件的schema,然后渲染界面提供事件的一级属性供用户进行绑定。比如可以将 出租车的数据映射到知识库中的位置Position概念，此机制需要后台相应的实现，并在 前端只提供用户绑定的对象名称和属性。
在绑定了事件与知识对象之后，用户需要选择事件的推理范围，只有属于推理范围 内的事件才需要进行处理，比如可以选中某一条具体的道路实例作为推理范围来推理此 道路是否拥堵。系统同样会根据用户选择的知识库提供用户相应的选择列表，比如用户 选择traffic知识库，提供的列表只会包含traffic知识库中存在的道路实例名，请求提交 之后系统会自动根据选择的道路实例名查找知识库获取相关的信息。
结合需求分析和实际需求，为了利用一阶逻辑推理来处理事件，目标事件的组成还 需要提供相应的参数以及参数的约束。对于具体的道路，用户需要定义拥堵事件的参数。 例如，数据最小个数、缓速的临界值、缓速车量占观察车量的比例等。用户选择这些相 关选项和输入参数之后，接口会将推理请求提交发送到后台，系统后台会将其解析生成 一阶逻辑推理器Z3中的一阶逻辑表达式，然后利用推理证明的方式来验证这些条件是 否成立，如果成立则意味着拥堵。
用户定义目标的流程图如下图4-3所示：
开始
选择领域信息
目标参数设置
定义相关目标约束
提交推理请求
结束
图4-3目标定义流程图
例如，结合本课题使用的深圳出租车数据，用户可以定义如下目标：首先选择特定 的道路作为推理范围，然后定义道路拥堵的条件，如设置当前道路上缓速车量占比达到 一定比例可视为拥堵条件，这其中缓速车的数量与占比的比例数值均是构成目标的约束 条件。
定义好推理目标之后，用户提交推理请求，推理目标携带id提交到后台进行推理， 处理结果存储在MongoDB数据库中，同时附上用户此次推理的唯一标志ido
处理结果的呈现：对于处理结果的呈现，用户界面采用轮询的方式向平台后端发送 请求，请求包括推理时提交的唯一 id,系统后台每接到数据请求时就利用此id从 MongoDB数据库获取结果并返回给用户界面。用户界面将返回来的处理结果利用开源 的图形库渲染界面，过一段时间再次对后台提交请求结果。图4-4是结果展示流程图：


图4-4结果获取流程图

如上图所示，前端采用轮询的方式获取结果数据,如果有结果返回则更新前端界面， 如果没有结果返回则结束获取流程。
4.3知识管理概要设计
结合上一章的需求分析，知识管理模块主要涉及资源建模和知识库的管理以及查询。 首先，需要对物理资源环境进行建模，本课题釆用本体来作为模型的载体。用本体描述 语言来描述资源环境的属性关系。本体是实现信息交换、共享及解决语义冲突的基础。 通过构建统一的概念和术语，为同一领域的异构事件的互操作和集成提供了可能。
领域模型的构建需要把领域相关知识转化为本体描述语言来表示。因此，本体知识 建模包括两个子需求，本体的构建方法和本体的构建工具的选择。本体的构建方法有许 多种，但目前还没有一个标准的方法。相关文献中提出的方法共有八种：骨架法、 METHONTOLOGY法、IDEF5方法、七步法、CYC方法、TOVE方法、KACTUS方法、 SENSUS方法。同时建模工具也多种多样，有斯坦福大学的Protege. OntoEdit、OilEd 等。本课题在模型的构建方法上选择七步法，并且选择Protege作为本体的构建工具。
模型的构建首先要对现实的需求说明，包括确定本体和范围，获取领域知识。然后 要将现实知识抽象化，包括定义类及其关系、实例化。最后是利用工具将描述好的模型 建立。本体建模流程图如图4-5所示：

结合本课题使用的出租车数据，为了推理道路拥堵的状态，需要将GP%数据与道 路环境结合起来，因此需要对道路进行建模，由于道路的范围过大，因此可驀道路分多 个位置概念，将位置定义成长方形的概念，并为其定义四个数据属性。道路对应本体中 的一个类概念，位置同样对应本体中的一个类概念，两者之间是包含关系，同时道路与 位置都对应有多个实例。
本论文釆用Protege本体编辑软件作为建模工具，建模界面如下图4-6所示：


彩 hasY2 exactfy 1 xtAdouble 8 h??Yl e<??.tiy 1 x“:doubU -hasXZ ???<*<> 1 >ad:double hasXl exacSy 1 x*d:douM?
图4-6 Protege建模图
将前述模型涉及的概念通过Protege建模描述起来，然后保存成本体文件，由于 Protege是根据w3c标准开发的，因此此文件符合W3C的标准定义，可釆用大部分的语 义编程库进行处理。本体文件部分截图如图4-7、4-8、4-9所示。
owlsObjcctProperty rdf:aboutssMhttp://www.semanticweb.org/traffic-ontology#hasPo$ition°> <rdfs:damain rdf;resources,,http://www.semanticweb.org/traffic-ontology#Road"/> 〈rdfs;range rdf:resource^http://ww.senanticweb.org/traffic-ontology#Position,7> </cwl:0bjectProperty>
<uwI;DacatypeProperty rdf:abouts',http://www.senanticweb.org/traffic-ontology#tiasxi*7>
<owl；Datatypeproperty rdf:aboutsMhttp://www.semanticweb.org/traffic-ontology#tiasX2*7>
isDatatypeProperty rdf:about3**http://www.semanticweb.org/traffic-ontology#hasYlM/>
owl:DaratypeProperty rdf:about=uhttp://uw. sesanticveb. org/traffic-ontology#hasY2"/>
owijClass rdf:about='*http://www. semanticweb.org/traffic-ontology#Position°>
-- <cwl:equivalentClass>
<owl;Restriction>
<cwl:onProperty rdf: resource="http://www.semanticweb.org/traffic-ontology#hasXl'7> ccwlzqualificdCardinality rdf：datatype=',http://www.w3.org/2001/XMLSchema#nonNegativeInteger,'?l</cwl:qualifiedCardinality> <cwl:onOataRangc rdf; resources*,http!//www.w3.org/2fl01/XMLSchema#double**/>
</Qwl:Restrictlon>
</owl:equivalentClass> ?GwliequivaIentClass> owl: Restriction*
<cwl:onPrcperty rdf:resource=Mhttp://www. semanticweb.org/traffic-ontology#hasX2,7>
<owl:qualifledCardinality rdf：datatype=,,http://www.w3.org/2001/XMLSche<na#nor^legativeInteger,'>l</cwl,:quali.fledCardinality> <owl:onDataftange rdf:resource="http://www.w3.org/2001/XML5chefna#double"/>
</cwl:Restriction>
</owl:equivalentClass>
<owl:equivalentClass>
?owl:Restriction>
<owl:。「Property rdf: resourckhttp://www. senanticweb.org/traffic-ontology#hasYl"/>
<owl equal if iedCa rd inality rdf:dat3typesMhttp://www.w3>org/2081/XMLSchemd*nonNegativeInteger">l?Vcwl:qualifledCardinality> <owl:onOataRange rdf:re sou rces"http://www.w3.o rg/2e01/XMLSchema?doubleH/>
图4-7本体模型部分截图

<cwl：C1ass rdfxabout^'httpt/Zwww.seaanticweb.org/traffic-ontology?PositlonM>
owl: equ ivaUntCla$s>
<cwl: Restriction
<cwl:onProperty rdf: resource^httpt/Zwww.seaanticweb.org/traffic-ontologyfhasXlnA <Gwt:quallfie<iCardlnaUty rdfsdatatype*1*http://ww.w3.org/ZBBl/XHLSchenafnonNegativelntegef^lK/owUqualifiedCardlnality* ?cwl:onOetaRange rdf:resourcea**http://MM.w3.org/2001/)01LSchea3MoubleM/>
^/owl:Restrlcticn>
</cwl;equivalentCUss>
<wlt equ iwa UntC Us $> <owl:Restriction*
<owl:onProperty rdf: resource^'http:/Amw.se?antlcweb.org/trafflc-ontology?hasX2'7>
<owl:qualifie<lC?rdinaUty rdftdatatyp^httpsZ/ww.wa.org/ZOei/XMLScheaaifnonNegativelnteger^^/owljqualifiedCardinality* <cwl:onOataRange rdf: resourcea**http://ww.w3.org/2001/)91LScheaaMoublea/>
</owl:Rest riction>
</owl:equivalentClB5S> <ow\:equlvalentClass> <owl：Restriction?
<owl:onProperty rdf: resource?*http://??**.seaanticweb.org/trafflc-ontology?hasYln/>
<awl:qualifie(fCardln4lity rdf:datatype?'*http://MM.w3.org/2Ml/XMLSche?a*nonNegativeInteger**>l</Qwl:qualificdC<>rdlnelity> <owl:onDataRangc rdf:resource***http://ww.W3.org/2Ml/XMLScheo?Mouble*7>
?/owl:Restrictian>
?/owl:equivalentCX?si>
: ecu lvalentCU$$>
<cwl: Restriction
<owls onProperty rtff: resourcea**http: //mm.seoanticweb.org/traffic-ontologyfhasY2**/>
<owltqu?1 ifledCsrdlnaUty rdf:datatype?**http://MM.w3.org/20evXML$cheaa?norNegatlveInteger*'>l</owl:qu3UfiedCdrdlnality> <owl:onDataRange rdf: resource>"http://Www.w3.org/2Ml/XMLSchenaMouble*/>
?/owl:Restriction*
图4-8道路模型实例部分截图
http: //ww. semanticweb? org/t raftic-ontologyW^S中蹬 …>
<owl:NamedIndividual rdf: about=*'http://www. semanticweb. org/traffic-ontology#^S中路“〉 vrdf:type rdf:resource="http://www.semanticweb.org/traffic~ontology#RoadM/> <hasPosition rdf: resource="https//www.semanticweb.org/traffic-ontolcgy#fll中路pl'7> <hasPosition rdf: resource="http://www.semanticweb.org/traffic~ontology#fil中路p2"/A <hasPosition rdf: resources*'http://www.semanticweb.org/traffic*ontology#li3中路p3"/> <hasPosltion rdf: resource=Hhttp://www.semanticweb.org/traffic-ontology#m中路p4*7> </owl:Namedlndividual>
<1— http://ww.secanticweb.org/traffic-ontology#^!中路以一>
<owl:Namedlndividual rdf:about="http://www.semanticweb.org/traffix-ontology蜘中路pl"> <rdf:type rdf: resource=,,http://www.semanticweb.org/traffic-ontology#Position'7> <hasXl rdf:datatypessMhttp://www.w3.org/2001/XMLSchema#decimal">114.0&3391</hasXl> <hasX2 rdf: datatype="http: //www.w3. org/2001/XMLSchema#decimal">114? 08371</hasX2> <hasYl rdf:datatype="http://www.w3.org/2001/XMLSchema#decimaV'>22.545458</hasYl> <hasY2 rdf:datatype=Mhttp://www.w3.org/2001/XMLSchema#decimalM>22.544874</hasY2> </owl:Namedlndividual>
<!— http://www<semanticweb.org/traffic-ontology#?8cllffip2 一>
<owl:NamedIndividual rdf: about=Mhttp://www. semanticweb. org/traffic-ontology#fll中路p2"A <rdf:type rdf: resource="http://www. semanticweb.org/traffic-ontology#Position"/> vhasXl rdf:datatype?uhttp://www.w3.org/2e01/XNLSchema#decimaXn>114.083396</hasXl> <hasX2 rdf:datatype?"http://www.w3.org/2001/XMLSchema#deci!nalM>114.083737</hasX2> <hasYl rdf:datatype="http:Z/www.w3.org/2001/XNLSchema#decimal">22?544632</hasYl> <hasY2 rdf:datatypes"http://www.w3.org/2001/XMLSchema#deciinaV,>22.544073<ZhasY2>
</owl:NamedIndlvidual>
图4-9道路模型实例部分截图二
在此本体文件中，共有路、位置的概念，如前所述，位置有且仅有四个数据属性。 例子中定义了路、位置的实例，共有福中路、红岭中路、翠竹路、金田路等路的实例, 对于福中路有福中路P1、福中路P2、福中路P3、福中路P4四个位置的实例，对应四 个位置属性。
其次，需要对事件进行建模，事件的处理需要分析事件的信息结构，可采用文件 模型的形式来表示事件的schema。本实现釆用json来对事件进行结构描述，每个json 描述一种事件信息结构，包含事件的描述信息。其中，事件的领域信息是必含选项。然 后将所有事件的json进行存储管理。使用事件的领域信息作为事件的标志进行查询。 当事件到来时，利用事件携带的领域信息查询事件知识库获取事件的json schema。然 后解析json schema的各个字段。同时，结合java的多态机制，可以定义一个事件类， 类包含有一个domain属性和一个保存事件结构信息的map对象。利用事件结构信息可 对事件进行处理成为事件对象。同样，删除和更新操作也非常容易实现，只需要删除或 更新map中的对象和对应的json文件即可。
由上所述，本课题将知识库分为两类，一类是通过建模过程对物联网建模的本体知 识，另一类是推理目标所需要事件模型和一阶逻辑函数算子。本体的管理和査询可以直 接基于Jena的TDB文件数据库对进行组织和管理，不同领域的信息存储在不同的知识 库中，可方便的提供知识库的新建，备份，删除以及本体信息存入等功能。本体写入流 程图如下图4-10所小：

图4-10本体写入流程图

如上图所示，本体建模后的本体文件需要写入本体知识库中。首先利用Jena的API 读取本体文件，在Jena之中本体釆用Model类表示，通过调用Jena的工厂方法可以将 本体文件或者文件输入流InputStreamc对象读取为Jena的Model对象。然后利用TDB 的接口获取数据集Dataset对象，Dataset对象是TDB中数据集表示，生成的Dataset的 时候指定了文件夹作为其数据的存储和读取目录，将Model对象写入到Dataset对象中， Dataset会自动完成写入到文件系统的工作，从而完成本体的写入。
除了本体之外的事件模型通过编码基于配置文件进行管理，算子知识则通过编码实 现，包括利用Z3实现的用于不同数据类型的大于、小于、等于等基本函数算子。因此， 在非基于本体的知识库管理方面，主要是对定义好的函数、算子的管理和使用，通过提 供不同工厂方法进行实现，同时可以结合数据库和文件映射等方式进行持久化保存。
在查询方面，因为涉及两类知识类，基于模型的知识库和函数知识库。对于基于模 型的知识库的查询，知识釆用基于文件的TDB进行存储，利用Jena的SPARQL査询引 擎进行查询，对于一个查询，首先要根据查询对象生成具体的SPARQL查询对象，将, SPARQL查询对象交由TDB进行处理，获取ResultSet,然后遍历解析具体的ResultSet 生成返回结果。对于函数知识库的查询，可以釆用映射的形式来实现，本课题当前的实 现是将映射关系维持在文件之中，系统启动时将其加载到内存中的一个Map,方便查询 使用。本体知识库的SPARQL查询流程图如图4-11所示：

图4-11 Sparql查询流程图

如上图所小，首先要根据查询需求生成String类型的查询语句，并获取数据集对 象Dataset。然后利用工厂类QueryFactory类的方法根据String类型的查询语句生成 Query查询语句对象，并根据查询语句对象和数据集对象两个参数生成查询执行对象。 这川,以利用Jena抽象工厂对象QueryExecutionFactory的create方法生成。生成执行对 象?之后调用其exexSelect()方法获取结果集ResultSet对象。ResultSet对象是-、组三元组 的集合，包含了查询语句返回的所有三元组信息，通过其提供的迭代器接口可以遍历这 些三元组并进行相应的处理。也可以通过其getResourceModel接口得到结果集的Model, 利用此Model,结合Jena的文件写入接口，可以将一个Model输出为一个标准的本体 文件，利用此特性可方便的进行语义编程库之间的格式转换。
4.4事件接入概要设计
事件接入模块主要是解决系统中事件的接入问题。所有的物联网事件都存储在发布 订阅系统消息中间件中。数据的订阅模块则负责数据的订阅和过滤功能。基于配置的订 阅模块可以决定订阅哪些主题的信息，当消息中间件中有这些主题的事件出现则交给推 理模块进行处理。如果是向发布订阅系统订阅，就会解析出订阅主题并向发布订阅系统 请求订阅，若是要退出订阅，就会向发布订阅系统请求退出订阅。发布订阅系统受到相 应的请求后会做出响应并返回处理消息。
事件接入模块存储了订阅主题信息供用户查询，同时判断订阅者订阅的主题是否存 在，如果不存在会创建订阅主题。事件接入模块会向发布订阅系统获取主题树，事件主 题是以主题树的形式存储的，在进行匹配时都是从根节点逐渐到子节点开始匹配，直到 找到对应的节点，用户订阅主题、取消订阅和发布事件所用的主题都是从主题树获取， 如果所订阅主题不在主题树中，可以请求建立主题，如果没有建立相关主题，就会订阅 失败。
结构图如图4-12所示。
图4-12事件接入模块结构图

订阅方需要基于需求进行相关主题的订阅，本课题主要是基于用户的目标进行推理 从而实现事件处理功能。所以用户的目标定义中需要包含相关的主题信息，此主题信息 也属于领域信息的范畴。通过解析用户的目标，获取相关主题信息，就可以订阅相关卽 主题。订阅流程图如下图4-13所示： :

图4-13主题订阅流程图
4.5推理概要设计
结合功能需求分析，推理模块的功能主要是利用一阶逻辑推理器来推理目标，通过 对新来的事件进行处理，然后推理证明目标是否成立。SMT理论求解器Z3的推理证明 功能主要釆用数理逻辑中以下过程：
基于已有的事实P,若要推理出Q成立，则是要证明P-Q的反不可满足。因为P -Q = -PVQ,其中Q是的目标,P是已有的事实，即已有事件处理之后的布尔表达 式。 P-Q的取反即是PA-Qo因此，想要证明P-Q成立，则需要证明PA-Q不可满足。 因为若上式为假，则可得P-Q为真。
SMT推理器Z3主要利用Solver对象进行推理和证明，Solver类是Z3推理器的主 类，其通过Context对象进行创建，Context是Z3提供一个包含Z3大部分对象和方法 工厂方法类。通过Context接口创建的布尔表达式对象都要加入到Solver对象中进行推 理，加入到Solver中的所有的一阶逻辑表达式都是以合取范式的形式存在。
通过将用户的目标处理成一阶表达式对象Q,已有的事件知识通过处理成一阶逻辑 表达式对象P,然后将P以及Q的逻辑反表达式对象都加入到同一个solver中，调用 solver的check。函数，如果结果等价于Status.UNSATISFIABLE则证明目标成立，反之 则表明无法证明目标成立。
整体推理流程图如下图4-14所示：


图4-14目标推理流程图
首先，因为用户的目标推理请求是原生的http请求模型，所以需要解析目标推理请 求。解析目标推理请求包括主题信息提取、知识对象映射、目标一阶表达式生成等任务。
1）	提取主题信息，然后利用此主题信息通过事件接入模块订阅相关主题信息以接 收事件，接收到的事件用于后续事件处理。
2）	知识对象映射，提取目标中的scope信息，通过映射生成知识对象。知识对象 对应知识库中的实例，也就是本体中类的实例。利用此对象查询本体知识库可以获取与 此对象实例相关的实例、数据属性、对象属性。这些关系和属性构成了一个包含概念， 属于描述逻辑中的包含范畴。然后利用描述逻辑与一阶逻辑的关系，通过翻译模块翻译 成为一阶逻辑表达式。用这些一阶逻辑关系可以推理新的事件知识对象是否属于目标推 理范围。
3）	目标一阶表达式生成o主要将目标中的参数和相关约束处理成一阶逻辑表达式。
约束对应了一阶逻辑推理库中的算子函数。比如等于、大于等于、小于等于、大于、小 于等等约束。结合出租车数据，scope对应道路信息，映射成知识库中的道路实例，此 道路实例由多个位置实例组成。这个关系由hasPosition组成，通过将已有的这些关系翻 译成一阶逻辑表达式，可以判断位置与道路的包含关系是否为真。	'
目标解析流图如图4-15所示：

结束

图4-15目标解析流程图
目标解析之后，首先需要接收订阅的事件，为了处理通过事件接入模块到来的事件, 首先要根据事件映射成为事件对象，这可以通过主题映射到爭件结构的方式实现，每一 个主题对应一个schema,根据schema确定事件的携带信息结构，然后解析生成具体的 事件对象。利用Java语言面向对象利多态的特点，实现一?个事件的抽象父类，然后对 应每一类具体事件实现相应的具体实现类。在系统内部维护一个事件主题信息到事件实 现类句的映射表，在Java中也就是维护…个HashMap<String, String〉，对这样可以迅速 的获取事件的实现类名。对于特定的事件，首先利用事件的主题信息获取对应的实现类 名，然后然后利用Java反射获取事件实现类的Class,通过此Class就可以动态的获取 事件实现类的构造函数。从而可以利用构造函数新建事件实例，完成事件信息到事件实 现类的转化。
事件对象生成之后，需要与知识库中的知识对象映射起来，所以需要实现事件对象 与知识对象的映射机制。首先需要实现知识库中的知识对应的Java类，同样，利用多 态特性，实现一个知识对象的抽象父类。抽象父类包含知识对象的唯一标识URI,此 URI也对应了本体中的本体标识符。然后需要实现不同知识对应的不同的实现类，利用 本体中的Position概念就可以用一个具体的实现类来表示，实现Position的相关坐标属 性，并利用类中的标识URI唯一确认知识类。有了知识类之后，需要提供几种将事件 类对象映射到知识类对象的方法，比如结合本论文建立的本体实例和深圳出租车数据， 出租车的坐标信息需要与本体中的Position概念进行关联起来，当一个出租车GPS事 件到来时，首先根据上述流程将事件转化为对应的具体事件对象类实例，此具体对象类 实例包含出租车具体的经度、纬度、速度等信息。为了将此事件类实例与Posigion概念 对应的实例进行映射，可以利用事件类实例的坐标信息和Position概念实例信息的坐标 信息来实现。如果事件类实例的坐标落在Position类实例的坐标范围之中，则说明此两 者对应。
结合Z3的Solver的特性，一旦有新的数据到来就应该更新推理器Solver的内容， 也就是添加BoolExpr对象到Solver中，在实际应用场景中，数据量可能会非常大，如 果每一个对象都加入到系统中进行推理就会造成服务器非常大的负荷。因此，当数据量 增大时，要考虑先过滤无用数据。所以在将事件映射成知识对象时如果发现事件无法对 应知识库中的知识则将事件对象及时的销毁，因为本课题主要采用java语言实现，所 以这可以通过将对象置为null并强制GC来实现。
爭件转化流程图如下图4-16所示：

图4-16事件转化流程图

事件映射为知识对象之后，需要知道知识对象是否处于目标推理的范围之内。只有 属于推理范围内的事件才有意义。如前所述，我们可以利用一阶逻辑推理来实现。在描 述逻辑中，包含概念是一种基本概念，在本体中定义也非常方便，比如，一个类有多个 部分组成，所以一个类的实例也有多个组成部分，这是最为常见的一种包含概念应用。 在本体的构建中包含关系在本体中已经定义好，本体也存储在本体知识库中。在目标解 析过程中，通过査询知识库将目标对象包含的范围中的实例都查询岀来。事件对应的知 识对象如果在这些实例中则说明属于推理的范围之内，如果不是则不属于推理范围之内。
范围推理流程图如下图4-17所示：

图4-17范围推理流程图
利用SPARQL查询知识库取出的相关的模型信息是OWL格式的，为了利用一阶逻 辑推理能力，需要将其进行转化处理成一阶逻辑表达式，也就是将OWL表示的知识转 化翻译为Z3中的一阶逻辑表达式。因为OWL格式和内容众多，如果直接翻译的话工 作量将会是非常巨大的，而且容易出错。结合本体的描述逻辑特性，我们可以参考本体 推理器的推理实现，本体推理器是基于描述逻辑进行推理的，为此可以获取本体推理器 在进行本体解析推理过程中的中间形式，这样可以免除翻译过程的繁琐的本体解析和分 类任务。例如本体推理器Hermit是利用OWL API并扩展接口来进行本体的解析、表示 和推理，利用本体推理器Hermit的API可以获取hermit的中间代码表示。
Hermit是少数的几个优秀的开源本体推理器之一，其源码都是由Java实现的，而 本系统各个模块均釆用Java实现，所以可以无缝集成Hermit的API。利用Hermit的 API首先加载本体文件或者输入流InputStream,加载之后会得到一个Ontology类对象， 此对象表示的是一个本体实例，实际上Hermit调用了 OWL API加载Ontology,而 Ontology类是0WL API提供的接口。然后，为了扩展0WL API以实现自己的算法。

Hemit利用此Ontology对象生成一个Reasoner类对象。在Reasoner类对象的生成过程 中，会将Ontology对象中的对象属性、数据属性、对象属性约束和数据属性约束等翻 译成Hermit内部表示形式。包括Atom、DLClause^ Role等对象实例。
本体解析和描述逻辑翻译成一阶逻辑表达式的流程图如下图4-18所示：

图4-18本体解析翻译流程图

在加载本体获得DLOntology对象之后，需要将对应的数据和对象属性约束翻译成 Z3中的函数。这些约束都包含在DLOngology对象的一个类型为Set<DLClause>的成员 属性中。将这些DLClause输入时的格式如下所示：
?<http://www.semanticweb.org/traffic-ontology#Road>(X)
<http://www.semanticweb.org/traffic-ontology#hasPosition>(X,Y)
?<http://www.semanticweb.org/traffic-ontology#Position>(Y)
<http://www.semanticweb.org/traffic-ontology#hasPosition>(X,Y)
单输入参数的DLClause表示一个参数属于什么类，两个参数的DLClause表示两 个参数之间的关系。比如<http://www.semanticweb.org/traffic-ontology#Road>(X)表示 X 是 Road 类的实例，<http:〃www.semanticweb.org/traffic-ontology#Position>(Y)表示 Y 是
Position 的实例 o |(lj<http://www.semanticweb.org/traffic-ontology#hasPosition>(X.Y)则表 示X和丫之间的:元关系。
Z3的函数与数学中的函数-样，有定义域domain和值域range。domain可以是… 个或者多个输入参数，这些参数可以是不同的类型，在Z3中用Sort接口来表示，具体 的有 IntSort、BoolSort、RealSort、UnintepretedSort 等等，分别对应整型、布尔型、实 数、非解释型。而值域只有一个，类型为上述类型中的一种。结合DLClause的格式， 在翻译过程中，将Z3函数值域都定义为BoolSort,然后分析DLClause的格式得到定义 域参数的个数，同时依据参数的类型确定Z3函数对应的定义域参数类型。因为DLClause 中包含许多重复的函数定义，所以需要维护一个Map以便去重。方便起见，Map的key 对应函数名，也就是DLClause中小括号前的字符串，Map的value即我们生成的Z3函 数。
翻译完函数之后，需要利用这些函数将本体中的Assertion也就是断言翻译成一阶 逻辑表示形式。本体中的断言是既有的事实，在DLOntology中，这些断言都处在一个 名为m_positivefacts的成员属性中，其类型为Set<Atom〉，将Atom打印出的形式如下 所示：
<http://www.semanticweb.org/traffic-ontology#hasPosition>(<http://www.semanticweb .org/traffic-ontology#福中路>,<http://www.semanticweb.Org/traffic-ontology#福中路 p2>)
显然，这也是一个函数形式，利用翻译本体生成Z3函数时得到的Map,可以迅速 的取得对应的函数，然后分别将参数实例化，并将函数应用在这些实例化的参数上。最 后将函数应用结果断言为TRUE而成为一个布尔表达式，所有这些布尔表达式就构成了 推理的前提。如果新加的布尔表达式与前提相矛盾，则说明新加入的布尔表达式不成立。
因为目标事件需要一定的时间窗口来推理出目标事件，比如拥堵需要利用一段时间 内的事件进行推理。所以需要一个缓冲队列来缓存属于目标事件推理范围内的事件，每 一次推理都将整个队列内的事件对象一起推理。因此，事件如果经过范围推理属于目标 事件的推理范围，则将事件对象加入到目标事件对象的缓冲队列之中，并适时的将缓冲 队列队头的数据移除出去。
目标事件发现流程图如下图4-19所示：

困4-19目标事件发现流程图

用户的目标定义，经过处理同样会生成一阶逻辑表达式。每个目标由一个Solver 负责。每一次推理，将属于目标的缓冲队列内的所有事件对象依次遍历，根据事件对象 生成的一阶逻辑表达式会依次添加到相关的Solver中，然后调用对应的Solver的check() 接口获取推理结果值，此结果值表示了是否发现目标事件，从而对事件作出响应。推理 结果需要存储到数据库中持久化以便结果展示时获取。
4.6本章小结
本章主要内容是对本论文提出的知识子系统进行概要设计。开篇介绍了系统总体架 构，接着是对各模块的整体设计，并介绍了各模块的功能和内部关系等。通过本章可以 详细的了解本系统的总体概要设计，形成一个清晰的概念。接下来的章节将对各模块的 具体实现细节做详细讲解。

第五章系统详细设计与实现
前面章节对系统进行了需求分析和概要设计，本章将着重阐述物联网系统的知识子 系统的详细设计与实现。
5.1用户接口实现
用户接口模块主要是提供用户一个直观的Web管理和操作界面，结合之前的设计, 主要包括提供基本的知识库管理操作功能和用户自主定义事件推理目标及结果展示功 能。用户也可以通过界面按照提供的选项输入领域信息，选择相关参数和相关的约束算 子，然后提交给后台，后台完成处理之后将数据存储到数据库MongoDB中。之后用户 可以选择展示结果，同样的前端会将请求提交到Web后台，后台根据请求访问数据库 获取数据，然后以Json的数据格式返回。用户也可以通过界面进行基本的知识库管理 操作，包括知识库的添加、删除、文件上传、备份和SPARQL査询。请求提交时序图 如下图5-1所示：



图5-1请求提交时序图
前端基于backbone框架同时结合Bootstrap库和jquery.js库实现开发，釆用MVC 设计模式，主要涉及 dataset-controller.js、manage-controller.js、query-controller.js、server.js、 upload-controller.js等几个类。server.js:用于发送请求的主类，用于将用户的操作发送给 后台服务器。dataset-controller.js是dataset.html控制主类，用于获取数据集列表并显示 加载数据集页面。初始化数据集，在页面中生成对应列表，记录下用户的操作并进行响 应。manage-controller.js是数据集管理器，负责响应用户的数据集添加、删除、备份操 作并根据返回结果更新界面。query-controller.js是SPARQL查询控制器，嵌入Qonsole component编辑器，用于加载整个SPARQL编辑器并负责将SPARQL代码传送至后台。 upload-controller.js：负责文件的上传操作，并根据上传结果渲染界面。
规则定义界面的主体实现为一个Bootstrap表单(fbrm),用户可以选择知识库名，然 后系统会自动根据选择的知识库更新相关选项。界面包含映射定义、推理定义、推理、 结果展示等相关功能选项。如下图5-2所示：

。定义事件处理规则：
知识库
談射定义	推建定义	推理	结果展示	停止展示
图5-2定义事件处理规则主界面图
映射定义按钮触发事件与知识映射定义窗口，用于事件与知识的映射，包括选择特 定的知识对象，选择事件主题及事件的属性，知识实例(事件推理范围)。界面实现同 样为一个Bootstrap表单，釆用Bootstrap模态框形式进行弹出。表单包含的项目包含推 理映射定义的各项内容，包括要映射的知识库中的知识对象，事件主题和用于映射的事 件的一级属性、知识实例等选项。在表单各项中，知识对象、知识实例和事件主题等选 项使用了下拉列表框(select)类型，事件属性选择使用了多选框(checkbox)类型，数据输 入框使用了下拉列表框(select)和文件(file)类型，备注使用了文本域(textarea)类型，其他 各项使用的都是文本框(text)类型。事件与知识映射定义界面如下图5-3所示：

事件知识映射
知识对象
http://www.semanticweb.Org/traffic-ontology#Position

事件主题
shenzhen
速度	经度 新
'?莅j欵為參忒迎.	板％....	! 纬度 62 状态	　　　方向
知识实例
http://www.semanticweb.Org/traffic-ontology# 翠竹路		　　　▲

图5-3映射定义图
推理定义按钮触发约束定义窗口，用于推理目标的约束定义，包括选择选择相关参 数以及输入相应的参数值。界面实现同样为一个Bootstrap表单，采用Bootstrap模态框 形式进行弹出。约束定义界面如下图5-4所示：

推理按钮用于提交用户推理请求，用户点击就会触发请求处理函数。函数会首先要 阻止表单自动提交，然后会获取表单中的每一项参数以及参数值。随后，会附上一个唯 一 id值，此id值用于标识此次推理。以便后续获取结果时作为凭证。然后利用jQuery 中?瘁技术提交所有参数到后台监听地址和端口。
结果展示的时序图如下图5-5所示：

图5-5结果获取时序图

结果界面的渲染釆用百度的echarts.js库实现。echarts.js库需要提供一个div元素来 初始化图表，并提供一个json格式的配置对象用于设置图表的参数，包括标题、tooltip、 legend、x轴和y轴的类型、数据展示的图表类型等。结果获取釆用轮询的方式，前端 每隔固定时间访问后台请求结果数据，同样也是采用Ajax技术实现，用户单击结果展 示之后，触发相应事件响应函数。首先响应函数会做一些初始化的工作，包括基本图表 的渲染，id值的获取等，然后向服务器发送推理时提交id号，服务器会根据此id号返 回相应的推理结果数据。数据都是以json的形式返回，为了更新界面，首先要解析数 据生成一个JSON格式的对象。对象中的各个属性值存储着结果信息，通过将结果信息 push到图表的option配置对象的数据数组里，同时把最开始的数据给移除。这样相当 于时刻维护一个数据窗口，每次更新界面时只渲染此窗口中的数据。。
定义事件处理规则:
知识库
Traffic



道路拥堵状态

19:40:0	19:45:0 19:50:0	19:55:0	200:0	20:5:0	20:10:0 20:15:0
图5-6结果渲染图
后台服务器基于Jetty技术实现，通过继承AbstractHandler类实现DataHandler类, 这是处理请求的主类，根据请求的不同执行不同的响应操作。后台启动之后会监听固定 的端口，前端的请求经过jetty的封装之后会生成Request对象。通过分析Request中的 path判断是推理请求还是结果获取。如果是推理请求则将参数封装为Targetinfo对象中, 并将此对象作为入口参数调用推理模块进行推理，如果是结果获取则根据参数id访问 数据库获取结果。类图如图5-7所示：

图5-7后台服务类图

具体涉及到的类有：DataHandler 类、Main 类、MongoTool 类、JettyService 类、 DatasetFactory 类、JettyService 类、Targetinfo 类、ClientHelper 类。表 5-1 对上述的这 些类和对应的实现功能作了简要介绍：
表5-1数据集删除功能
类/接口	功能描述
Main	后台服务入口，Web后台的服务启动类。监听1古1定端口，如果参数 中没有提供启动端口，则默认从15100端口启动。
DataHandler	Web请求处理类。根据接收到的HttpRequest,判断其中的请求地址 后缀，如果是/dataset开始的地址则进行知识库相关的操作，如果是 /deduce则将其余参数传给推理器，如果是/data则获取结果并返冋。
MongoTool	MongoDB数据库的类，采用单例模式实现。提供获取利存储数据的 接口。
JettyService	Jetty的启动类，启动函数start负责从给定端口启动，并将请求作为 转发给DataHandlere处理。
Target In fo	封装Request中的参数，是推理模块入口参数对象。
ClientHelper	结果获取辅助类，根据配置文件获取存储结果的数据库名和数据集 名，并生成MongoDB的访问对象MongoCliento
DatasetFactory	用于数据集操作,DatesetHandler调用接口响应用户的知识管理操作。


表5-2是JettyService类的启动方法介绍。
表 5-2 JettyService 类 start 方法
方法	protected void start(int port, bstractHandler handler)
描述	根据传入的接口和AbstractHandle对象生成Jetty的Server对象。
AbstractHandler是Handler接口，实际传入的是实现接口的DataHandler对 象。然后启动Server开始监听输入的端口，将到来的请求分发给传入的 DataHandler对象进行处理。
参数	@Param port要监听端口。
@Param handler实际响应类对象。
返冋	void
表5-3是DataHandler类的handle方法介绍。
表 5-3 DataHandler 类 handle 方法
方法	protected void handle(HttpServletRequest request,
HttpServletResponse response)
描述	响应用户接口的请求，根据请求的内容生成进行处理，包括推理、结果获 取以及模型知识库的增删改査等功能调用。
参数	@Param request http 请求。
@Param response http 响应对象。
返冋	void

5.2知识库管理模块的实现
知识库管理模块功能需求主要包括知识库管理和查询实现。
5.2.1知识库存储的设计与实现
在本实现中，管理本体知识库利用Jena的TDB中的数据集的来实现，每一个知识 库按照数据集的形式来组织和管理。因为每一个数据集是存储在文件系统中，需要利用 TDB的API可以加载到内存，因此，结合事件的查询需求，需要将数据集按照领域进 行分类，避免一个数据集过于庞大而内存不够加载使用。将数据集按照特定领域分类组 织，每个领域给予一个命名，数据集的名字就是领域名。同时，在配置文件中给定映射， 每当系统启动即加载配置文件。实现类图如图5-8所示：
图5-8知识座管理类图

知识库对应TDB数据集，TDB数据集通过工厂类TDBFactory生成。TDBFactory 静态工厂方法用以创建和连接TDB数据集。用户在Web前端输入的数据集名，以及用 户选择的内存模式还是持久化模式，内存模式在后台服务器停止运行后数据会销毁，下 次运行时数据不可用。而持久化模式则会以文件的形式存储在文件之中，之后再次运行 时数据可用。给定一个新的数据集名，新建一个数据集的详细实现具体涉及到的类有: DatasetFactory类、Dataset类，DatasetMap类和Config类。表5-4对上述的这些类和对 应的实现功能作了简要介绍：
表5-4知识库管理主要涉及类
类/接口	功能描述
DatasetFactory	知识库管理主类，默认是resource目录下的每个子目录是 一个数据集。同时根据输入的名字生成、删除、备份数据 集，利用Map进行名字利数据集之间的映射。
Dataset	数据集对象，表示一个数据集（知识库）。
DatasetMap	维护数据集名和数据集对象的映射。
Config	配置类，主要用丁?读取配置文件。


表 5-5 DataFactory 类 createDatasetByName 方法
方法	protected void createDatasetByName (String datasetName)
描述	根据知识库名生成对应的知识库，并且将名字和知识库对象的映射更新到 map中，在适当的时候持久化到文件中。
参数	@Param datasetname 知识库名
返回	Void
表 5-6 DataFactory 类 getDatasetByName 方法
方法	protected void getDatasetByName (String datasetName)
描述	根据知识库名获取知识库，并返冋对应的知识库，若不存在则返冋null。
参数	@Param datasetname 知识库名
返冋	Dataset返冋的知识库对象


表 5-7 DataFactory 类 removeDatasetByName 方法
方法	protected void removeDatasetByName (String datasetName)
描述	根据知识库名移除对应的知识库，如果不存在则返冋。并11将名字和知识 库对象的映射更新到map中，在适当的时候持久化到文仰中。
参数	@Param datasetname 知识库名
返冋	Void
本体存储部分核心算法如表5-8所示：
表5-8本体存储部分核心算法
标题	本体存储部分核心算法
输入	Model model
输出	void
1: Dataset dataset = getDatasetByName(datasetName);
2: if not dataset
3: create dataset; //如果对应的数据集不存在则新建
4: begin
5:	dataset.begir)(ReadWrite.Write); // 写爭务开始
6: Model model = dataset.getDefaultModel();
7: model.add(....);//本体加载后依次加入数据集中的model;
8:......;
9:	dataset.commit(); // 写事务提交
10: dataset.end();
11:end

5.2.2知识库查询的设计与实现
知识库的管理功能另--功能就是SPARQL查询，已冇的本体模型存储在知识库中， 需要实现查询接口以方便使用知识库的知识。本系统利用Jena语义框架的SPARQL查 询引擎ARQ来实现这一功能，实现类图如图5-9所示：

图5-9 SPARQL查询支持类图
SPARQL査询语句首先需要转化生成为Query对象，然后调用静态工厂类 QueryExecutionFactory 的 create 接 口获得 QueryExecution 对象,调用此对象的 exexSelect() 接口可以得用结果集对象ResultSet,具体涉及到的类有：SparqlQuery类、SystemState 类，DatasetFactory类。表5-9对上述的这些类和对应的实现功能作了简要介绍：
表5-9知识库SPARQL查询主要涉及类
类/接口	功能描述
SparqlQuery	Sparql査询主类，提供査询Jena Model和Jena Dataset静态的 接口，返回 ResultSeto
SystemState	初始化类，加载数据集利维护系统状态
ResultSet	SPARQL査询结果集对象。
Dataset	Dataset数据集类
Model	本体表示接口类。
DatasetFactory	知识库管理主类，默认是resource目录下的每个子目录是一个 数据集。同时根据输入的名字生成、删除、办公数据集，利用 Map进行名字和数据集之间的映射。


表 5-10 SparqlQuery 类 queryModel 方法
方法	protected ResultSet queryModel(String queryString, Model model)
描还	响应传入的SPARQL査询请求和提供的Jena Model对象获取结果集对象， 结果集可提供迭代器遍历三元组结果。
参数	@Param queryString SPARQL 查询语句
@Param model Jena Model对象,Jena内部对本体的表示接口
返冋	ResultSet结果集


表 5-11 SparqlQuery 类 queryModel 方 法
方法	protected ResultSet queryModel(String queryString, Dataset model)
描述	响应传入的SPARQL査询请求利提供的数据集对象获取结果集，结果集可 提供迭代器遍历三元组结果。
参数	@Param queryString SPARQL 查询语句
@Param dataset数据集对象
返冋	ResultSet结果集

SPARQL查询核心算法如表5-12所示:
表5-12 SPARQL查询部分核心算法
标题	SPARQL部分核心算法
输入	String sparql String
输出	ResultSet
1: Dataset dataset = getDatasetByNaine(datasetNaine);
2: if not dataset
3: return null ; //如果对应的数据集不存在则返回空
4: begin
5:	dataset.begin(ReadWrite.READ); // 写事务开始
//根据查询语句和选定数据集生成査询对象
6: QueryExecution qExc =
QueryExecutionFactory.createa(sparqlString, dataset);
7: ResultSet resultSet = qExc.execSlect();
8:		;//结果过滤
9：	......；
10: return resultSet;
11: dataset.end();// 写爭务结朿
12:end

5.3事件接入模块的实现
推理模块接收的数据是物联网平台上传的高速实时数据流。物理设备实时数据首先 经过资源接入管理，通过相对应的协议进行处理和解析，将实际的物理数据转化为结构 化的数据。并将这些结构的数据经由发布订阅消息间件发给推理模块进行处理。事件接入模块的主要目的是提供一个数据转发功能。因此发布订阅消息空间中的主题众多，只 需要订阅一部分主题相关的消息。本课题主要将其分为数据订阅和接收两个子模块。
5.3.1数据订阅模块的设计与实现
数据是经过发布订阅系统进入推理功能模块中的，需要向发布系统订阅需要接收的 事件的主题，然后可以从发布订阅系统接收相关主题的事件，本模块涉及相关事件的订 阅。在本课题中，推理功能模块是消息的消费者。物联网平台数据接入平台是消息的生 产者。结合面向对象的编程思想，数据订阅模块相关类图如图5-8所示，此部分主要涉 及的类有：PubSub 类、Configuration 类、TopicEntry 类。
表5-13对上述的这些类和对应的实现功能作了简要介绍：
表5-13订阅模块主要涉及类
类/接口	功能描述
TopicEntry	发布订阅系统主题对象实体。
Configuration	动态信息配置类。可以在配置文件中对发布订阅系统相关
1P、端口等信息进行动态配置。
PubSub	实现了与发布订阅系统消息空间节点的交互。
主要方法：
获取所有的主题名称allTopicNamesQ; 获取所有的主题树目录allTopicContents();
向主题树中新增主题叩loadTopic(String, String); 订阅主题 subscribe(String);
取消主题 unsubscribe(String);
得到消息主题的schema文件getSchema(String)


表 5-14 PubSub 类 getSchema 方法
方法	protected void getSchema(String topic)；
描述	根据订阅主题名得到相应的schema文件。
参数	@Param topic 主题名。
返冋	File文件对象。

表 5-15 PubSub 类 subscribe 方法
方法	protected TopicEnty subscribe (String topic);
描述	根据主题名获取对应的主题。
参数	@Param topic主题名字。
返冋	TopicEntry返冋的主题对象。

5.3.2数据接收模块的设计与实现
数据接收模块主要是用于接收数据订阅模块所有订阅主题的数据，只要此相关主题 的消息被发布，推理功能模块就需要得到这些数据（事件）进行处理。如何接收并正确 的预处理这些数据由数据接收模块来实现。
由于推理功能模块能接收处理的数据是带有领域信息的对象，所有数据接收模块需 要将从发布订阅接收到的数据转化为Java对象，具体涉及到的类有：SchemaFunction, 类,NotificationProcessImpl 类，DeducerData 类。
表5-16对上述的这些类和对应的实现功能作了简要介绍：
表5-16数据接收模块主要涉及类
类/接口	功能描述
SchemaFunction	根据输入的Schema文件，解析事件属于哪个主题。
Deduce Data	生成的数据对象，用于推理模块处理。
NotifictionProcesslmpl	负责监听是否有数据到来，每当有新的数据到来时，首先 解析出数据是属于个主题。然后根据相应的主题生成对应 的数据对象。


表 5-17 SchemaFunction 类 getTopicNameBySchema 方法
方法	protected String getTopicNameBySchema(Document schema)
描述	根据输入的schema文件的内容判断数据属丁?哪个主题，返冋值为类名。
参数	@Param schemat org.w3c.dom.Document 对象。
返冋	String

5.4推理模块的设计与实现
推理功能模块是核心模块，推理模块主要提供给用户能够基于目标进行即时推理的 功能。本模块主要包括目标和事件解析、一阶逻辑子句转化，推理等三个子模块。
5.4.1目标和事件解析模块的详细设计与实现
此部分的时序图如图5-10所示：
具体实现的类图如下图5-11所示:



下面就模块中涉及的类的主要接口进行说明：Targetinfo类是目标解析主类。首先 提取主题信息，然后通过事件接入模块订阅接口 PubSub订阅相关主题信息以接收事件。 ScopeManage类用于知识对象映射，提取目标中的scope信息，通过映射生成知识对象 并且通过LoadTargetKnowledge查询本体知识库获取与此对象实例相关的实例、数据属
性、对象属性。TargetToBoolExpr用于目标一阶表达式生成。主要将目标中的参数和相 关约束处理成一阶逻辑表达式。
表5-18目标解析主要涉及类
类/接口	功能描述
TargetParser	目标解析主类，解析传入的Target Info对象，调用相关接口 完成提取主题信息并订阅、映射知识对象并査询知识库获 取相关联的知识、目标一阶表达式生成等二个任务。
T argetToBoo 1 Expr	目标一阶表达式生成。主要将目标中的参数和相关约束处 理成一阶逻辑表达式
ScopeManager	ScopeManage用丁-知识对象映射，提取目标中的scope信 息，通过映射生成知识对象。
Load T arget Knowledge	查询知识库获取相关联的知识。
PubSub	用于订阅相关事件主题。


表 5-19 TargetToBoolExpr 类方法
方法	List<Solver> parseTargetToBoolExpr(Context ctx,Targetlnfb info)
描述	根据输入的Targetinfo对象生成BoolExpr,并对应生成一个Z3 Solver对象， 将生成的BoolExpr对象加入到Z3中。
参数	@Param Context Z3 上卜文对象。
@Param Targetlnfb推理目标对象。
返冋	List<Solver>

5.4.2 一阶逻辑表达式转化模块的详细设计与实现
一阶逻辑表达式转化包括本体的加载和解析翻译两个步骤。本模块的输入包含本体 文件或者本体输入流。本质上文件的处理也是先通过加载文件为一个流对象再调用数据 流的加载函数进行处理的。通过将本体进行加载入内存，然后解析生成本体对象，以便 后续处理本体对象获取描述逻辑子句。本课题通过分析Hermit本体推理器的加载过程， 釆用与之同样的方法，即利用OWL API进行进行加载并生成DLOntology对象。再对 DLOntology进行处理。时序图如下图5-12所示：



图5-12 —阶逻辑转化时序图
类图如图5-13所示:


图5-13 一阶逻辑转化类图
主入口是0WLT0Z3的parse函数，通过调用ParseOWLToDLOntology的接口获得 DLOntology对象。然后根据DLOntology得到DLCIause类型的集合，将每一个 DLClausecf解析生成相应的Z3函数FuncDecl对象。最后根据FuncDecl将DLOntology 中的positiveFacts翻译成一阶逻辑表达式。ParseOWLToOWLOntology用于加载OWL输入流或者本体文件，利用本体管理器OntManager生成OWLOntology对象。解析文件 的流程实质是先加载文件为Inputstream标准流的形式，然后再调用上述流的加载流程。 OntManager使用单例模式，因为可能会出现多个线程同时调用的问题，所以采用多线 程安全模式创建一个本体管理器单例。
在生成DLOntology对象的过程串，Hermit的Reasoner API会分析OWL API原生 接口 OWLOntology的内部结构生成OWLClausifier对象，然后根据0WLOntology调用 clausify函数对Ongoloty对象进行子句化过程。通过子句化之后生成DLOntology对象， 此对象内部包含一个DLClause的集合对象，此对象集合包含所有的描述逻辑子句。解 析DLClause生成相应的Z3函数的这部分任务由FuncDeclGenerate类实现，利用Z3函 数并生成一阶逻辑表达式的任务则由OWLTOZ3实现。
表5-20对上述的这些类和对应的实现功能作了简要介绍；
表5-20本体OWL解析模块主要涉及类
类/接口	功能描述
OWLToZ3	OWL解析和翻译一阶逻辑表达式主类。
通过FuncDeclGenerate生成Z3函数,得到键利值分别为 函数名与函数的Map对象。然后利用此Map将 PositiveFacts中的翻译成一阶逻辑表达式。
OntManager	采用单例模式实现的本体管理器管理器单例类。■
ParOWLTo DLOntology	加载本体文件，利用Hermit的Reasoner API生成 OWLOntologyo parse(InputStream inputStream)根据输入 流解析成本体对象。
parse(File file)根据输入的文件解析成本体对象。
ParseOWLToDLClauses	获取DLCIause的主类。
FuncDeclGenerate	Z3函数生成主类。并将函数名和函数更新到-个map中， 用丁?后续使用。
getFuncDecl(Context, DLCLause)生成 Z3 函数。


表 5-21 OWLToZ3 类 parseFromStream 方法
方法	public BoolExpr parseFromStream(Context ctx,
InputStream inputStream)
描述	首先调用ParseOWLToDLOntology的接口获得DLOntology对象。然后根 据 DLClause 生成 Z3 的函数 FuncDecU 最后根据 FuncDecl 将 DLOntology 中的positiveFacts翻译成一阶逻辑表达式。

（续上表）
参数	@Param context Z3 Context 对象。 @Param InputStream 输入流对象。
返冋	BoolExpr本体对象


表 5-22 ParOWLToDLOntology 类 parse 方法
方法	public DLOntology parse(InputStreain inputStream)
描述	首先利用OntManager根据输入流加载成本体OWLOntology对象，此对象 是OWL AP【接口，然后利用此对象生成Reasoner对象，然后获取其 DLOntology域并返冋。
参数	@Param InputStream 输入流对象。
返冋	DLOntology本体对象


表 5-23 FundeclGenerate 类 getFuncDecl 方法

方法	public Quantifier getFuncDecl (Context context,
DLClaused dlclause)
描述	解析DLCIause对象，生成Z3函数即FuncDecl对象。并将函数名与FuncDecl 保存到一个全局map中。
参数	@Param context Z3 Context 对象。 @Param diClause DLCIause 对象。
返回	void

5.4.3推理的详细设计与实现
结合之前的的设计，事件推理时序图如图5.14所示:


HL hr h .
图5-14事件推理时序图
具体类图如图5-15所示:
Client类接收目标请求对象Targetlnfb,采用一个Deducer类作为推理的主类。此类 然后调用之前的目标解析进行主题订阅、知识库查询并翻译、目标一阶逻辑表达式生成。 查询知识库并翻译所得的BoolExpr存放在一个名叫scopeDeduceSolver的Solver对象中, 用于后续事件范围推理。目标一阶逻辑表达式生成得到一个Solver的列表list,列表中 的每一个Solver保存一^推理目标表达式BoolExpr的逻辑反，即利用Context的 mkNot(BoolExpr)接口获得一个布尔表达式的逻辑反。
然后，每来一个事件，首先利用IncidentFactory接口生成一个事件对象。Incident 是Java的接口，目前实现此接口的只有Trafficincident类。然后利用IncidentToKnowledge 将事件对象映射生成一 Knowdedge对象，如果不存在映射就将事件进行销毁。Kowledge 也是接口类，目前具体实现的只有IncidentKowledge。然后利用Knowledge对象判断是 否在推理范围内，范围推理由scopeDeduceSolver实现。如果事件不属于目标推理范围 内则将事件对象和事件知识对象都销毁。如果属于目标推理范围则将事件对象和事件知 识对象交给Deducer进行推理。
属于推理范围的事件会加入到一个队列之中，如果队列内包含的事件时间跨度超过 一定范围就开始对队列内所有的数据进行一次对理，每个事件根据处理最终会生成一个 布尔表达式BoolExpr,根据其与哪些目标相关添加到相应的Solver中。然后调用Solver 的check。接口，如果结果等于Status.UNSATISFIABLE则证明相应的目标成立。如果 结果等于Status.SATISFIABLE则证明相应的目标不成立。并将结果存储在MongoDB 中。主要涉及的类有：Client类、Deducer类、IncidentFactory 类、TargetParser类、 IncidentToKnowledge 类等。
表5-24对上述的这些类和对应的实现功能作了简要介绍：
表5-24推理主要涉及类
类/接口	功能描述
Client	用丁?接收推理目标，包括参数的提取和转化。从发布订阅接收 事件数据。调用査询知识库API,过滤无用数据。
IncidentFactory	将接收到的事件映射为对象。
Deducer	推理主类。
Deduce(BoolExpr)将布尔表达式添加到对应Solver中，调用 Solver的check()得到推理结果。
TargetParser	解析日标对象，具体实现在目标解析模块。
IncidentToKnowledge	将事件对象映射为知识库中的知识对象。

表 5-25 Deducer 类 deduce 方法
方法	protected void deduce(Knowledge knowledge.
Incident incident)
描述	首先根据knowledge生成布尔表达式进行范围推理。如果不在推理范围内 则返冋。如果在推理范围内则根据incident生成布尔表达式添加到成员变 量List<Solver>的每个Solver中，调用Solver的check()接口得到推理结果， 并将推理结果存储到数据库中。
参数	@Param Knowledge事件映射生成的知识对象。
@Param Incident解析事件生成的Java对象。
返冋	Void


5-26事件推理核心算法
标题	事件推理核心算法
输入	String message 事件信息
输出	Boolean
〃事件对象生成
1:	Incident incident = IncidentFactory.convertlncident(message)
//事件映射知识对象
2:	Knowledge = incidentToKnowledge.getKnowledge(incident);
3:	if (Knowledge = null):
4:	　　　destroy incident;
5:	BoolExpr expr = mkBoolExpr(knowledge);
//	范围推理
6:	scopeDeduceSolver.add(expr);
7:	if (scopeDeduceSolver.check() = Status.UNSATIFIABLE):
8:	　　　destroy incident and knowledge ;
//	如果距离上次推理已经过去interval Ibl fnJ,则进行推理
9:	if (time - lastTime) > interval :
10	: BoolExpr expr2 = boolmkBoolExpr(incident, knowledge)
11	:	for (Solver solver: list):
12	　　　　solver.add(expr2);

13	　　　　if(solver.check() == Status.UNSATISFIABLE):
14	proved; //推理成功
5.5本章小结
本章分别对设计的各个模块进行了详细的实现介绍，包括实现技术、工具、具体实 现方法。主要从以下几个模块给出了详细的设计流程图和实现类图、主要代码，包括用 户接口模块、知识库管理模块、事件接入模块、推理模块这几个大的模块。其中推理模 块又细分了几个小的部分：目标解析的设计与实现、一阶逻辑子句转化的设计与实现、 推理的设计与实现，对这几个小部分分别进行了具体流程介绍以及相应的类图讲解，到 本章为止的知识子系统也完成了的需求实现，接下来将对本系统进行测试和验证。

第六章系统的测试及验证
6.1测试目标及环境
6.1.1测试目标
对于在本论文研究背景中提到的基于物联网平台的知识子系统，本章将从功能测试 和性能测试两个方面对原型系统进行测试及验证。
（1）	功能测试。主要目标是测试系统的Web的前端和后台，包括推理及结果展 示等功能模块。并通过将平台应用到真实的样例来测整体的处理流程。并且保证功能正 常运行。
（2）	性能测试。主要目标是测试基于物联网平台的知识子系统在处理用户需求
时的性能。包括SPARQL查询的响应时间、推理系统每秒处理的消息数專，以及CPU 占用等性能指标。	*
6.1.2测试环境

HAS
图6-1测试环境部署图

图6-1所示为测试环境的部署拓扑结构：
?Web客户端：网页客户端，用于管理数据集和目标定义以及结果展示。
?Web后端：Linux系统下Jetty环境，运行后台程度。
?推理服务器：Linux系统下Jetty环境，运行系统程序程序。
?服务器：安装MongoDB,负责请求转发及存储推理结果的相关数据信息。
69
表6-1虚拟服务软件配置
操作系统	Ubuntu Server 14.04 LTS
Java虚拟机	Java Runtime Environment 1.8.0 l 12
Z3版本	4.5.0
Hermit版本	1.3.8
Jena版本	3.1.1
MongoDB 版本	3.4.0

表6-2虚拟服务器硬件配置
处理器	Intel(R) Xeon(R) CPU E5640,主频 3.00GHz+2.99GHz, 6 核
内存	4GB
网l<	百兆网卡
硬盘存储	600GB

表6-3客户端硬件配置
处理器	*	英特尔酷睿13,主频2.5GHz,双核
内存	2GB
网卡	百兆网R
硬盘存储	250GB

表6-4客户端软件配置
操作系统	Windows 7 旗舰
Java虚拟机	Java Runtime Environment 6.0
网络浏览器	Chrome

6.2系统功能测试
本论文测试釆用深圳出租车GPS数据，通过利用此数据来实时推理出道路的拥堵 情况，结合测试流程来对系统进行功能测试。
本论文采用Protege本体编辑软件作为建模工具，如下图6-2、6-3、6-4所示：

图6-2 Road概念图
IQvmdarM TTo
鬱 hasY2 nxactly 1 xsd:dout>le 蜂 h”V exactly 1 xsd:doubl? 谿 hasX2 exactly 1 xsdidouble fthasXl exactly 1 xsdzdouble
? ?<*>api ?福中鶏。， ?福中*p3 ?福中?》4
is!
? tIW4>Bp2
■BOG
e€o
@0G
900
图6-3 Position概念图

6*，心 ?. EnUUw、by 技st>，Di.软* “
DH-Api-^p^vs. MT&mtrc	O?Xa?yp?>? tnan-OMt ? 91 中 ISpl
机	InUwkJgArewUBur* .坤冲*如雄:
?? ?
?M?M
?■中路
?a*Hpi
?；■中 Bp2 ?構中Mp3
?n 中Big
?n*??H
?u龄中路pl
?nn<FHp2
?US中 hp3
?aw??p4
?U的中Hp5
?II岭中路p6
?8n?
?BttBpl 4f BHSp2
??nnp3
??n>8p4
?snaps
?￡SK
?￡￡3pl
?SSBp2
?BS?p3 ?隹田路X
?SffiBpS
将以上建模完成后的模型保存为owl文件，然后用于后续测试。
6.2.1用户接口功能测试
（一）前端模块
1.数据集添加功能。
1）测试用例。
表6-7数据集添加功能.
用例目的	该用例用于测试“数据集添加”功能。
描述	该用例用于测试“数据集添加”功能，是系统的关键步骤。
前提条件	用户打开网页，进入管理数据集页面。
测试步骤	1）	点击加入新数据集；
2）	输入新的数据集名，选择数据集类型；
3）	点击“创建数据集”按钮。
预期结果	登录成功，用户进入数据集主页面。
测试结果	测试通过。
2）测试结果
图6-5是数据集添加功能过程的截图，显示了创建数据集的过程。

管理数据集
在已存在的数据集上执行操作，包括备份.或者加入一个新的数据编



数据集类型	?内存模式-服务器亜启时数据集将会重新创建，但内容会丢失
持久化模式-数据集会保存



图6-5数据集添加功能
2,数据集删除功能。
1）测试用例。
表6-8数据集删除功能
用例目的	该用例用于测试“数据集删除"功能。
描述	该用例用丁?测试"数据集删除”功能，是系统的关键步骤。
前提条件	用户打开网页，进入管理数据集页面。
测试步骤	1）	点击“已有数据集”按钮，进入己有数据集界面；
2）	选择一个数据集点击“移除”按钮；
3）	弹出界面，点击确认。
预期结果	删除成功，用户进入管理数据集页面。
测试结果	测试通过。
2）测试结果
图6-6是Web端数据集移除功能中确认移除界面。显示了用户选择了 test数据集并

3.数据集备份功能。
1）测试用例。
表6-9数据集备份功能
用例目的	该用例用于测试“数据集备份”功能。
描述	该用例用于测试“数据集备份”功能，是系统的关键步骤。
而提条件	用户打开网页，进入管理数据集页面。
测试步骤	1）	点击“已有数据集”按钮，进入已有数据集界面；
2）	选择一个数据集点击“备份”按钮；
3）	弹出界面，点击确认。
预期结果	备份成功，用户进入管理数据集页面。
测试结果	测试通过。
2）测试结果
图6-7是Web端数据集备份功能中确认备份界面。显示了用户选择了 traffic数据
集并点击移除按钮后弹出的界面，等待用户确认操作。


在已存在的数槌案上执行撩作，包括备维.裁者加入一个新的数芻集
6-12-07Tl5:22:23.758^-08:00.完成的闾 2018-12-07T15:22:23.838+08?)
图6-8数据集备份完成界面
图6-8是Web端数据集备份功能中确认备份成功之后的界面。

4.单文件上传功能。
1）测试用例。
表6-10单个文件上传功能
用例目的	该用例用于测试“单个文件上传”的功能。
描述	该用例用于测试“单个文件上传”的功能，是系统的关键步骤。
前提条件	用户打开Web,进入主页面。
测试步骤	1）	点击首页左上角的“数据集”，数据集列表：
2）	在数据集列表中，点击任意一个数据集数据；
3）	点击上传文件按钮，选择本地文件；
4）	点击上传按钮。
预期结果	文件上传成功。
测试结果	测试通过。
2）测试结果
图6-9是对选定的数据集traffic选择单个文件后上传成功的界面。
￡上传文件 0编辕 的信息
上传文件
上传数据到当前的数据集中.可上传任憲RDF格式，如Turtle, RDF/XML.
选择数据集	traffic


model_rdf.owl 11.1 kb
Result: success. 85 triples
图6-9数据集备份确认界面
5.多文件上传功能。
I）测试用例。
表6-11文件上传功能
用例目的	该用例用于测试“文件批量上传”的功能。
描述	该用例用于测试“文件批量上传”的功能，是系统的关键步骤。
前提条件	用户打开Web,进入主页面。

（续上表）
测试步骤	1）	点击首页左上角的“数据集”，数据集列表；
2）	在数据集列表中，点击任意一个数据集数据；
3）	点击上传文件按键，选择多个本地文件；
4）	点击上传所有文件按钮。
预期结果	文件上传成功。
测试结果	测试通过。
2）测试结果
图6-10是文件批量上传成功时的界面。
殺査询	工上传文件	0缀辍 成信息
上传文件
上慎数据到当爾的歡擒繼中.可上作任窸ROF格式，^Turtle, FO7XML.
选择数据策	　　test
——?—
待上传文件	■寸	［靄
owlDemoData.xml	1.4kb
Resuit: success. 15 triples

owlDemoSchema.xml	2.8kb
Result: success. 43 triples
rdfsDemoData.rdf	545 bytes
Result: success. 3 triples
■■■■■■I	■■■■■

6-10文件批量上传确认界面

6.规则定义功能
1）测试用例
表6-5规则定义功能
用例目的	该用例用于测试“规则定义”功能。
描述	该用例用于测试“规则定义”功能，是系统的关键步骤。
前提条件	用户启动后台，打开Web端，进入“规则定义”页面。
测试步骤	1）	用户选择知识库；
2）	用户进行事件知识映射定义与推理范围；
3）	用户输入约束定义参数；
4）	点击"提交”按钮。
预期结果	功能通过，页面正常响应。
测试结果	测试通过。

2）测试结果
图6-11是推理规则定义界面。



7.推理结果展示功能。
1）测试用例。
表6-6推理结果展示功能,
用例目的	该用例用于测试'‘推理结果展示”功能。
描述	该用例用于测试“推理结果展示”功能，是系统的关键步骤。
前提条件	用户启动后台，打开Web端，进入''规则定义”页面。
测试步骤	1）	用户选择推理范围；
2）	用户进行规则定义并选择推理；
3）	点击“结果”按钮。
预期结果	获取结果并正常展示。
测试结果	测试通过。
2）测试结果。
图6-12和6-13是推理结果展示界面，其中x坐标表示时间，坐标表示拥堵程度, 其中10表示畅通，30表示轻微拥堵，50表示拥堵，70表示严重拥堵。



知识库
Traffic
图6-12推理结果展示界面一
知识库
Traffic
映射定义［推理定义|推理|结果展示|停止展示
道路拥堵状态
30-
20-
18:25:0
18:30:0
18:35:0
18:40:0
18:10:0
18:15:0
18:20:0
图6-13推理姑果展示界面二
（一）后台目标接收模块
1.推理请求响应功能
1）测试用例

表6-12推理请求响应功能
用例口的	该用例用丁?测试“请求响应”的功能。
描述	该用例用于测试“请求响应”的功能，是系统的关键步骤。
前提条件	用户启动后台，打开Web,进入主页面。
测试步骤	1）	用户选择推理范围；
2）	用户输入规则定义数据；
3）	点击“推理”按钮。
预期结果	请求正常响应。
测试结果	测试通过。

2）测试结果
图6-14是推理请求响应成功图。
/Library/Java/JavavirtuaiMachines/idKi^<^_102*iaK/contents/Home/bir
Begin listening in 15100:
Log4j:WARN No appenders could be found for logger (org.eclipse.jetty.util.log).
Log4jjWARN Please initialize the log4j system properly-
log4j:WARN See http://lowaina.aoach/? ora/loa4i/l?html#nocanfia for more i httD：〃locaUwst:15100/dedD 弟
Begin deduce id : 1 scope :福中路 topic : traffic min : 10 severe : 80 medium : 60 slight : 40 speed : 10 福中路<http:/zw
2.结果获取请求响应功能
1）测试用例
表6-13结果获取请求响应功能测试
用例目的	该用例用丁?测试"结果请求响应”的功能。
描述	该用例用丁测试'‘结果请求响应”的功能，是系统的关键步骤。
前提条件	用户启动后台，打开Web,进入主页面。
测试步骤
定产十 --k: :::■	1）	用户选择推理范围；
2）	用户输入规则定义数据；
3）	点击“结果”按钮。
预期结果	后台正常响应，运行正常。
测试结果	测试通过。

2)测试结果
图6-15是结果获取请求响应成功时的输出界面。
图6-15结果获取请求响应成功界面
6.2.2知识库模块功能测试
(-)知识库存储模块
1.添加知识库功能
1)测试用例
表6-14知识库添加功能
用例目的	该用例用于测试“知识库添加”功能。
描述	该用例用于测试“知识库添加”功能，是系统的关键步骤。
前提条件	生成DataFactory对象。
测试步骤	　调用 createDatasetByName()接口，传入参数 test。
预期结果.	知识库添加成功，文件系统生成相应文件夹。
测试结果	测试通过。
2)测试结果
图6-16是知识库添加成功界面。



图6?16知识库添加成功图

2.删除知识库功能
1）测试用例
表6-15知识库删除功能
用例目的	该用例用「测试“知识库删除”功能。
描述	该用例用丁测试“知识库删除”功能，是系统的关键步骤。
前提条件	生成DataFactory对象。
测试步骤	调用 removeDatasetByName()接 口，传入参数 test 1 o
预期结果	知识库删除成功，删除相应文件夹。
测试结果	删除成功，测试通过。
2）测试结果
图6-17知识库删除之前的界面，图6-18是删除成功的界面。

图6-17知识库删除之前图



图6-18知识库删除成功图
表6-16 SPARQ查询功能
用例目的	该用例用于测试"SPARQL査询”的功能。
描述	该用例用于测试"SPARQL査询”的功能，是系统的关键步骤。
前提条件	生成DataFactory对象。
试步骤	1)调用 getDatsetByName(utesf,)获得数据集；
<	2)生成 SparqlQuery；
3）编辑SPARQL査询语句；
4）调用查询接口。
预期结果	査询测试，根据查询语句生成正确査询结果。
测试结果	测试通过。
2）测试结果
图6-19是SPARQL查询语句，图6-20是SPARQL查询结果界面。
Dataset Factory dataset Factory = new DatasetFactoryO;
Dataset dataset = dataset Factory. getDataset ByName ( datasetName: utestn)；
SpajrglQuery sparqlQuery = new SparqlQuery(dataset);
String querystring = 11 PREFIX info: <http://www.semanticweb?org/traffic~ontology#> *" + “SELECT * where {“ + Hinfc:福中路?p ?o |}“ ；
ResultSet resultSet = sparqlQuery.queryDataset(queryString):
. ^ ^
ResultSetFormatter.out(resultSet);
图 6-19 SPARQL 语句

图6-20 SPARQL查询结果输出
6.2.3推理部分功能测试
（-）目标解析与一阶逻辑转化
目标一阶逻辑子句生成功能
1）测试用例
表6?17目标一阶逻辑表达式生成功能
用例目的	该用例用丁?测试“目标一阶逻辑表达式”功能。
描述	该用例用丁?测试“目标一阶逻辑表达式”功能，是系统的关键步驟。
前提条件	启动后台，打开Web界面。
测试步骤	1）	用户选择推理范围；
2）	用户输入规则定义数据；
3）	点击“提交”按钮。
预期结果	目标翻译成功，生成相应一阶逻辑表达式。
测试结果	测试通过。
2）测试结果
图6.21是翻译目标定义图，图6-22是翻译目标生成的一阶逻辑表达式图。
约束定义
道路
红岭中路
严重拥堵定义：缓速车量比例
拥堵定义：缓速车量比例
轻徹拥堵定义：缓速车■比例
最小故据01
缓速阕值定义



图6?22目标一阶逻辑表达式输出图
2.描述逻辑子句获取功能
1）测试用例
表6-18描述逻辑子句获取功能
用例目的	该用例用于测试“描述逻辑子句获取”功能。
描述	该用例用于测试“描述逻辑子句获取”功能，是系统的关键步骤。
前提条件	提供本体输入流。
測试步骤	1)生成 ParseOWLToDLOntology 对象；
2)调用 parse 接口获取 DLOntology；
3)获取d(Clauses成员变量。
预期结果.	获取成功，输出相应的描述逻辑子句。
测试结果	测试通过。
2）测试结果
图6-23是生成的描述逻辑子句输入图。



图6-23生成的描述逻辑子句输出图
3.Z3函数生成功能。
1）测试用例。
表6-19 Z3函数生成功能
用例目的	该用例用于测试"Z3函数生成”功能。
描述	该用例用丁?测试"Z3函数生成”功能，是系统的关键步骤。
前提条件	已经生成dlClauses集合。

（续上表）
测试步骤	1 ）生成 FuncDeclGenerate 对象；
2）	调用 getFuncDecl 接口;
3）	获取包含Z3函数的全局map。
预期结果	生成止确的Z3函数。
测试结果	测试通过。
2）测试结果。
图6-24是生成的Map输出图，左边是map的Key,对应函数名。右边是对应的Z3 函数。



图6-24 Z3函数输出界面
4. 一阶逻辑表达式转化功能。
1）测试用例。
表6-20 一阶逻辑表达式转化功能
用例目的	该用例用丁?测试“一阶逻辑表达式转化”功能。
描述	该用例用「测试“一阶逻辑表达式转化”功能，是系统的关键步骤。
前提条件	已经生成diClauses集合并生成了 Z3函数。
测试步骤	1）	生成0WLToZ3对象；
2）	调用parse接口；
3）	获取结果。
预期结果	测试成功，生成本体相应一阶逻辑表达式。
测试结果	测试通过。
2）测试结果。
图6-25是通过应用Z3函数生成的布尔表达式。
勰剪"滸風冬.田"徂』￡;^.皿京做史膈￥令(。盘JV
(=(［如 JD：//雄n\ se^3r rl^-wb.pr^t raf f i$H?ntQ.loq^ha5Y；<> |
j<SttP；ZZ5wx '>内。.8￡竖如_5￡0/1*.0拦小9里3的滨35
图6-25应用Z3函数一阶逻辑表达式输出界面
（-）推理模块
1.范围推理功能
1）测试用例
表6-21范围推理功能
用例H的	该用例用于测试“范围推理”的功能。
描述	该用例用于测试“范围推理”的功能，是系统的关键步骤。
前提条件	启动后台，打开Web界面。
测试步骤	1）	用户选择推理范围；
2）	用户输入规则定义数据；
3）	点击“推理”按钮。
预期结果	正确推理出属于目标范围内的事件。
测试结果	测试通过。
2）测试结果
图6-26是推理过程中范围推理输出结果图。
Document{{id=l, time=1303722300000, value=70}} vht￡D：//wx俄■? §応费 anticweb. orq/traf f ic-orrtoloqy偏中路 p4> 在推理范围内 solverList.sizeO : 3
Mon Apr 25 17:10:00 CST 2011 size : 13
solverList.sizeO \ 3
Mon Apr 25 17:15:00 CST 2011
size : 14
Document{{id=l, time=1303722900000, value=70}}
vhtt p * 7/www?sei理yt icweb ? o hi/1 ra f f ic二 ontology^福中路
6-26范围推理输出结果
2,目标一阶表达式推理及结果存储功能
1）测试用例
表6-22目标一阶表达式推理功能测试
用例目的	该用例用丁-测试“目标一阶表达式推理”的功能。
描述	该用例用丁-测试“目标一阶表达式推理”的功能，是系统的关键步骤。
前提条件	用户启动后台，打开Web,进入主页面。
测试步骤	1）	用户选择推理范围；
2）	用户输入规则定义数据：
3）	点击“结果”按钮。
预期结果	推理岀结果并存储到数据库。
测试结果	测试通过。

2）测试结果
图6-27是获得的推理结果输出界面。
MongoDB Enterprise > db.traffic.findO
{ ,,_idn : ObjectId(,,5871ad901e89270e458e2d64"), "id11 < ： Objectld(',5871ad911e89270e458e2d65"), "id" { : Objectld(“5871ad911e89270e458e2d66”)， "id" { " id" : ObjectId("5871ad911e89270e458e2d67H), “id” { H id" : Obj ectld(?,5871ad911e89270e458e2d68H), ”id” { H id” : Objectld(,,5871ad911e89270e458e2d69")/ "id” { ** id1' : Objectld(u5871ad911e89270e458e2d6au), “id” { " id" : Objectld(“5871ad911e89270e458e2d6b“), "id" { "id" : Objectld(,,5871ad931e89270e458e2d6c,')/ ,,idH {，Lid" : Objectld(,,5871ad931e89270e458e2d6d,'), “id”
图6-27推理结果

6.3性能测试
性能测试主要从两个方面进行性能测试，知识库的查询性能和推理模块的处理速度。
表6-23测试环境配置
操作系统	Ubuntu Server 14.04 LTS
Java虚拟机	Java Runtime Environment 1.8.0 l 12
Z3版本	4.5.0
Hermit版本	1.3.8
Jena版本	3.1.1
TDB版本	3.1.1
MongoDB 版本	3.4.0

北京Illis I li X学工学硕I：学位论文
由于的测试环境的PC机，同时所有需要的软件都在同一台机器上部署，模拟数据 发布。所以通过多线程发送数据来模拟压力测试，查看知识库的响应性能和推理模块的 处理速度。测试用例如表6-24所示。
表6-24知识库SPARQL查询性能测试
用例目的	测试知识库SPARQL査询的性能。
测试应用	编写不同WHERE子句的SPARQL查询测试用例。
用例产生	直接编写Java代码SPARQL査询语句。
测试步骤	1）	分别产生 10000、30000、50000、100000 次査询。
2）	通过测试査看不同情况下处理总时间和平均每次査询 消耗时间。
3）	记录下相关数据并绘制图表。
对知识库进行SPARQL查询时的测试结果如表6-25所示：

6-25 SPARQL查询性能测试结果一
査询请求数
-	SPARQL 语句中 Where
子句中的条件个数	总耗时ms	平均毎次査询耗时US
10000	1	835	83
10000	2	956	95
10000	3	961	96
10000	5	1190	119
30000	1	2214	73
30000	2	2832	94
30000	3	2997	99
30000	5	3568	118
50000	1	3584	71
50000	2	4387	87
50000	3	4753	95
50000	5	6565	131
100000	1	7694	76
100000	2	8783	87
100000	3	9658	96
100000	5	12499	124

SPARQL查询测试总时间



?" Where限制个数1	Where限制个数2
f-Where限制个数3	Where限制个数5
图6-28 SPARQL查询测试总时间
SPARQL查询测试平均时间



'? 	Where限制个数1	Where限制个数2
Where限制个数3	Where限制个数5
图6-29 SPARQL查询测试平均时间
分别进行10000、20000、50000、10000次査询知识库，性能测试结果图表明，影 响SPARQL的因素主要是Where子句个数，Where子句个数越多，查询总时间和平均 时间越长。
表6-26推理性能测试一
用例目的	测试推理模块的性能
测试应川	用户定义推理日标并发送请求。
事件产生	直接读写文件数据，控制读写频率。
测试步骤	1）	在福中路、金田路、翠竹路、红岭中路四个模型中分别 选取一个、二个、四个模型，并且每个模型构建四个实 例放入知识库中进行推理。
2）	事件产生器每秒分别产生1000、2000、5000、10000、 20000、50000数据，推理区间为30秒。
3）	通输出结果査看每秒事件处理数量。
4）	记录下相关数据。

事件推理的测试结果如图6-30所示:
每秒处理事件量
20000
18000
16000
14000
12000
10000
8000
6000
4000
2000 0


图6-30每秒事件处理数量图
图6-30是对推理模块的压力测试结果，同样把所有的软件都部署在普通PC机上, 分别每秒发送1000、2000、5000、10000、20000、30000、50000数据（本例中主要是 深圳出租车的GPS数据），采用不同的模型数，可以看出，影响性能的主要因素是每 秒发送数据量、模型数量。随着发送数量的增加，吞吐量随之增加，到50000/s左右到 达峰值，并且随着模型的增加，吞吐量减少，事件处理性能下降。
表6-27推理性能测试二
用例H的	测试推理模块的性能
测试应用	用户定义推理目标并发送请求。
事件产生	直接读写文件数据，控制读写频率。
测试步骤	1）	选取福中路一个模型，分别为此模型构建5、10、15、 20个位置实例并加入知识库中进行推理。
2）	事件产生器每秒分别产生1000、2000、5000、10000、 20000、3000、50000 数据。
3）	数据推理时间周期为一分钟和五分钟，此区间根据数 据携带的原始时间而定。
4）	通过输出结果查看每秒事件处理数量、事件平均处理 时间。
5）	记录下相关数据。

不同资源实例下每秒处理事件量一
20000
18000
16000
14000
12000
10000
8000
6000
4000
2000
0
1000	2000	5000
f-5实例
图6?31推理窗口为二分钟结果图
不同资源实例下每秒处理事件量二

1000	2000	5000	10000	20000	30000	50000
5实例 10实例一象 5 0实例

图6-32推理时间窗口为五分钟结果图
图6-28到6-29是对推理模块的压力测试结果，同样釆用每秒发送1000、2000、5000、 10000、20000、30000、50000数据（本例中主要是深圳出租车的GPS数据）的方法进 行性能测试，从结果可以看出，影响推理性能的主要因素是每秒发送数据量、模型包含 的实例数量以及一次推理的推理时间窗口大小。推理时间窗口的长短决定了一次推理使 用的数据量，数据量越大导致一次推理的时间更长，所以时间窗口越长推理性能下降。 如图所示，模型实例的增加明显导致吞吐量下降，分析其原因主要为模型实例的增加一 方面使得对事件进行映射的时间增加，另一方面也导致根据模型信息生成的布尔表达式 增加，因此在进行事件范围推理时增加了范围推理Solver的推理时间，从而使得事件处 理时间相应增长，进而影响事件处理的吞量。
6.4本章小结
本章从功能和性能两个方面对文中实现的系统做了详细的测试和验证。其中功能性 测试主要针对平台提供的知识库管理、推理目标定义和结果展示等功能进行了测试，描 述了各模块功能的测试用例，以图表的方式对测试结果进行了展示。性能测试方面则主 要是针对知识库的查询和推理模块对事件的处理进行相应的测试，并从事件处理时间、 SPARQL查询处理里等性能指标对测试结果进行了统计和展示。

第七章总结与展望
7.1论文总结
本论文在深入研究本体建模在物联网中的应用以及逻辑推理的基础上，借鉴面向对 象的一些思想，设计并实现了基于模型的物联网知识子系统。并将知识子系统的实现主 要分为四个模块：用户接口、知识库的管理和查询、数据的接入以及推理功能模块。本 论文完成的工作主要包括：
(1)对基于物联网服务系统中的知识子系统所使用到的相关技术进行了调研，包 括本体及其描述语言、本体建模工具、描述逻辑与一阶逻辑的转化、Jena语义Web框 架、一阶逻辑推理库Z3、本体推理器Hermit等。
(2)从功能性和非功能性共两个方面对知识子系统进行了需求分析，给出了各个 模块的详细用例图。然后阐明了知识管理平台中各个模块的功能结构，流程设计，最后 给出了知识子系统的整体架构设计。
(3)对物联网知识子系统中的具体的模块的详细设计和实现进行了阐述。包括用 户接口、知识库的管理与查询、事件接入模块的实现、推理功能及其子模块如目标的解 析和加载、一阶逻辑子句的生成转化、推理的实现等进行了详细的设计与实现。在介绍 过程中，主要通过对具体实现类的功能介绍及其核心代码进行了详细的说明。
(4)从功能和性能两个方面对文中实现的系统做了详细的测试和验证。其中功能 性测试主要针对平台提供的用户接口、知识库管理、推理等模块的功能进行了测试，描 述了各模块功能的测试用例，以图表的方式对测试结果进行了展小。性能测试方面则主 要是针对知识库的查询和推理模块对事件的处理进行相应的测试，并从SPARQL查询 处理时间、事件处理时间等性能指标对测试结果进行?了统计和展示。
7.2下一步研究工作
本论文在深入研究物联网知识建模的基础上，借鉴事件驱动的?些思想，设计并实 现了基于模型的物联网服务系统中的知识子系统，県本完成了知识管理系统的设计和实 现和测试。但是还有很多的工作需要进一步的研究与完善：
1)建模部分，目前建模涉及领域太小，信息代太少，卜' ?步需要扩大领域建模范 围，增大知识库，另一方面，知识库的查洵接1丨1丨前来说还能胜任，但在应对大量数据的真实场景会比较吃力，在并行性和查询预处理上有待提高。下一步可考虑将知识库采 用分布式实现，得用负载均衡缓解单一结点的查询压力，从而提高系统效率。
2）	目标定义部分，现有的目标定义阶段提供的算子（函数）太少，对于不同的数 据源有比较固定的定义。下一步的计划是增大函数库，增大系统的应用范围和可用性。
3）	在测试部分，对各个模块进行了功能性的测试并使用真实世界的数据进行了流 程测试，但由于没有在真实的环境中的使用，所以仍然不知道真实情况下使用的结果。 所以下一步的工作是采用真实环境对知识子系统的进行测试，根据使用的结果再对系统 进行完善和进一步的修改。
4）	在性能方面，由于推理模块目前还是单机模式，推理性能有所限制，在大量事 件处理场景会导致性能下降，而且本论文所使用的计算环境还不复杂，所以还得进一步 开发。

参考文献
[1]吴思齐.物联网资源建模工具的设计与实现[D].北京：北京邮电大学,2014.
[2]MLAITU-T Y. Overview of ubiquitous networking and of its support in NGN [J]. ITU-T Recommendation, 2009, 32(1): 153-167.
[3]Open Geospatial Consortium. OpenGIS SWE Service Model Implementation Standard[J]. Open Geospatial Consoritum, 2011, 10(1): 155.
[4]王洪微.知识本休模型下的不…致推理机制研究[D].大连：大连海事大学,2013
[5]Boulos M N K, Resch B, Crowley D N, et al. Crowdsourcing, citizen sensing and sensor web technologies for public and environmental health surveillance and crisis management: trends, OGC standards and application examples[J]. International journal of health geographies, 2011, 10(1): 1.
[6]Borgida A. On the relative expressiveness of description logics and predicate logics[J], Artificial intelligence, 1996, 82(1): 353-367.
[7]周明.物联网应用若干关键问题的研究[D].北京：北京邮电大学,2014.
[8]赵帅.物联网资源管理框架及服务提供平台[D].北京：北京邮电大学,2014.
[9]Prud'Hommeaux E, Seaborne A. SPARQL query language for RDF[J], W3C recommendation, 2008, 19(7): 1 15.
[10]Bechhofer S. OWL: Web ontology language/ZEncyclopedia of Database SystemsfM]. US: Springer, 2009: 2008-2009.
[11]张雪.基于物联网业务平台的设备管理方法研究与实现[D].北京：北京邮电大学, 2014.
[12]刘佩云.基于本体的物联网设备共『信息模型的研究与实现[D].北京：北京邮电 大学,2013.
[13]王莉.基于本体的知识检索系统研究与实现[D].青岛：中国海洋大学,2008.
[14]李丽.基于本体的网页文本分类的研究[D].北京：北京交通大学,2008.
[15]杨柳.模糊本体建模方法及语义信息处理策略研究[D].长沙：中南大学,2011.
[16]王辨，何克清，刘进.基于OWL元模型的本体建模研究卩].武汉大学学报：理学 版，2004, 50(5):581-585.
[17]Eiter T. lanni G. Lukasiewicz T、et al. Combining answer set programming with description logics for the semantic web[J]. Artificial Intelligence, 2008, 172(12): 1495-1539.
[18]秦小燕.■阶逻辑系统的计量化硏究[D].成都：西南交通大学,2015.
[19]Borgida A. On the relative expressiveness of description logics and predicate logics[J]. Artificial intelligence, 1996, 82(1): 353-367.
[20]徐贵红,张健.l吾义网的一阶逻辑推理技术支持[J]. Journal of Software, 2008, 19(12): 3091-3099.
[21]刘柱子.基于描述逻辑的本体推理技术研究[D].天津：天津理工大学,2015.
[22]Haarslev V, Moller R. Description of the RACER System and its Applications[J]. Description Logics, 2001, 231(2): 49.
[23]Sirin E, Parsia B, Grau B C, et al. Pellet: A practical owl-dl reasoner[J]. Web Semantics: science, services and agents on the World Wide Web, 2007, 5(2): 51-53.
[24]Shearer R, Motik B, Horrocks I. HermiT: A Highly-Efficient OWL Reasoner[C] OWLED. 2008,432(2):91.
[25]Glimm B, Horrocks I, Motik B, et al. HermiT: an OWL 2 reasoner[J]. Journal of Automated Reasoning, 2014, 53(3): 245-269.
[26]De Moura L, Bjorner N. Z3: An efficient SMT solver[A]//Intemational conference on Tools and Algorithms for the Construction and Analysis of Systems[C]. Berlin Heidelberg: Springer, 2008: 337-340.
[27]Brummayer R, Biere A. Boolector: An efficient SMT solver for bit-vectors and arrays[A]//International Conference on Tools and Algorithms for the Construction and Analysis of Systems[C]. Berlin Heidelberg: Springer, 2009: 174-177.
[28]Ball T, Bounimova E, Levin V, et al. Efficient evaluation of pointer predicates with Z3 SMT Solver in SLAM2[R]. Technical Report MSR-TR-2010-24, Microsoft Research, 2010.
[29]Leino K R M. Automating induction with an SMT solver[A] //International Workshop on Verification. Model Checking, and Abstract Interpretation[C]. Berlin Heidelberg: Springer, 2012: 315-331.
[30]Bierman G Gordon A D, Hritcu C, et al. Semantic subtyping with an SMT solver[A]//ACM Sigplan NoticesfC]. New York: ACM, 2010, 45(9): 105-116.
[31]Wintersteiger C M, Hamadi Y, De Moura L. A concurrent portfolio approach to SMT solving[A]//Intemational Conference on Computer Aided Verification[C]. Springer Berlin Heidelberg, 2009: 715-720.
[32]张宗仁，杨天奇.基于自然语言理解的SPARQL本体查询[J].计算机应用，2010, 30(12): 3397-3400.
[33]汪璟埼，方知立，张燕琴.面向分布式的SPARQL查询优化算法[J].计算机科学, 2014,41(7)： 227-231.
(C) 1994-2022 China Academic Journal Electronic Publishing House. All rights reserved.
