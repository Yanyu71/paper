第一章绪论
1.1	研究背景及意义
物联网，作为一种广义上的移动通信网络，并不局限于物与物的连接，而是旨 在打破所有可连接的人与物之间的障碍为用户提供更多的组合可能，从而进一步丰 富人类现有的生活体验I1在物联网中，任何具备智能感知能力的物体,比如传感器、 传统智能设备、可穿戴式设备等，都可以发挥所长随时随地连入“物联广域网”内。
首先，随着物联网概念的逐渐普及和技术的不断发展，物联网，作为一个市场 和应用前景十分广阔的科技领域，为传统的运输物流、医疗卫生、环境保护、个人 生活和社会生活等多方面都带来了新的发展机遇和挑战⑵。近年来，市场上涌现出一 大批与物联网相关的商业项目，这些项目依托物联网推出了前所未有的业务模式和 服务，使得越来越多便捷的智能服务成为可能，比如智能家居场景下的设备联动、 智慧农业下的个性化精准生产等。据Gartner的最新统计数据表明，2016年全球与物 联网相关的产品和服务市场总额将达到2350亿美元，设备总数将达到64亿台，同 比增加30%,因而2016年也被业界称为物联网落地元年［刃。
其次，世界各国对于物联网政策的支持力度也是达到前所未有的历史高度。2016 年中国发布的“十三五规划纲要”明确指出要促进大数据、云计算、物联网的广泛 应用，推进基础设施规划布局，发展物联网开环应用⑷。早在2009年1月，奥巴马 总统就积极响应由IBM首席执行官建议的政府投资新一代智能型基础设施方案，并 在随后出台的经济复苏和再投资法中通过在能源、宽带与医疗三大领域开展互联网 技术应用来鼓励美国物联网的发展⑸，总额高达7870亿美元。2016年8月，欧盟在 国家科研计划 FP7(Framework Program 7)中设立了 IoT-A、IoT6、open IoT 等一系列 项目，通过构建智能电网、交通、城市等多项物联网项目来鼓励物联网行业的发展。 英国通信管理局也在2016年4月份发表了《物联网的甚高频无线电波段》的详细声 明，这一声明确认了目前已经被用于部分物联网、M2M应用以及移动语音通信中的 频带(55-68 MHz、70.5-7L5 MHz以及80.0-81.5 MHz)的合理地位，并宣布用新的 许可证取代现有的商业无线电许可证来支持loT/M2M的发展。2014年5月，韩国提 出IoT物联网基本规划，从服务平台网络到终端设备与信息安全全面构建开放式物 联网IoT生态体系⑹。
综上所述，无论是市场方面还是政策方面，物联网技术都迎来了发展的春天。
1
可以坚信，在未来的岁月，随着各国政策的支持和技术的不断发展，物联网行业必 将呈现一片欣欣向荣的态势，成为世界新一轮的经济制高点。中华民族要实现伟大 复兴就必须在这些新兴科技领域的发展上抓住机会，迎头赶上甚至努力超越其它发 达国家，因而需要有人紧跟时代和科技的潮流，积极投身于这些先进技术领域的学 习和研究。智能家居领域作为物联网的基础领域，在物联网领域起着至关重要的作 用［刀。事实也证明，伴随着近年来物联网领域的发展，智能家居作为物联网领域的重 要分支，重新焕发了生机，并迅速变成了家居行业中的一匹黑马电叫本文正是基于 这样的考虑，希望能以点窥面，通过深入研究智能家居领域的基础技术为物联网领 域的研究沉淀一些基础性的成果，为即将到来的物联网世界大战积蓄力量。
1.2	研究现状
本节将主要从以下三个方面深入介绍物联网行业的研究现状：一是物联网行业 和联盟的整体发展情况；二是物联网领域的联网解决方案和平台发展情况；三是物 联网领域软硬件产品发展情况。
(1)物联网行业和联盟发展
近年来，物联网领域迎来了行业的发展春天。2016年1月5日，Wi-Fi联盟正式 发布适用于低功耗、长距离物联网设备通信的802.11ah Wi-Fi标准。2016年3月， Cassia在蓝牙世界大会上正式发布了蓝牙路由Cassia Hub的SDK,该SDK实现了 服务器和蓝牙设备制造商原生程序的无缝整合，使得终端用户无需改变现有蓝牙设 备便能同时实现对多路蓝牙设备的安全实时控制。
此外，物联网联盟也在近年如雨后春笋般蜂拥而出。2013年，高通联合海尔、 LG等知名厂商成立AllJoyn联盟，后更名为AllSeen联盟，并在2016年融入Open Connectivity Foundation(OCF)以致力于设备互操作性的标准研究。目前OCF成员包 括高通、微软、英特尔、通用电气、伊莱克斯、海尔、三星、ARRIS和电缆试验室
(CableLabs)等众多知名企业。2016年2月，思科以14亿美元现金和股票收购物 联网创业公司Jasper Technologies0而收购之前，Jasper公司的主营业务是将汽车、 喷气发动机及起搏器等设备连接到互联网并通过软件监测平台实时监控这些设备的 工作状态。2016年4月，中国在深圳成立了中国传感器及物联网产业联盟。
(2)物联网联网解决方案和平台发展
随着行业的整体发展,物联网联网解决方案也取得了长足的发展。2015年12月，
2
科技创业公司Afero推出了一个全新的平台用于应对安全连接物联网所需的硬件和 软件需求,该平台可以通过一个安全的蓝牙智能模块和连接到Afero云的移动手机进 行通信。2016年于2月29日，阿里巴巴集团对外宣布阿里集团旗下包括阿里云、阿 里智能、YtmOS等在内的事业群将联合打造面向物联网时代的服务平台。2016年2 月，IBM推出了全新的开源开发工具“Quarks”用于帮助制造商与程序员开发基于 物联网感应数据的高效应用。2016年3月30日,长虹正式发布全球首个开放的物联 运营支撑平台-UP平台(United Platforms)«同年9月，Nuance公司发布了物联网开发 平台 Nuance Mix。
除了平台外，物联网的联网解决方案也在迅速发展。2016年3月10日，京东智 能在中国家电及消费电子博览会上联手东易日盛推出首个落地C端的智能家居解决 方案。Ayla大数据平台也在该展会上公开展示了 Ayla Insights, Ayla Insights集成于 Ayla物联网平台，旨在为硬件制造商提供更具成本效益、更易于使用的物联网数据 分析与商业智能解决方案。展会期间，美满电子科技(Marvell)也面向谷歌的IoT 操作系统Brillo推出了第二款Andromeda Box平台-Andromeda Box是一款可扩展网 关平台，该平台可以帮助客户快速进行IoT网关和智能设备的原型设计及产品开发 和为多种市场灵活开发创新、高性价比和安全的网关解决方案。2016年，华为提出 了基于4.5G技术的eW-IOT解决方案，旨在打造一个更好的统一工业互联平台，以 提供一个实现开放兼容、可靠联接、工业性能、维护便捷、灵活组网、统一接入等 特性的物联网解决方案。
(3)物联网领域软硬件产品发展
2016年1月，Atmel宣布全力支持微信硬件平台开发板计划，助力推动安全无 缝连接微信硬件平台。2016年2月22日，安森美半导体与RFMicron合作开发了一 款“即插即用”开发工具，以加快部署无线无源传感器方案到任何物联网(IoT)云平 台。2016年2月24日，ARM发布最新的物联网CPU ARMCortex-A32芯片。2016 年3月，智能门铃厂商Ring获得6120万美元C轮融资，并推出新产品Video Doorbell Proo 2016年4月6日，微软推出Open Translators to Things,让开发者共同合作开发 翻译器从而简化物联网设备的app开发。
1.3论文研究内容
由于物联网的最终目标是实现万物互联互通，而目前各设备之间缺乏一种统一
3
的有效通讯和管理方式，因而，本文主要研究了设备间的发现、组网和通讯机制。 考虑到智能家居系统中涉及到的设备种类具有很大的差异性，设备采用的通讯协议 也具有多样性，本文在选择研究技术时重点考虑了各技术对通信协议的兼容性和可 拓展性以及设备的异构性三个方面，最终选定高通创新中心公司主导的相对成熟的 AllSeen技术，并基于该技术设计了一套完整的智能家居系统方案。此外，本文还基 于设计方案利用真实的智能硬件产品和开发相应的控制软件搭建了一套真实的智能 家居系统，并基于该系统深入研究了设备的管理和通讯机制。
具体来说，本文主要从以下四个方面深入研究智能家居系统的设备发现、管理、 组网、通讯和控制机制。
(1)搭建了基于AllSeen服务框架的局域智能家居环境，实现对AUSeen标准设备和 AllSeen瘦客户端设备的发现，自由组网和心跳机制检测，设备间的单点和多点 会话建立，和设备间的控制以及设备间的通知机制在内的基础功能，为本文的 研内容奠定真实的实验基础。
⑵ 打破了 AUSeen服务框架目前只支持Wi-Fi协议的局限性，在智能家居系统中引 入定制网关拓展AllSeen服务框架对ZigBee协议的支持，该定制网关的转换模 块可以实现ZigBee设备到Wi-Fi虚拟AllSeen设备的转换。为以后拓展蓝牙、 Zwave协议提供了参考。
(3)提出了蓝牙哑设备动态组网方案，该方案该方案与AllSeen现有的Onboarding 基础服务框架相一致，为AllSeen服务框架提供了一套统一的支持Wi-Fi、蓝牙 和ZigBee等多协议的物联网通信网络解决方案，该方案借助带有图形界面的标 准设备来实现蓝牙哑设备之间的动态组网，拓展了 AUSeen基于蓝牙协议的微微 网和散射网。
(4)改善了 AllSeen服务框架的通信方式，具体来说主要改进了以下两个方面：将 AUSeen服务框架的Event-Action机制拓展为支持CRUD (增删改查)功能的异 步触发机制；在多点通信协议基础上引入分布式代理以进一步优化资源的配置, 从而适应更复杂的功能需求环境。
1.4论文结构安排
本文一共分为五章，具体结构安排如下：
第一章详细介绍和深入分析了智能家居所处的行业背景和政策支持，得出了物
4
联网行业的整体发展趋势和指明了本文的研究意义；并通过对物联网行业发展现状 的深入介绍锁定了本文的主要研究内容。
第二章分别从技术概述和系统架构、基本概念和基础服务框架本文研究的技术 基础-AUSeen做了详细的介绍，为后续的智能家居系统设计提供了理论支持。
第三章基于AUSeen技术设计了一套完整的智能家居系统并详细描述了设计方 案的总体目标、系统架构和参与各类型设备的应用层框架。此外，第三章还深入介 绍了设备组网、管理、通讯、控制等核心模块的实现方法。
第四章介绍了本文根据设计方案利用市场上现有的一些智能硬件、芯片和网关 以及安卓手机搭建的智能家居系统的具体实施方案，并利用搭建的系统对本文的研 究内容进行测试和分析。
第五章认真总结了本文的研究内容和成果，并深入思考了本文可以进一步改进 和完善的地方。此外，还根据本文研究过程中的心得和体验，提出了本文未来的发 展建议。
5
6
第二章 基于AllSeen的智能家居系统技术基础
2.1	AllSeen技术概述
AllSeen服务框架最早由高通创新中心公司于2013年贡献给AllJoyn联盟，后更 名为AllSeen联盟，旨在吸引全球的知名公司、组织和个人积极参与到其研发中并共 同推动AllSeen技术成为物联网行业的标准。从本质上来说，AllSeen服务框架是一 个实现了 D-bus总线协议并将其拓展到分布式总线场景的开源项目，并遵循Apache 2.0版本许可，AllSeen服务框架打破了现有设备之间的通讯障碍，使得设备的互联 互通成为可能，并极大程度地简化了异构分布式移动系统的近邻通信。
AllSeen服务框架在设计之初便追求平台中立性、通信协议和开发语言的独立【助, 为了实现这一目标,AllSeen服务框架的底层分别提供了系统、协议和语言的抽象层。
(1)	AllSeen系统抽象层屏蔽了设备底层操作系统的异构性和复杂性，使得 AllSeen框架能最大程度地独立于所运行设备的操作系统、硬件和软件。到目前为止， AllSeen 服务框架已经可以很好地支持 Windows > Linux、Android、iOS、OSX、Open WRT 和带有Unity插件的互联网浏览器等多种操作系统。
(2)	AllSeen协议抽象层保证了 AllSeen服务框架对物理网络和协议的独立性。该 抽象层为底层的网络协议定义了统一的接口，正是由于接口的统一，为AllSeen拓展 其它支持协议奠定了基础。目前，AllSeen支持PLC、以太网和Wi-Fi等协议。
(3)	AllSeen语言抽象层则解决了开发语言的困扰，该抽象层将非C++的其它开 发语言转换为原生语言从而实现对开发语言的独立。得益于这一抽象层，目前AllSeen 的开发人员可以随意使用C++、Java、C#、JavaScript和Objective-C等多种语言来开 发AllSeen程序。
一个好的服务框架除了考虑到基础功能方面的开发，也会注重安全性。AllSeen 在设计之初也深入思考了应用程序之间的通信安全，使得开发人员在使用AllSeen服 务框架时可以抽身于安全问题。
本文正是出于对AllSeen服务框架在平台中立性、通信协议和开发语言独立性以 及安全性这四个方面体现出来的优势和智能家居领域产品和通信协议的复杂性的双 重考虑，最终选择以AllSeen服务框架作为本文的技术基础。
7
2.2	AllSeen整体介绍
2.2.1	AllSeen网络拓才卜结构
AllSeen网络的拓扑结构根据网络的配置场景可以分为独立AllSeen网络和外界 可达AllSeen网络〔5。独立AllSeen网络和外界可达AllSeen网络最根本的区别在于 网关是否将消息通信锁定在局域网内。
考虑到智能家居技术的发展趋势，本文着重考虑外界可达AllSeen网络拓扑结构, 该网络拓扑结构可以通过定制网关节点利用网络数据和云端进行通讯。具体来说， 该定制网关节点可以将AllSeen网络中的设备功能和控制方法通过标准API暴露给以 云为基础的服务端，这样位于网络外的设备就可以通过以云为基础的服务端来调用 网络中设备的方法和服务，从而实现外网设备对近邻网络中设备服务和功能的发现 和访问，图2-1描述了外界可达AllSeen网络的具体拓扑结构：
图2-1外界可达AllSeen网络示意图
2.2.2	AllSeen 协议栈
AllSeen的协议栈类似于TCP/IP协议，自顶向下由应用层，传输层，网络层,
8
数据链路层以及物理层这五层构成。具体的协议栈如图2-2所示。由于普通开发者在 研发过程中主要涉及到的是应用层，在此重点介绍应用层。
总体来说，应用层可以进一步细分为应用服务、服务框架、AUSeen核心库和 AUSeen路由四层。其中，应用服务位于应用层的最上层，主要负责应用的具体的服 务和功能；AUSeen服务框架位于应用服务的下层，从本质上来说，服务框架和应用 层并没有区别，这两层都通过AllSeen的接口定义向外提供服务，只是应用服务以应 用形式向局域网内其它设备提供功能和服务，服务框架则以API方式向应用服务提 供公共基础服务；AllSeen核心库主要实现AllSeen的底层基础服务；AllSeen路由层 主要负责应用程序与AllSeen后台路由的通信，实现包括广播和发现服务、建立和销 毁会话、发送和接收无会话信号以及保障通讯安全等在内的功能。其中，路由层中 的传输抽象层使得AllSeen服务框架支持多种通信协议成为可能。
AllSeen协议栈
All Seen 设备 | 应用服务一
国 服务框架
三| AHSeen核心库
AUSeen路由
I传输抽象层I
传输层（有线,无线）
网络层＜ IP层和非」P层）
数据链路层 iwi
AllSeen高层系统框架
系统和语言绑定（可选）
辅助	总线附件
安全代理总线对象总线对象AllSeen总线D总线
信息和路由
终端
本地网络传输层
操作系统抽象层
本地系统
图2-3 AllSeen高层系统框架
图2-2 AUSeen协议栈
2.2.3	AllSeen系统框架
AUSeen的高层系统框架如图2-3所示，系统和语言绑定层位于最高层，主要用 于屏蔽开发语言的差异性。AUSeen本身使用C++编写，对于其它语言，比如Java、 JavaScript等，AllSeen通过该轻量级转换层-系统和语言绑定层来实现兼容。辅助对 象层通过提供总线附件、总线对象和代理总线对象大大简化了 AllSeen的开发工作。 信息和路由层主要负责消息的转发。终端层位于消息和路由层之下，终端端点是专 门用于负责提供最基本的网络功能的传输实体，所有有关网络的抽象在终端层已经
9
全部实现，所以从终端的角度来看，不管AllSeen的底层网络采用的是无线连接的 Wi-Fi、有线以太网连接的PLC或是其它拓展性的通信协议都不具有任何差异性。本 地传输是客户端、服务端或对等端中唯一使用的网络传输，本地传输用来连接本地 AllSeen总线后台程序进行本地进程通信。在不同的操作系统，本地传输的表现形式 也不一样，比如，在基于Windows的系统中本地传输是一个和本地后台程序连接的 TCP连接，而在基于Linux的系统中，本地传输则为一"基于Unix的socket连接。 此外，AllSeen还提供了一个操作系统抽象层来屏蔽硬件操作系统的差异性，本地系 统位于AllSeen系统的最底层口4
如果进一步抽象AllSeen服务框架，可以发现AllSeen设备由应用、AllSeen的 路由/后台程序和操作系统构成，根据操作系统的不同，可以将AllSeen设备分为 AllSeen标准设备和AllSeen瘦客户端应用两种类型皿，图2/描述了这两种设备 类型的系统框架。一般来说，AllSeen标准设备的功率、内存和CPU相对瘦客户端 设备而言要相对充足。
AllSeen标准设备
AllSeen标准应用
应用代码
AllSeen标准服务框架
AllSeen核心标准库
AllSeen瘦客户端设备
AllSeen瘦应用 ―应用代码—
AllSeen瘦客户端服务框架
AllSeen瘦客户端核心标准库
AllSeen 路由
非嵌入式操作系统 （例如安卓，windows, ios, Linux, Mac OSX）
RTOS,嵌入式操作系统 （例如Arduino, ThreadX等）
图2・4 AllSeen设备类型
10
2.3	AllSeen基本概念
2.3.1	AllSeen总线和路由
AllSeen系统在实现D-Bus总线协议的基础上，通过增加新的标志和头文件成功 将D-Bus通信模块拓展到分布式总线场景。AllSeen总线，作为AllSeen服务框架最 抽象的基础概念，为分布式系统提供了一种快速轻量序列化的消息传递方式【⑸。 AllSeen总线分为系统总线和会话总线两类，系统总线负责设备内部消息传递，会话 总线负责设备间消息传递[⑹，这两种逻辑总线均由AllSeen路由实现，具体结构如图 2-5和2-6所示，其中直线代表系统总线，折线代表会话总线。
图2-5 AllSeen系统总线	图2-6 AllSeen会话总线
路由，作为AllSeen的核心概念，实现了 AllSeen逻辑总线的功能，具体包括广 播和发现应用的服务、建立会话连接、广播信号和数据以及转发消息、，使得服务端 或客户端的应用程序能够通过调用AllSeen服务框架的核心功能实现与总线的通讯 [17],如图2-7所示。
图2-7 AllSeen路由示意图
11
从本质上来说，AUSeen服务框架是一个端对端的通信协议，最终设备与设备之 间的通信就是路由与路由之间的通信。应用消息需要通过路由才能广播到总线，对 于每一个特定的路由都可能处于两个状态，或者绑定在特定的应用之内，或者作为 一个独立的应用存在同时为被多个应用提供服务，如图2-8-a和2-8-b所示。
图2-8 a）应用捆绑路由b）应用共享路由
在此，需要特别强调的是，只有AUSeen标准设备才有路由口阴，瘦客户端设备由 于受限于功率、内存、和CPU, 一般都只包含应用代码和AUSeen瘦客户端核心库， 并不包含路由，那么瘦客户端程序又怎么将应用的消息广播到总线呢？运行在 AUSeen瘦客户端的轻量级应用会寻找近邻网络中标准客户端的路由，并借助该路由 进行广播和发现，以及与其他设备建立连接。瘦客户端通过TCP协议与标准客户端 的路由进行通信，具体示意图结构如图2-9所示：
瘦客户端AHSeen设备
标准AUSeen设备
应用
服务框架	应用服务
应用
服务框架	应用服务
AllSeen瘦客户端核心库
AHSeen核心库
AHSeen路由
图2-9瘦客户端与标准客户端路由通信才匡架
12
2.3.2	AHSeen总线附件
绑定在服务端或客户端应用中的路由往往以后台程序运行，而应用则与用户在 前台交互。这意味着路由和应用位于不同的进程中，无法实现直接通讯。然而，应 用消息需要通过路由广播到总线上，为了解决这一问题，AllSeen服务框架在AllSeen 应用中创建一个实体类来代表路由实现和应用的通讯。这个位于应用进程的路由''代 理”，被称之为AllSeen的总线附件口叫 负责到每条AllSeen总线上的连接。每一个 需要和AllSeen总线连接的进程都需要通过总线附件来转发消息。
创建总线附件时，可以通过定义枚举值BusAttachment.RemoteMessage来设定总 线附件对远程消息的处理策略，当枚举值为Ignore时代表不接收来自远端设备的消 息，当枚举值为Receive时代表接收来自远端设备的消息。
由于总线上会连接许多总线附件，为了保证消息能在总线上准确传输，总线上 的每处连接都必须具有唯一的标识符。因而AllSeen服务框架在创建总线附件时会自 动为每个总线附件分配一个全球唯一的标识符(GUID)作为临时总线名称。虽然 GUID有效地保证了每个总线附件的唯一标识性，但每次重新启动AllSeen路由时， AllSeen服务框架就会重新给总线附件分配新的GUID,且往往不同于上次，因而 AllSeen服务框架无法通过GUID来长期标识特定总线附件。为了解决这个问题， AllSeen AllSeen引入了 WKN (well-known name)名称用来长期标识总线附件。WKN 名称命名规则符合D-Bus协议的命名惯例和准则。具体来说，总线附件在向路由请 求WKN名称时会通过如表2-1所示的标识符来确保WKN名称的唯一性。
表2-1 AllSeen的数据类型
标识符	意义
ALLSEEN_REQUESTNAME _FLAG_DO_NOT_QUEUE	如果不能马上获取请求的名字， 那么该请求失败
ALLSEEN_NAME_FLAG _ALLOW_REPLACEMENT	允许其它总线附件覆盖当前总线附 件拥有的名字
ALLSEEN_REQUESTNAME _FLAG_REPLACE_EXISTING	允许当前总线附件覆盖申请名字， 即使其它总线附件已使用该名字
13
2.3.3	AllSeen总线对象与代理总线对象
AllSeen总线接口提供了一种声明分布式系统接口的标准方式，约束了应用向外 暴露的服务。AllSeen总线对象负责实现这些接口的具体逻辑，并以树的存储结构作 为通信终点存在于总线附件中。由于应用可能对于同一总线接口有多个实现版本， 总线附件中可能存在多个总线对象，为了区分这些总线对象，AllSeen服务框架引入 了对象路径的概念。对象路径和接口名称在本质上并没有区别，这两者都是命名空 间中的字符串，只是接口名称位于接口命名空间，采用树形结构存储，对象路径位 于对象路径命名空间，采用类似于文件系统的目录树存储，使用斜杠字符作为路径 分隔符。由于总线对象实现了总线接口，因而对象路径一般也遵循相应的接口命名 规范，如果有多个实现版本，就在接口名后继续添加不同的字符串以示区分。
类似于RMI, AllSeen客户端通过调用本地代理总线对象来访问服务端总线对象 从而获取特定服务。AllSeen代理总线对象作为AllSeen的基本概念之一，通过总线 方法、总线信号和总线属性向总线传输相关信息。AllSeen应用提供了与具体编程语 言所绑定的代理对象。该代理总线对象与远程服务端总线对象实现了相同的总线接 口，使得从客户端的角度来看，代理总线对象与服务端总线对象并无差异，然后直 接调用代理总线对象相应的方法或信号，代理总线对象会封装相应的参数并通过
AllSeen总线将这些参数转发到服务端的总线对象加以调用，具体流程如图2-10所示。
图2-10总线对象与代理总线对象工作原理
总线 对象树
14
2.3.4	AUSeen总线接口成员
AllSeen是一个面向对象的服务框架，系统依靠各种类型的对象交互得以运行。 类似于其它面向对象的编程语言，AUSeen服务框架也通过总线接口定义相应的方法 和属性并以接口的方式向外暴露服务，AllSeen对象通过实现这些接口来获取相应的 方法和属性。在AUSeen系统中，接口规范按照D-Bus规范采用XML进行描述，在 此，给出AUSeen底层接口的例子，如下所示：
<node name-7example,,>
interface name=,,bupt.edu.cn.example,,> <!—接 口名称-->
<method name=,,method,,><!—方法节点，定义方法名称-->
<arg name="inStr" type="s" direction="in"><!一定义入参名称类型-->
<arg name="outStr" type="s" direction="out"><!—出参名称及类型 </method>
<signal name-,signal,,><!—信号节点,定义信号名称
<arg name="content" type="s”><!一定义信号内容类型-->
</signal>
</interface>
</node>
在开发时，并不需要通过编写如此复杂的XML来定义接口，类似于Spring, AllSeen也采用注解的方式来定义某一类型的数据，利用@BusInterface来进行接口定 义即可将普通接口转换为AllSeen接口。AllSeen将AllSeen总线对象实现的接口方 法称为总线方法，总线方法可以当作服务被远端应用调用。在AllSeen开发中，以 @BusMethod来区分总线方法和普通方法。AllSeen服务框架通过信号来通知客户端 服务端对象的状态变化或是异步事件。AllSeen中总线信号的定义方式为@BusSignal。 AllSeen中信号主要分为单播信号和多播信号两类，其中单播信号是点对点的单向信 号，多播信号是一对多的信号。AUSeen服务框架除了可以定义总线方法，还可以通 过@BusProperty定义总线属性，以方便远端客户端程序来读取和修改服务端对象的 属性。
在此需要特别强调的是，AllSeen服务框架的数据发生一般都发生在会话之中， 除了 AllSeen服务框架提供的特殊多播信号，不针对会话的信号，该信号独立于会话 而存在，只要应用订阅了不针对会话的信号，即使在服务端在发送信号时，客户端
15
和服务端之间尚未建立会话，客户端也能接收到服务端发送的信号。
开发者既可以通过总线方法、信号和属性进行设备之间的联动控制，也可以利 用AllSeen服务框架的Event-Action机制进行联动。AllSeen服务框架的Event-事件 与Action-动作机制沿袭和拓展了 AllSeen的总线信号和方法网。具体来说，事件Event 是AllSeen中带有描述信息的信号，主要向用户描述该信号对应的某一现象或是结果。 动作Action是带有描述信息的方法，主要向用户描述该动作的对应的操作和行为。 在AllSeen服务框架中，Event与Action主要用来描述设备的联动，其中，事件被用 来作为动作的触发源，也就是说，当相应的事件发生后，与之相对应的一个或多个 动作便会被触发以响应相应的信号。事件和动作的描述信息，分别构成了 AllSeen联 动操作的前半句和后半句。
2.4	AllSeen基本数据
2.4.1	AllSeen数据结构
AllSeen系统框架延续了 D-Bus协议的数据类型和数据封装、解封装方法。采用 统一的标准方式实现数据类型到wire格式的相互转换。表2-2描述了 AllSeen预定义 数据类型的ASCH码，开发时，可以直接使用ASCII码指定底层数据交换时使用的 数据类型或是组合。
表2-2 AllSeen的数据类型
数据类型	ASCII	数字码	签名内含
INVALID	NULL	0	无效类型码，用于结束签名
ARRAY	'a'	97	数组
VARIANT	'v'	118	可变类型
UINT64	'x'	120	64位有符整数
BYTE	'y'	121	8位无符整数
STRUCT	，r"（和），	114,40,41	结构体
DICT_ENTRY	七"｛和y	101,123,125	字典或是map中的键值对
BOOLEAN	'b'	98	布尔值：0代表假1代表真
DOUBLE	d	100	IEEE 754浮点数
SIGNATURE	'g'	103	类型签名
16
续上表2-2 AUSeen的数据类型
数据类型	ASCII	数字码	签名内含
INT32	'i'	105	32位有符整数
INTI 6	'n'	110	16位有符整数
OBJECT_PATH	'o'	111	对象名称
UINT16	'q'	113	16位无符整数
STRING	's'	115	UTF-8字符串,以NULL结尾
UINT32	'u'	117	32位无符整数
2.4.2	AllSeen数据匹配
由于AUSeen服务框架发送的多播信号涉及到多重端点的接收和处理，因而无法 在服务端进行信号限流，这也意味着客户端会收到无关信号和进行冗余唤醒。为了 解决这个问题，AUSeen服务框架沿袭了 D-Bus的匹配机制来限定客户端路由接收和 处理特定信号。AllSeen服务框架通过路由的AddMatch方法为路由添加匹配规则， 匹配规则以逗号分隔的键值对字符串进行描述。
AllSeen路由支持多项规则匹配，如果匹配的多条规则导致消息集合发生冲突， AllSeen路由采用最大集合规则。具体来说，AUSeen服务框架支持如表2-3所示的匹 配规则字段：
表2-3 AllSeen匹配规则
关键字	可取值	描述
type	信号、方法调用、 返回、错误	匹配消息类型
sender	WKN 或 unique 名	匹配发送方
interface	接口名称	匹配特定发送接口，如果省略匹配所有接口
member	有效方法名、信号名	匹配拥有特定方法或信号名称的信息
path	对象路径	匹配由特定对象发送或发送到该对象的信息
path_names pace	对象路径	支持模糊匹配到指定对象路径或是以字符串 开头的对象路径，不能和path同时使用
destination	unique 名	匹配指定字符串的unique名称
17
2.4.3	AUSeen数据报文
AllSeen设备通过总线方法、信号或属性进行数据交互，因而，AllSeen框架引 入了 METHOD_CALL、METHOD_RETURN 和 SIGNAL 三个新标志来拓展 D-BUS 的底层消息报文格式。这三个标志分别用于标识AllSeen服务框架调用、响应总线方 法或是发送总线信号时使用的消息类型。此外，AUSeen服务框架还定义了 ERROR 消息格式专门用于标识调用方法时发生故障的异常信息。虽然这四种消息使用的场 景各异，但它们共同组成了 AUSeen的基础消息报文集。
为了进一步了解AllSeen的消息报文，图2-11描述了 AllSeen的消息报文格式。 字节顺序标识标明了 AllSeen消息报文采用的字节顺序，其中ASCH字符代表 小头字节序，'B'代表大头字节序；消息类型描述了 AHSeen报文的类型，AllSeen 一共支持如下五种报文格式，INVALID代表无效消息，METHOD_CALL代表方法调用消 息，METHOD_RETURN代表方法结果返回消息，ERROR代表方法调用异常，SIGNAL代表 信号信息，分别用数字0,1, 2, 3, 4表示；头标识是头域的按位或，其中有关头域定 义详见表2-4；协议版本描述了消息发送方使用的AHSeen协议版本；消息体长度定 义了 AHSeen报文的长度，从报头结尾开始计算，单位为字节；表2-4描述了 AUSeen 消息报文中各个字段所代表的含义；消息序列是发送方给AllSeen报文赋值的非零数 字，主要用于识别响应的AUSeen报文；头域链表，由（字节，变量）数组或是结构 体构成，每位成员分别代表不同头域的域码和相应的取值；消息体为AllSeen报文 需要传送的数据。
图2・11 AllSeen消息报文
18
头域定义了 AllSeen报文的基本信息，AllSeen头域的定义如表2-4所示。
表2-4 AllSeen头域定义
名称	值	描述
NO_REPLY_EXPECTED	0x01	方法调用无需返回结果
AUTO_START	0x02	自动启用服务
ALLOW_REMOTE_MSG	0x04	允许接收远端消息
(Reserved)	0x08	保留域
SESSIONLESS	0x10	无会话信号信息
GLOBAL_BROADCAST	0x20	全局广播信号
COMPRESSED	0x40	表明AllSeen信息报头被压缩
ENCRYPTED	0x80	表明AllSeen信息正文被加密
2.4.4	AllSeen数据交互
AllSeen服务框架通过接口成员进行数据交换。服务端应用通过总线对象实现服 务的具体逻辑并通过AUSeen总线接口向外暴露提供的服务。客户端与服务端建立会 话后，通过调用相应的代理总线对象访问服务端特定对象路径下的总线对象，并调 用相应的总线方法或总线信号，从而实现设备之间的交互⑷],如图2-12所示。
Unique名字
AllSeen 路由
会话状态 会话I信息 会话n信息
图2-12 AllSeen数据交换图
19
图2-13描述了 AllSeen设备使用总线方法在路由间交换消息的流程。首先，服 务端通过总线对象实现相应的总线接口，并通过广播服务向近邻网络暴露提供的服 务并设置会话监听器等待客户端加入会话。当客户端进入到近邻网络，服务端和客 户端通过广播和发现模块检测到彼此的存在并建立会话。然后，客户端调用本地的 代理总线对象的方法，并将请求数据以METHOD_CALL消息通过合适的路由节点 发送给服务端。服务端接收到消息报文后会进行相应的解析，并根据传送的数据调 用总线对象上相应的总线方法。如果客户端不需要服务端返回结果，客户端可以将 METHOD_CALL消息的NO_REPLY_EXPECTED标识设置为1,否则客户端将通过 METHOD_RETURN消息响应客户端。如果方法调用发生异常,则返回ERROR消息、。
服务端应用
应用	［AS草心库］
连接
服务端AS路由
|消费端AS路由］
消费端应用
［AS/心库］|应用|
连接
注册总线对国 （加里不叫।
|Jo_REPLY_EXP|
CTED）
|绑定会话端口
添加方法调用器
2
会话端口，会话 选项，会话端口 监听器

1 1 1 1 1	选择路由端点f 发送 METHOD CALL I （ 消息	I
调用方法注册 的处理器
发送 METHOD_CALL 消息 序列号扎 NO_REPLY_EXPECT ED标识，对象路径， 接口名，成员，会话I Id.输入参数.
AllSeen服务和发现
AllSeen会话建立
连接
连接
得到代理总20 对象（唯一标 识名，对象路| 径,会话IdJ 总线接口）I
发送
METHOD_ CALL消息
选择路由端点
从代理总线' 对象获取总I 线接口 I 调用总线接I 口的方法
代理对象产 生一个I AJ.METHODJ &LL消息
调用方法
方法没有响
> 方法产生响也 q	产生 METHODRETU RN消亮 发送 METHOD_RET URN消息)	先送METHOD RETURN }	消息「	选择路由端点 发送
选择路由端点
回复序列号扎会话u Id,发送者，输出参, 数…
METHOD_RET URN消息
输出参数
P
图2/3 AllSeen通过总线方法进行数据交换
20
除了使用总线方法外，AUSeen设备还可以通过总线信号进行数据交互。图2-14 描述了 AllSeen设备通过总线信号传送数据的具体流程。首先,服务端通过总线对象 实现具体的服务并通过总线接口将服务广播到近邻网络中，然后，设置会话监听器 等待客户端加入。客户端注测相应的信号监听器，当客户端进入到近邻网络通过广 播和发现模块检测到服务端，首先，客户端与服务端建立会话，并设置路由接收信 号。当服务端向外发送SIGNAL信号时，需要传送的消息通过总线发送到客户端。
服务端应用		消费端应用
|应用|	| AS核心库|	|服务端AS路由|	|消费端AS路由|	| AS核心库|	|应用|
1	1	1	1	1	1
। _连接J 一连接 「	। 一 连接「一连接」
注册总线	「	1	r	n
1	较 ■	।	। C添加方法1	1		1	1 ।	।
（	*处埋器		। ।
|绑定会话端Q		J	1	। ।
।	［会话端口，会话1	।
・选项，会话端口 ।		1注册信号处।
1理器（接口।
1	।	1	1	।名，信号।
।	I	I	I	nrap	|名，接收对］
। ।	1	匹配	।象.处理方।
1	1	1	L			1法，源）।
1	1	|	| Type="	signal ” ］	I
1	1	।	.接口名	信号.
1	1	名，源对象路径;
!< ।	| AllSeen服务和发现 ］	r A
!<L !	! ai— !	!
1	1 1	1 1	-	1 ,用发送信号］	।	। 1	1 1	1 1	1 I	I	1	1 1	1 1	1 1	1 1	1
V 1 1调用总线对象.	1	1	1	1
1信号，产生।	1	1	1	1
| SIGNAL消息 |	1	1	1	1
1	1			1	1	1
|	］发送SIGNAL消息］	|		1	1
1	1诜择路由端点O	1		1	1
了发送SIGNAL消息:
1	1 |	|	|接口名，信号名，会|	1	1 1	1
1	1	। 话Id,信号参数…	1	1
1	1	c?根据匹配规则过!
1	1	滤信号1
1	1	।发送SIGNAL消息।
1	1	1	1			4	1
1	1	1	1	1调用注册的'1
1	1	1	1	1信号处理器1
图2-14 AllSeen通过总线信号进行数据交换
21
此外，AUSeen服务框架也可以通过总线属性进行数据交换，由于总线属性的获 取和修改是通过总线属性的setter和getter方法,因而数据交互流程与总线方法一致， 在此不再赘述。
2.5	AHSeen基本机制
2.5.1	AHSeen广播发现机制
AHSeen的广播机制主要负责将服务端提供的服务广播到近邻网络中，发现机制 则负责从近邻网络寻求客户端感兴趣的服务PL通过AllSeen的广播和发现机制可以 帮助物理相隔离的设备彼此发现各自的应用和服务。目前AUSeen的广播和发现机制 支持通过WKN或unique名称和通过AHSeen的About接口两种方式。
1	.基于名字服务的广播和发现
由于AHSeen路由本身支持名字服务，因而,AHSeen服务框架可以通过WKN或unique 名称进行广播和发现。路由的名字服务采用UDP/IP协议，包括“IS-Ar用“WHO-HAS” 两种消息类型。AllSeen路由通过使用IP组播技术在近邻网络中广播这两种消息类型 从而实现AUSeen的广播和发现机制，其中IPv4的组播地址为224.0.0.113, IPv6的 组播地址为FF0X::13A,端口号为9956。图2-15描述了这两种消息类型的基本报文 格式。SVer表示消息发送方使用的AHSeen发现协议版本号，MVer表示消息发送方 的名字服务版本号，QCount表示寻求的服务数量，Acount表示提供的服务数量， Timer表示IS-AT回答的有效时间期（以秒为单位）。Timer的取值由WKN广播设定 的周期时间 Adv_Validity_Period 和消息有效期 Adv_Infinite_Validity_Value 共同决定。 如果Timer值被设为0,则代表消息发送端的路由将回撤广播消息。
字节	0	12	3
比特	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
Sver	MVer	QCount	ACount	Timer
WHO-HAS消息中的Qcount数量
IS-AT消息中的Acount数量
图2-15名字服务消息格式
图2-16描述了 IS-AT消息的具体报文格式，当服务端采用IPV4的TCP协议或 UDP协议时，R4和U4会被分别置为E同理，如果服务端采用IPV6的TCP协议
22
或UDP协议，则R6和U6会被分别置为1。StringData描述了需要被广播的WKN, 一个StringData代表一个WKN。Count负责统计消息中包含的StringData个数。C 代表是否将StringData描述的所有WKN向外广播，G代表路由的GUID长度是否可 变。M代表消息类型，IS-AT消息M值为1。TransportMask代表代表广播协议的掩 码。
字节	0	12	3
比特	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
R U R U C G 4 4 6 6	M	Count	Transport Mask
R4IPv4Address （当 4R4'字段=1 时有效）
R4 Port （当'R4'字段=1时有效）			U4 IPv4Address （当'U4'字段=1 时有效）
U4 IPv4 Address （当'U4'字段=1 时有效）			U4 Port （当，U4'字段=1时有效）
R6 !Pv6Address （当'R6'字段=1 时有效）
R6 Port （当'R6'字段=1时有效）
U6 1Pv6Address （当			'U6'字段=1时有效）
U6 Port （当'U6'字段=1时有效）
路由GUID的StringData （当'G'字段=1时有效）
StringDala记录的数H
图2-16 IS-AT消息报文格式
图2-17描述了 WHO-HAS消息报文格式，其中Reserved为保留字段，M代表 消息类型,WHO-HAS消息类型M为2。StringData描述了客户端路由感兴趣的WKN。 Count代表WHO-HAS消息中包含的StringData项的个数。
字节	0	12	3
比特	0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
Reserved	M	Count
寻求的服务WKN数目
图2-17 WHO-HAS消息报文格式
在发现和广播过程中，服务端的路由会根据服务端的信息生成相应的IS-AT消 息，并将服务端的WKN名称填充在IS-AT消息中进行周期性广播，具体来说，IS-AT 消息可以通过配置Adc_Validity_Period参数来指定well-known名称广播的有效期限 和Adv_Msg_Retransmit_Interval来指定广播周期在网络中进行周期性广播。为了减 少客户端寻找服务的时间，当服务端接收到寻找其所支持服务的WHO-HAS消息时， 可以主动发出IS-AT消息进行响应。同理，客户端路由会通过
23
FindAdvertiseName（WKN/WKN前缀）获取客户端感兴趣的服务名称或是名称前缀， 并生成相应的WHO-HAS消息，然后通过AllSeen的IP组播地址将WHO-HAS消息 发送到广播中，并且保持监听，当收到IS-AT消息之后，会对IS-AT消息中的WKN 名称和WHO-HAS消息中广播的WKN名称或是前缀进行匹配，如果匹配成功，则 通过FoundAdvertiseame API向客户端反馈已经找到相关服务,否则将一直保持监听。 为了避免产生冲突而导致多播的包被丢失，WHO-HAS消息则可以通过指定 Disc_Msg_Number_Of_Retries 和 Disc Msg Retry, Interval 这两个参数来决定发送 WHO-HAS消息的次数及间隔时间从而避免产生冲突而导致多播包丢失。具体的广 播和发现流程如图2-18所示。
1应一用	服务端应用 | AS楚心库
|服务端AS路由
消费端应用
| AS核合库|	应■用1
|消费端AS路由
连接	、	次挂	.	一.
1	.」年	)|	|	1 连接 1
| ,唯一标识符，|	■ ,	连接
| <	:		1	1
1	1	|	唯一标识符	4	J
|
r请求名称 （WKN）	1	।	1	1	1
1	1	1
4
、加绑段端口	、.	1 I	1	1 I	I

广播名称	X	1 |	1	1 |	|
(WKN)	）!广播名称（wkn»		苻找广播名称:
1寻找广播名称	! (WKN) 1
1 , (WKN)	r	1
:	"IS-AT （通过IP组播）

1	z-r			> /	1	।
1	/ 1	1	_>|	>1
；।WHO-HAS （通过IP组播）		1	।
；		 1重传间隙：	1 IS-AT （通过IP组播） 1	、	r—	1 |	I	। ।	।
\ 1	\ 找到广播名称
X iIS-AT (通过IP组播)	I	I找到广播名%
1- -»
图2-18基于名字发现的广播和发现流
2	.基于About的广播和发现
图2-19描述了基于About的广播和发现的具体流程，服务端通过About模块从 应用中获取服务信息并通过这些服务信息生成多播信号存储在SLS模块的缓存中。 除了和About模块进行交互，SLS （SessionLess-Signal）信号模块还会和路由中的名 字服务进行通讯从而获取服务的WKN/unique名称并将其添加到SLS信号中以发送
24
到近邻网络中。SLS模块在生成不针对会话的信号时，会将信号的名称指定为符合 org.alljoyn.sLx<GUID>.x<changeJd>.格式的WKN。当客户端接收到这个IS-AT的消 息后，客户端的SLS模块就会以会话的形式连接到服务提供端的SLS模块，获取服 务端提供的额外消息。
服务端应用
|应丁 1 1 AS,心库J
连接
|<-----
］注册总线对象
消费端AS路由
连接
唯一标识符
I服务端AS路由
q生成广播信息 ］发送SLS信号
捆绑段端口
建立AS会话
获取声明信息
传送声明信息
找到广播名称 （SLS WKN前缀）
生成一条带有
SLS WKN的 IS-AT信息
WHO-HAS （SLS WKN前缀）
添加匹配以获得平会话信号
IS-AT （包含 SLS WKN）
在SLS缓存中 存储信号 生成SLS WKN
唯一标识符 >
寻找广播名称 （SLS WKN前缀）
消费端应用
AS核心库
连接


|应用
图2-19基于About的广播和发现的具体流程
使用About进行广播和发现时可以通过设置表2-5所示的参数修改About广播和 发现效果：
表2-5发现配置参数
参数	默认值	描述
Adv_Validity Period	120秒	IS-AT广播的有效期
Adv_Infinite_Validity_Value	255	表明广播永远有效的时间值
Adv_Msg_Retransmit_Interval	40秒	发送IS-AT消息的间隔秒数
Disc_Msg_Number_Of^Retries	2	WHO-HAS消息的重发次数
Disc_Msg_Retry_Interval	5秒	WHO-HAS消息的重发间隔秒数
基于About的广播和发现会在广播消息中提供一系列的信息，这些信息如表2-6
25
所示，既包括应用中总线对象的路径和实现的总线接口，也包括设备和应用的元信 息，比如，设备的制造商等等。为了减少网络的负载和提高网络资源利用率，AllSeen 服务框架只会周期性广播部分消息，对于其它的额外信息则在About接口中提供了 一个总线方法，当服务客户端需要获取这些额外信息时，服务客户端可以和服务端 建立会话从而获取相关信息。
表2-6广播字段
字段名称	是否需要	是否广播	是否局部	签名
应用ID	是	是	否	ay
默认语言	是	是	否	S
设备名称	否	是	是	S
设备ID	是	是	否	S
应用名称	是	是	是	S
制造商	是	是	是	S
型号	是	是	是	S
支持语言	是	否	否	as
描述	是	否	是	s
制造日期	否	否	否	s
软件版本	是	否	否	s
AllSeen 版本	是	否	否	s
硬件版本	否	否	否	s
帮助UH	否	否	否	s
根据上边的介绍，可以发现基于About的广播和发现都是基于多播消息，这对 于网络资源的利用率较低，也容易造成对网络的过高负载。而且IP路由可以阻塞多 播IP地址和端口，因此这种方式的发现能力是有限的。因而，AUSeen服务框架在 14.06版本中提供了一种基于mDNS的发现协议-NGNS (Next Generation Name System),这种协议通过使用AllSeen的多播地址和端口来发送基于多播的DNS来发 现支持某些特定接口的设备和应用，而且该协议的发现响应是单播的，这样可以提 高发现协议的性能和减少AllSeen发现过程所产生的多播数据量。NGNS使用的IPv4 多播地址、IPv6多播地址和端口号分别为224.0.0.251、FF02::FB和5353。
假设客户端的AllSeen路由支持原先的名字服务行为,消息序列如图2-20所示，
26
首先客户端发送FindAdvertisedName （）初始化消息序列；NGNS通过多播DNS发 送基于DNS-SD的查询消息以及名字服务支持的WHO-HAS消息；任何与搜索名字 匹配的服务提供端通过单播方式发送DNS-SD消息响应客户端；14.02版本以前的服 务提供者如果和WHO-HAS消息匹配则通过IS・AT消息响应。
服务端应用	服务端应用	消费端应用
（带有 NS）	（带有 NGNS）	（带 <NGNS）
AllSeen 应用
寻找广播名称（名称前缀）
回复：
寻找广播名称（名称前缀）
NGNS
A” Seen路由
WHO-HAS 版本表明了 mDNS询问 也会被询问 齐］持 门之乂刹 mDNS询问 的应答：之 后的mDNS 询问部分会 同样的爆发 式忽略
名以匹消被 有可确的会送 只称准配息发
-niDNSfli-
WHO-HAS 按 照相同的
NGNS传输表
WHO-HAS信息（版本,支持版本,WKN前缀） <-------------------------
mDNS询问（问题：PTR. addl： "sender-
infb" , "search”文本记录）
nDNS应答(回答：PTR, TXT. SRV； addl： "sender____infb" . "advertise n …“ 文本i己录)	、
IS-AT （名称）
图2-20基于NGNS的服务客户端和基于名字系统的服务提供端之间的消息时序
3	. WKN VS About
以上介绍的两种方式都可以用于广播和发现服务，在此，也给出关于这两种方 法的使用情景建议：一般来说，推荐使用About广播机制来进行广播，因为About 广播机制为应用提供了一种通用的方式来向可能对该应用感兴趣的其他应用来广播, 而且广播数据中包含一些通用的元数据，比如说制造商、支持接口、图标以及其它 等等，这也是在本文中最后选择使用以About方式进行服务广播的原因。从底层原 理，也可以发现，通过WKN或是unique名称进行广播是一种更为基础的方式，事 实上使用About进行广播时采用的就是用WKN/unique名称广播的底层机制。由于 这种方式对于底层的封装性较About要原始，因而对于应用开发人员对AllSeen服务 框架的了解要求相对比较高，所以在不需要涉及到底层技术细节的时候，不建议使
27
用WKN或是unique名称的方式进行服务的广播和发现。
2.5.2	AllSeen会话机制
AllSeen总线附件内可以同时注册多个总线对象提供多项服务，为了能区分同一 个总线附件上的各个服务，AllSeen设定了联系端口号来区分同一个总线附件上的各 个服务。服务通过总线附件将消息转发到路由进行广播操作,在AllSeen服务框架中， 服务通过申请的WKN名称通过总线附件进行广播操作。在传送消息时，这个名称 会被转换为底层网络结构的unique名称。从而确保消息被传送到正确的总线附件。
同理，AllSeen在连接服务时需要提供一个完整的信息传输规范来详细指定连接 网络的详细参数。AllSeen中服务地址的半连接表达形式如下：｛session options （会 话选项），bus name （总线名称），session port （会话端口）｝。其中会话参数选项决 定了数据以何种方式传输。在IP网络中，这个参数的选项可能是“基于消息的”、“非 结构化数据”或“不可靠的非结构化数据”的。总线附件所申请的well-known名称 用于定位服务。AllSeen中也有总线附件内部传输点的概念，在AllSeen中，这被称 为会话端口，会话端口只在给定的总线附件内起作用，与推断底层接口和对象的方 法一致，连接端口的值可以从总线名称中推断出来。
为了与服务进行通信，客户端也必须实现半连接，客户端的地址也是采用相似 的方法实现的。｛session options （会话选项），unique name （唯一名称），session ID （会话ID） ｝o会话并不要求客户端也向总线请求一个well-known名称，直接提供 总线分配给总线附件的唯一名称即可。由于客户端也不会充当会话的终点，所以， 它们也不提供会话端口，在建立连接时会给客户端分配一个会话ID。在会话的建立 过程中，这个会话ID会返回给服务端。AllSeen会话的建立过程就相当于TCP的连 接创建过程，服务端通过预设端口进行连接，在连接建立后，客户端则会使用一个 临时的端口进行通信。值得注意的是，在服务端和客户端总共有两个会话选项，因 而，在会话建立初始的时候，它们会被分别视做服务端可以支持的会话选项和客户 端可以提供的会话选项，会话创建过程便包括协商会话中实际使用某一会话选项的 这部分。一旦会话形成，客户端和服务端的半连接就会被联合描述成唯一的AllSeen 通信路径：｛session options （会话选项），bus name （总线名称）,unique name （唯一 名称），sessionID （会话ID） ｝。在会话建立过程中，在客户端和服务端进行相互通 信的后台程序也会形成一条逻辑总线。
28
AllSeen会话分为单点会话和多点会话两种类型必，2久其中单点会话为点对点的 连接，多点会话则支持多个设备或是应用在同一会话中进行通讯。会话都是通过一 个特定的端口来创建的。不同的端口允许单点或多点通讯的拓扑结构。如图2-21所 示，左边A和B都通过端口 1和S直接进行端到端的通讯，也就是说，形成了两个
2.6	AllSeen基础服务框架
2.6.1	Onboarding组网服务框架
由于受限于成本和外形，在智能家居系统中存在多种多样的哑设备，比如运动 传感器、门磁传感器、温度传感器、湿度传感器以及烟雾传感器。这些价格低廉的 设备往往都有有限的内存和CPU,而缺少相应的图形用户界面和输入设备，这限制 了这些设备的联网能力和在智能家居领域的参与度。但这些基础设备在智能家居领 域却起着非常重要的作用。正是考虑到这一点，AllSeen提供了 Onboarding基础服务 框架来提供一个一致的网络接入方案【25］，开发者只需要在开发的应用时支持 Onboarding提供的服务框架，就可以实现哑设备的自由组网。
在Onboarding的服务框架中，设备可以分为onboarder设备和onboardee设备， 其中onboarder设备是硬件基础比较好的设备，拥有相对充足的内存、CPU和用户图 形界面以及输入设备，比如手机、PC机等等。onboardee设备相对来说，是硬件条 件相对受限的设备，这部分设备往往具有相对简单的功能和单一的服务，数据要求 也相对较少，因而本身不需要有用户图形界面和输入设备，如上文提到的各种传感 器。onboardee设备依靠onboarder设备选择目标网络以及通过和onboarder设备建立 会话来接收目标网络的连接凭证和密码，最终登陆到目标网络。
29
2.6.2	Notification通知服务框架
AllSeenNotification服务框架主要提供了设备之间的一种通讯方式冈，这种设计 层面主要是从软件方面出发的。该服务框架采用AllSeen的不针对会话的信号组成。 使得设备之间在建立会话之前便可以相互通讯，该服务框架主要用于发送事件通知 或者状态更新给连接到同一网络中的设备。在该服务框架中，设备分为两大类，一 类是设备通知产生方，一类是设备通知消耗方，这两者并不相互冲突。某一单独的 设备可以是独立的通知产生方，也可以是独立的通知消耗方，也可以同时承担这两 个角色。设备通知方产生和发送通知，设备通知消耗方负责接收和显示通知。当设 备通知方调用Notification基础服务框架发送通知时，Notification服务框架会通过 AllSeen不针对会话的信号形式将通知广播打到网络中，网络中注册了通知订阅的设 备会接收到相应的信号，然后对自己感兴趣的信号传递给应用。
2.6.3	Config配置服务框架
配置服务框架主要用于执行特定设备的配置和操作PL比如，重启和恢复出厂 设置等具体设备方法，设备密码，友好名称和默认语言等特定设备可设置的属性。 设备的OEM会采用配置服务框架，并把它与单一的应用程序(系统软件)捆绑。
2.6.4	Control Panel控制服务框架
AllSeen控制面板(Control Panel)服务框架是AllSeen的四大基础服务框架之一 磔】，控制面板框架允许近邻网络中设备上的应用通过控件集合向临近的其他设备广 播它的虚拟控制面板，该设备称之为受控方，近邻网络中支持Control Panel的设备 可以根据控件集合在自己的屏幕上渲染出受控方广播的虚拟面板，该设备称之为控 制方，从而用户可以通过控制方来实现对受控方的交互。
2.7	本章小结
本章主要介绍了本文的技术基础-AllSeen服务框架。首先，从AllSeen技术的概 述入手详细介绍了 AllSeen的历史来源；其次，从网络拓扑结构、协议栈和系统框架
30
三个方面阐述了 AUSeen的整体框架；再次，深入了解了 AUSeen服务框架的基本概 念、数据、广播发现和会话机制，阐述了 AllSeen技术的底层通信原理；最后，深入 探讨了 AllSeen基础服务框架的具体实现细节。
31
32
第三章 基于AllSeen的智能家居系统设计
本章根据第二章所介绍的AllSeen技术基础系统地设计了一套完整的智能家居 系统方案。首先本章根据本文的研究内容明确了系统的整体目标和功能，并对相关 功能点进行了详细设计和拆分；其次根据这些功能点设计了系统的整体架构，并针 对系统内各类型设备承担功能对设备应用层进行了深入的特征分析梳理出各类型设 备需要实现的功能模块。为了进一步了解整个方案，本章还从系统用户的角度出发， 设计了控制设备与系统内设备的交互流程。最后本章针对系统内的核心功能模块给 出了详细的设计方案，这些核心功能模块包括设备转换、发现、组网、通讯、控制、 图标获取、心跳机制、异步事件-动作触发和分布式多点会话。
3.1	基于AHSeen的智能家居系统的设计目标
一套完整的智能家居系统应该具有高效的设备发现机制、灵敏的设备心跳机制、 有效的设备管理机制、便捷的设备通讯机制和可靠的安全机制。本系统也针对这五 点进行了如下的功能设计： 1、高效的设备发现机制
巧妇难为无米之炊，同样，智能家居系统也离不开对基本智能设备的操作。设 备操作的前提在于系统拥有一套高效的设备发现机制，能迅速发现网络中的可操作 设备。根据本文的研究目标和内容,本文搭建的智能家居系统需要能迅速发现AllSeen 标准设备、AllSeen瘦客户端设备、ZigBee设备和云端设备，因而系统也针对这四种 类型的设备分别设计了对应的发现机制。
系统通过实现About机制来进行标准设备服务的广播和发现，控制设备通过注 册相应的监听器监听总线上的About信息并根据监听到的信息发现标准设备；对于 AllSeen瘦客户端设备，则通过借助AllSeen的Onboarding服务框架，使用控制设备 的Wi-Fi扫描模块实时检测周围的AP信息从而发现目标设备；本系统对于ZigBee 设备的发现需要转换为对ZigBee设备在网关虚拟的AllSeen设备的发现，采用转换 模式可以避免系统再重新开发一套完整的基于ZigBee协议的设备发现和管理机制， 并为进一步拓展蓝牙协议、Zwave协议提供参考。云端设备的发现需要控制应用连 接到相应的云端账户并通过网络数据获取云端的存储数据，然后再根据预定义的数 据格式来解析这些数据为云端设备。
2、灵敏的设备心跳机制
33
一套好的智能家居系统应该具有灵敏的心跳机制，从而能实时监测和更新设备 的在线、离线状态并以此保证操作的可靠性。由于对ZigBee设备的发现最终需要转 换为对虚拟AllSeen设备的发现，因而本文搭建的智能家居系统主要考虑了 AllSeen 已入网设备、AllSeen未入网设备和云端设备的心跳机制。具体来说，本系统主要使 用了 AllSeen的NGNS服务设计了相应的心跳机制算法来监测已发现设备的实时状 态；对于未入网的AllSeen设备则通过AllSeen的Onboarding框架加以实现；云端设 备的心跳机制需要本地设备的配合，系统每次检测到设备的更新状态之后都将通过 总线方法将设备的新状态发送到网关，再通过网关实时更新云端的存储数据从而来 保证云端设备的心跳机制。
3、有效的设备管理机制
智能家居系统的最终目的是实现用户对于设备的智能控制，设备的发现和心跳 机制都是作为底层技术来确保受控对象的可靠性。本文搭建的智能家居系统会系统 内的设备控制提供了丰富多彩的方式，主要有Control Panel、Bus Object、Config以 及Event-Action四种方式。其中Bus Object为最底层的方式，控制设备通过服务的广 播信息和Java的动态编译实现对设备的单点控制；Control Panel和Config是AllSeen 服务框架提供的基础服务模块，通过实现这两个基础服务模块，系统可以实现对设 备的图形化控制和基本信用控制；Event-Action机制作为用户友好型的控制方式，为 用户提供了设备的联动控制，进一步提升了用户体验。
4、便捷的设备通讯机制
智能家居系统与传统家居系统的最大区别在于智能家居系统打破了系统内设备 间通讯的障碍，让设备对话成为可能。本智能家居系统也为系统内设备提供了丰富 的通讯方式，具体包括单点会话、多点会话和AllSeen的Notification基础服务框架 三种方式。其中单点会话主要发生在设备控制时，控制设备主要通过AllSeen的会话 机制与被控设备建立会话渠道传送控制命令和交换信息；多点会话则主要发生在网 关的设备组管理中，网关主要通过多点会话来获取当前网络的设备信息。
5、可靠的系统安全机制
智能家居系统作为一套完整的智能服务方案，在给用户带来新体验的同时也需 要保障通讯的安全。AllSeen的服务框架在设计之初便考虑到了安全性，因而对其通 讯内容进行了加密处理。此外，为了进一步加强系统的安全性，本文在存储设备相 关信息时也采用了 MD5的加密方式。
34
3.2	基于AllSeen的智能家居系统架构设计
明确了智能家居系统的整体设计目标，就可以根据相应的功能设计系统架构。 整体来说，系统架构的设计离不开通讯协议和通讯设备的选择。其中通讯协议不仅 决定了通讯设备的基本类型，也决定了通讯设备的连接方式。本文考虑到当前智能 家居系统中协议的多样性和普适性以及课题时间的局限性，最终决定选择在系统中 暂时先实现Wi-Fi和ZigBee两种通信协议，并预留出蓝牙协议的接口。具体系统架 构如示意图3-1所示：
图3-1智能家居系统架构
智能家居系统通过Wi-Fi、ZigBee和蓝牙协议将系统内的设备紧紧联系在一起。 其中系统内设备根据所处的环境可以分为本地设备和云端设备两大类，其中云端设 备通过云连接到系统内的网关上，本地设备则直接和网关交互。由于云端设备是本 地设备在云端的注册，因而云端设备只是与本地设备对应的一个概念镜像，因而云 端设备在物理结构上并没有额外对应的设备，对云端设备的操作最终都将转换到其 注册时对应的本地设备。所以不需要考虑云端设备的选型。
本地设备由真实物理设备充当并且和网关直接交互。根据使用通信协议的差异, 该智能家居系统中的本地设备又可以分为:AllSeen设备、ZigBee设备、蓝牙设备、
35
控制设备和网关。
AllSeen设备为实现了 AllSeen服务框架的智能设备，根据设备内是否包含 AllSeen路由又分为AllSeen标准设备和AllSeen瘦客户端设备。由于本文是搭建基 于AllSeen服务框架的智能家居系统，AllSeen设备是该系统的最基本的控制对象， 也是该系统拓展ZigBee协议和蓝牙协议的基础。篇幅限制，下图3-2给出了在搭建 具体的智能系统时选择的部分AllSeen设备，还有部分设备由Arduino开发板组成网。
图 3-2 控制设备 a) FreeWings 音响 b)Hitache 音响 c)Freewings 音箱
ZigBee设备因为其价格低廉、功耗低而且在短距离通信中性能优异，在智能家 居领域也占据着越来越重要的角色。这也是本文选择ZigBee协议作为本智能家居系 统的底层通信协议之一的原因。图3-3-a给出了本智能家居系统中的部分ZigBee设 备，包括门磁传感器、温湿度传感器和智能灯。
图3-3控制设备a) ZigBee设备b)控制设备c)网关
蓝牙设备目前在智能家居领域也起着不容小觑的作用，由于受限于课题研究时 间，本文将只对蓝牙协议这一部分进行可行性理论方案设计，而不将其纳入实际搭 建的智能家居系统。
控制设备是整个智能家居系统的入口，系统通过借助控制设备的图形界面向用 户展示设备状态和信息和获取用户的操作指令。考虑到安卓手机在市场的占有率， 本文最终选择了它作为控制设备。由于智能控制设备涉及到整个智能家居系统的大 部分功能，因而是本文开发量最大的设备，通过分析控制设备上应用的系统框架可 以帮助梳理整个智能家居系统。从图3-1的系统架构图可以看出控制设备既可以控制
36
本地设备也可以控制云端设备，而与其所处环境和位置无关。
网关是整个智能家居系统的核心画】,如图3-3-C所示。它既充当了局域网的AP, 负责提供本地设备的底层通信渠道，也和云端相连负责云端和本地的数据交互。此 外，本智能家居系统的网关为定制版，除了实现以上基本的数据交互功能外，还需 要开发额外的应用功能，包括设备管理模块、ZigBee设备转换模块和蓝牙设备转换 模块。
从图3-1可以看出本智能家居系统对设备的最终控制都需要转换为对AllSeen设 备的控制，系统中的非AllSeen设备：ZigBee设备和蓝牙哑设备都需要通过网关的 转换模块转换为虚拟AllSeen设备（包括虚拟标准AllSeen设备和虚拟AllSeen瘦客 户端设备）。智能家居系统中的所有设备都需要转换为AllSeen设备才能注册到云端 成为云端设备，以保证控制设备处于远程控制模式时，操作的对象也依然是AllSeen 设备，从而保证设备控制的一致性。
由于本文课题只是利用云端存储注册设备的数据，并不涉及其它复杂的功能， 所以云类型的选取对于本智能系统并不会造成太大的影响。
3.3	设备应用层框架分析
根据第二章2.2.2介绍的AllSeen协议栈可知基于AllSeen服务框架开发的智能 家居系统的开发主要集中在应用层，为了能更好地整体把握系统的整体功能和通信 流程，本节描述了系统内各类型设备的详细应用层框架。由于系统中的ZigBee设备 和蓝牙设备最终都要通过网关的转换模块转换为本地网络的虚拟AllSeen设备，本身 并不实现AllSeen的服务框架，因而这里就只介绍标准AllSeen设备、AllSeen瘦客 户端设备、控制设备和网关的应用层框架。
标准设备拥有自己的路由和图形用户界面，因而可以实现自由动态组网，所以 不需强制实现Onboarding服务框架，除非该标准设备希望充当Onboarder角色。标 准设备需要向外提供服务和功能，所以需要实现About和相应的设备控制机制。通 知模块也是加强功能，各设备根据自己开发功能的需求选择是否实现该框架。总体 来说，AllSeen标准设备的系统架构具体如图3-4所示。
37
Al 1 seen标准设备应用层架构详解
图3-4 AUSeen标准设备应用层架构
AllSeen瘦客户端设备没有自己的路由和图形用户界面，因而无法实现自由动态 组网，所以需要借助Onboarding服务框架联网。瘦客户端设备需要向外提供基础的 服务和功能，所以需要实现About和相应的设备控制机制。考虑到本智能家居系统 希望加强对设备状态的管理，所以AUSeen瘦客户端将实现通知服务框架。本系统中 的AllSeen瘦客户端设备的系统架构如图3-5所示：
Allseen瘦客户端设备应用层架构详解
瘦客户端设 备应用通知
通知发送
Notification
设备服务与功能
设备信息	设备控制
标准设备广播 About	Control Panel	Config	Event Action	Bus Object
设备组网
Onboarding
图3-5 AllSeen瘦客户端设备应用层架构
控制设备需要与系统内的所有设备进行交换，因而需要实现所有的功能，包括 实现Onboarding基础服务框架支持瘦客户端设备的组网，实现Notification基础服务 框架通知发送模块。以及实现设备的发现、控制和管理。控制设备的具体系统架构 如图3-6所示：
38
控制设备应用层架构详解
通知获 取模块
设备控制
设备管理
设备控制
设备信息	心跳机制
设备控制
通知接收
Notification
标准设备发现	瘦设备发现
About	Onboarding
设备组网
Onboarding
图3-6 AllSeen控制设备应用层架构
网关作为系统的核心，需要实现Notification基础服务框架来接收通知，和云端 交互，以及实现ZigBee设备的转换模块，和一些设备管理机制。网关的具体系统架 构如图3-7所示：
网关应用层架构详解
服务与功能
设备心跳机制
通知处理模块
设备信息
设备控制
通知发送接收
Notification
瘦客户设备广播
About
Bus Object Conf ig Event: Act ion
Zigbee
白W
E
图3-7 AllSeen网关应用层架构
3.4	控制应用交互流程
如图3-8所示，控制应用以设备发现和心跳模块为核心与各个功能模块进行交互。 总得来说，整个应用可以分为应用引导、设备发现、设备组网、家庭网络设置、设 备通讯、设备管理和应用设置七大模块。其中应用引导模块则主要负责向用户介绍 控制应用的使用方式；设备发现模块主要负责近邻网络设备的发现，包括标准设备、 瘦客户端设备和虚拟的AllSeen设备；设备组网模块主要负责给AllSeen的瘦客户端 配置入网信息；由于家庭网络中设备数量远多于热点数量，因而在控制设备中开发 了家庭网络设置模块，用户可以选定特定AP作为家庭热点。设备通讯模块主要负 责从网关获取近邻网络中的设备通知，和与控制设备建立单点会话交换信息；设备 管理模块主要负责控制设备调用其服务或者修改设备的信息；应用设置主要用来选
39
择控制效果，比如选择性接收某些设备的通知，以及接收通知时的铃声和震动等等,。
图3-8控制软件架构图
3.5	本地模式与云端模式
本智能家居系统采用外界可达AllSeen网络拓扑结构，同时实现云端模式和本地 模式。由于云端模式和本地模式实现的技术手段不同，本地模式使用AHSeen技术实 现对设备的管理、组网、通讯和控制，云端模式通过网络数据在云端和网关进行通 讯交流，且这两个模式下设备的交互流程也相互独立，因而具有独立性。
考虑到人类复杂的社会活动，这两个模式虽然具有独立性，但并不具备互斥性。 举个最简单的例子，用户生活的家庭和工作的地方有可能是两个物理相隔离的智能 家居系统。但存在用户需要同时控制着两个系统的情况，在这种情况下，本地模式
40
和云端模式又是同时存在的。
考虑到本地模式的独立性和非互斥性，如果简单地将本地模式和云端模式独立 设计为用户可以选择的模式，那也在一定程度上削减了系统的智能性。此外，由于 云端设备是本地设备注册的虚拟设备，所以同一设备可能同时存在本地在线和云端 在线两种状态，在这种情况下，设备选择何种方式通讯也值得深入思考。
考虑到本地AllSeen设备通讯发生在同一局域网内，通讯成本较云端外网更低, 速度更快，因而本文优先选择本地模式。具体实现方法如下，控制设备默认开启本 地模式自动检测用户所处环境的设备，这些设备即为本地设备。采用显性入口由用 户决定是否开启云端模式。如果采用云端自动开启模式，控制应用程序需要提供一 个后台进程或线程来保持和云端的互联互通并周期性获取设备信息，这样的无限循 环在无须开启云端模式和云端模式异常时对于资源的浪费极其严重的。考虑到控制 设备资源有限，本文最终选择优先本地模式。此外，如果对于同一个设备，本地模 式和云端模式该设备都处于在线状态，控制设备将按照本地模式的通讯方式进行处 理。
3.6	核心模块
这部分主要介绍了搭建智能家居系统时耗费时间和精力比较多的核心模块，包 括AllSeen设备的发现、AllSeen瘦客户端设备的组网、蓝牙哑设备的组网方案。
3.6.1	设备转换模块
由于当前的AllSeen服务框架并不支持ZigBee协议，为了让设计的智能家居系 统兼容ZigBee设备和为后续进一步拓展蓝牙、Zwave等协议，本智能家居系统特意 在网关部分设计和开发了转换模块卬］，该转换模块主要用于设备的桥接，用于将非 AllSeen设备映射为虚拟AllSeen设备从而将其接入到AllSeen网络，从而使得位于 AllSeen网络的设备可以通过这些虚拟的AllSeen设备来控制这些非AllSeen设备。 有关ZigBee设备转换的最终场景效果图如图3-9所示：
41
Al ISeen设备网络
网关转换模块
非Al ISeen设备网络
设备1
ZigBee设备转换模块
设备n
控制
设备2
转换
控制
虚拟设 备(对 应 ZigBee 设备1)
手册
Zwave设备转换模块控制
蓝牙设备转换模块 ”二 控制：
设备1
设备n
设备2
设备1
设备2
设备n
图3-9非AllSeen设备转换图
3.6.2	AllSeen标准设备发现
由于标准设备对于特定AP的状态只有入网和离网两种状态，而只有在AllSeen 标准设备入网的情况下控制设备才能发现标准设备。因而对于标准设备的发现，暗 含标准设备和控制设备连接在同一网络。在此种情况下，由于标准设备有自己的路 由，在标准设备连接到个人AP之后，会通过About广播设备相应的信息，具体广播 信息格见表2-5,控制设备在加入到标准设备所在的AP之后，会根据控制设备的路 由匹配规则，接收总线上符合规则的消息从而找到提供感兴趣的服务的设备。本系 统中控制设备路由通过调用wholmplements ()接口将路由消息的匹配规则设置为: “org.*"，这代表控制设备可以接收包含org.前缀开头服务的设备消息。在接收到相 应的广播信息后，控制设备会根据这些信息抽象为具体的设备。本智能家居系统根 据广播端口号，总线名称和应用ID确定标准设备的唯一标识性。
42
3.6.3	AUSeen瘦客户端设备发现
瘦客户端设备对于特定AP只有配置入网、配置离网、未配置三种状态，控制设 备无法发现处于离网状态的设备，只能发现配置入网和未配置这状态。
已经配置入网的瘦客户端设备会借助网络中的可借助的路由进行About消息广 播，从而标准设备可以通过广播的About消息得知瘦客户端设备的存在，对于这种 情况，其发现流程和机制都和3.6.1所介绍的标准设备发现一样。唯一需要补充的是 瘦客户端设备没有自己的路由，需要借助其它标准设备的路由进行About消息的广 播。为了保证瘦客户端设备在网络中能找到至少一个可用的广播路由，控制设备将 其路由命名为quiet@org.alljoyn.BusNode.d+ “设备的GUID”方式，在保证控制设备 路由名称的唯一性时主动将其路由暴露给瘦客户端设备。
对于未配置瘦客户端设备的发现，控制设备首先利用Onboarding服务框架暴露 的 API getWifiScanResults(WifiFilter.ONBOARDABLE)来获取周围的瘦客户端设备。 具体的发现原理为Onboarding服务框架在调用该API时，会控制控制设备的Wi-Fi 模块扫描附近的所有AP。由于瘦客户端在未配置入网前，瘦客户端的SSID必须符 合以“AJ_”开头或是“_AJ”结尾的命名规则。所以标准设备可以根据检测到的SSID 的名称来筛选出未入网的瘦客户端设备。本系统框架将筛选出的软AP看作是未入网 的瘦客户端设备，并通过AP信息来唯一标识瘦客户端设备。
3.6.4	AllSeen瘦客户端设备组网流程
图3-10描述了 AllSeen瘦客户端设备组网的基本流程。首先，未入网的瘦客户 端会以AP模式启动并通过Wi-Fi广播其SSID, AllSeen约定尚未入网的设备SSID 以AJ_开头或是_AJ结尾。Onboarder控制应用会通过Wi-Fi扫描机制监听周围的AP, 并将符合未入网SSID命名规则的AP筛选过滤出来展示给用户进行选择。用户在选 择相应的未入网设备后，需要输入该设备的安全验证密码，然后继续选择需要配置 的目标网络，通过Onboarder安卓应用输入目标网络的SSID类型以及密码，安卓应 用会根据用户输入的未入网设备的安全信息连接到该设备，建立连接后，未入网设 备会通过Onboarder的路由广播其about消息，如果广播的about消息显示该设备支 持Onboarding接口，Onboarder应用会和未入网设备建立会话，并将用户输入的目标 网络信息发送给未入网设备以帮助它加入目标网络。当瘦客户端设备Onboardee加
43
入到目标网络后会广播其about消息，此时连接到目标网络的Onboarder设备会检测 到相应的about信息，从而标志设备入网完成。为了更好地识别入网设备，在接收到 about消息后，Onboarder应用会提醒用户修改设备的名称，并通过Config基础服务 框架修改设备的名称。
Onboardee 设备
以软AP模式启动
--------►
通过Wi-Fi广播SS1D
终端用户
.	连接到软AP
连接至9 AJ核心daemon
广播信号
I提醒终端用户选择软AP的SSID和输入软AP密码
___出P邀选弹_ _
个人AP被选择
广播信号
如果支持onboard i ng接 口，建立会话
提醒用户在WiFi扫描列表中选择个人AP SSID,类型和输入个人AP密码
激活 Onboarding. ConfigureWiFi (PersonalAPinfo) 发送目标网络信息
激活 Onboarding. Connect ()
〃如果设备支持快速通道劣持, ConnectionResul t.信号
广播信号
二）加入个人AP
。加入个人AP
广播信号
登陆完成
提醒终端用户修改设备名称
通过Config框架修改名称
输入修改名称
图3・10 AllSeen瘦客户端设备组网的基本流程
44
卜

3.6.5	蓝牙HE设备组网方案设计
目前AllSeen的服务框架并不支持蓝牙哑设备的自由组网，考虑到蓝牙协议在智 能家居领域占据的地位越来越重要，本文结合蓝牙协议和AllSeen服务框架地特点, 提出了一种和现有AllSeen Wi-Fi协议组网相一致的蓝牙哑设备动态组网方案。
图3-11描述了蓝牙设备组网方案的物理结构，为了能让两个蓝牙哑设备动态组 网，该组网方案在组网过程中引入了一个带有图形界面的标准设备在组网的哑设备 间传递消息，此外，该方案的网关实现了蓝牙协议，并在完成组网时，充当蓝牙哑 设备网络的主机和管理设备。为了实现这一方案，标准智能设备需要实现蓝牙主机 的功能，哑设备需要实现蓝牙从机的功能，而网关作为最终的主机和管理设备则需 要同时实现蓝牙主机和从机两部分的功能。此外，为了方便标准智能设备区分周围 需要配置的蓝牙哑设备和可以充当目标主机的网关，本方案规定需要配置的蓝牙哑 设备名称以AJ_开头或是_AJ结尾，可以充当主机的网关设备则以AM_开头或是_AM 结尾。
图3-11蓝牙哑设备组网物理结构图
图3-12描述了蓝牙哑设备的详细组网流程。首先用户会通过标准设备的控制应 用去搜索周围的蓝牙哑设备，由于周围的蓝牙哑设备会进行周期性地广播，所以标 准设备会维护一张周围的蓝牙设备列表，并根据需要配置的哑设备和管理设备的命 名规则过滤出周围需配置的蓝牙哑设备和管理设备，并将这些信息通过标准设备展 示给用户。然后用户通过标准设备选择需要配置的哑设备和目标管理设备，标准设 备将先和需要配置的哑设备建立会话，并将该设备的广播信息和安全验证信息存储 在标准设备中。然后断开连接，连接到目标管理设备，并将存储的需要配置的哑设 备信息发送给目标管理设备，包括其广播信息和安全验证消息，然后管理设备就可 以通过这些信息开启主机模式连接到需要配置的设备，从而完成组网过程。
45
用户
智能设备 （带输入功能）
请求搜索周围的配置设备
搜索周围需要配置的哑设备
返回维护的周围哑设备列表 k-------------
：用户选择配置设备
搜索设备成功
与用户选择的配置设备建立单点会话
请求搜索周围的管理设备
会话建立成功
；将用户选定的设备的详细信息和配 ;对密码存储在智能设备中，并标记 为配置设备信息
搜索周围的管理设备
性
返回维护的周围管理设备列表:
<---------------卜
用户选择管理设备
与用户选择的管理设备建立单点会话
将所储存的配置设备信息传递给管理设
-备，包括配对密码-
管理设备
搜索设备成功
会话建立成功
<


与配置设备信息建立连接:
-----------工
会话建立成功
图3・12蓝牙哑设备组网流程图
图3-13描述了最终的组网效果图，在此需要强调的是，该组网方案不仅可以将 蓝牙哑设备连接到网关形成蓝牙微微网，也可以将网关连接到网关形成散射网，因 而其具有很强的可扩展性。
图3・13蓝牙哑设备组网效果图
46
组网完成后，控制设备就可以通过管理设备来控制和管理其它的蓝牙哑设备。
标准设备充当蓝牙主机且连接到管理设备，管理设备在接到命令之后，将通过转换 层，将命令以主机的形式发送给受控设备，然后受控设备完成相应的操作，具体示 意图如图3-14所示。
图3-14蓝牙哑设备控制流程图
3.6.6	AllSeen设备通知获取流程
根据2.6.2所介绍的AllSeen通知服务框架，可以得知AllSeen设备可以通过不 针对会话的消息进行消息传递。然而AllSeen的通知服务框架并不完全适用于本文搭 建的智能家居系统，因而需要对其改善。在介绍具体的方案之前，首先了解一下现 有的通知服务框架所存在的弊端。弊端主要体现在两个方面：
1.	AllSeen原有的通知服务框架根据消息的紧急程度将通知分为普通、一般警告和 严重异常三类，并且规定对于每一个设备的不同紧急程度的通知在通知发送端只 能保存一条，当控制设备在消息覆盖时间不在网络中时很容易造成消息的丢失。
图3-15通知获取与TTL的关系
47
2.	AllSeen现有的通知服务框架为每条消息设置了存活时间TTL,并规定通知接收 方只有在消息存活期内才能从发送端获取通知，一旦通知的存活期失效，那么通 知接收方就无法再获取相应的通知，具体示意图如图3-15所示。
由于这两点机制，如果控制端设备不能保证时时处于网络中，将导致控制设备 丢失网络中的许多通知。这对于网络中的严重异常信息和一般警告信息是不可以接 受的。如果将AllSeen的通知接收模块放置在控制设备，为了解决这一问题，通知发 送端就必须延长严重异常和一般警告通知的存活时间。由于AllSeen的底层通知机 制在发送通知时采用UDP组播，延长TTL会造成重复包发送，浪费资源也增加网络 的负载。
基于以上的考虑，本智能家居系统最终决定将AllSeen的通知接收模块放置在网 关，利用网关来接受网络中发送的通知，并且将接收到的通知按照紧急程度分别存 储，对于严重异常信息和一般警告信息，路由器会全部存储，直到用户发送相应的 删除指令。对于设备的普通通知存储，网关开发了相应的总线方法允许用户根据个 性化需求设定存储条数。此外，网关还暴露了通知查询、删除的接口。标准设备可 以根据相应的总线方法查询某一特定设备的通知或是网络中的所有通知，也可以单 独或是批量删除设备通知。
当智能家居系统的设备发送通知时，服务端设备上的AllSeen框架发出一个无会 话信号广播的通知消息。该信号这会被网关的AllSeen通知框架所接收。然后网关通 过和服务端设备建立单点会话从服务端获取通知消息并将其传递给网关消息管理模 块。本智能家居系统不仅仅支持文本通知的发送和接收、也支持多媒体通知和动作 通知，其中文本通知指的是只携带文字内容的通知，多媒体通知指的是通知内容中 携带图标或是音频，动作通知中则携带包含动作信息的对象路径，用户可以通过该 通知调用相应设备的功能。下图3-16描述了网关接收通知的具体流程：
图3-16网关接收通知流程
48
除了解决现有通知机制存在的问题，本文还利用AUSeen的通知服务框架开发了 如下三个进阶功能，一是实现通知的本地系统化；二是实现通知的回撤；三是支持 带动作的通知。
通知的本地系统化主要是在控制设备也实现通知机制，这样在控制设备接收到 的通知的时候，就可以利用安卓开发的API将接收到的通知内容以系统通知发送出 来以保证接收消息的实时性，而控制设备在进入通知页面获取系统的设备通知时， 则通过总线方法从网关获取。
由于底层通知的发送采用UDP机制，会造成底层网络资源的浪费，因而在本系 统中控制设备针对接收的通知实现了撤回功能，如图3-17所示。当用户在某一控制 端设备上阅读某一通知并确定撤回通知时，控制端设备会尝试根据通知中包含的发 送端信息与相应的通知发送端建立会话连接，如果会话建立成功，消息发送端会根 据控制端设备传送的消息ID撤销形影的通知，并以不针对会话的信号告知网络中的 其它设备该消息通知已经撤销，此时，通知会从其它已经获取该通知的设备端撤销， 如果设备还没有获取相应的通知，那么就不会再获取相应的通知。如果会话建立不 成功，那么用户确认撤销的通知客户端就直接代替通知发送端告知外界该通知已经 被撤销。
＜初始化通知接收
服务端应用	服务端服务
~1~ I
| 发送通知|
1	1	发送通知	发送通知	.发送通知,发送通知.

1	1	忽略通知	1		1	J	J
1报销通知（通知发送1	1	1
1	1	1	端，消息ID） |	|	|
1	［建立会话
I	M	-	1	1	1	1
1	1会话建立成功1	1	1	1
।	1撤销通知（通知ID）’।	1	1	1
1	H	1	1	1	1
1	।取消 I	1	1	1
1	s销通知	।	撤销通知	1撤销通知1撤销通知1
■	I
3	*1	*1
1	1	1	如果无法连	| 撤销通知 |	撤销通知J
1	1	1	接到发送端 1
1	1	1	1	1	1
图3-17通知撤销流程
49
本智能家居系统不仅支持文本通知、多媒体通知也支持动作通知，网关和控制 设备在解析通知的时候，会根据通知中携带的响应对象路径是否为空来判定接收到 的通知是否为动作通知，如果为动作通知，在点击通知的时候，控制设备会通过 Control Panel调用总线方法响应通知。
3.6.7	设备控制模块
本智能家居网络对设备的控制主要通过三种方式，一是对于基本的设备信息， 比如设备名称、设备密码以及恢复出厂默认等基本操作都直接通过AllSeen的Config 框架进行，对于设备的控制有直接通过Control Panel机制控制，也有通过总线对象 及其对象路径以单点会话的形式控制，通知中携带的动作通过Control Panel控制。
3.6.8	AllSeen设备图标获取
为了帮助用户更好地识别不同的设备和提升系统的服务水平，本智能家居系统 在发现AllSeen设备时，将设备图标获取纳入了重点考虑范围。由于图标相对于设备 的其它信息而言是多媒体数据，因而处理相对较复杂。为了保证AllSeen设备能在各 种网络环境下显示最优的设备图标，本智能家居系统在图表部分设置了设备的默认 图标、静态图标和皿代表的网络动态图标三类。
默认图标是指设备不存在图标或是静态图标和url图标获取失败的情况下，智能 家居系统利用默认图标充当设备图标，默认图标由用户通过控制设备选取。静态图 标是设备在广播的时候广播出来的设备图标信息，由于静态图标需要在广播的时候 随着广播信息广播出来，因而静态图标往往采用大小限制在1K以内的jpg格式，让 智能家居系统中的设备广播静态图标是防止当控制设备获取不到设备广播中uri对应 的动态图标时退而求其次的解决方法。设备About信息中广播的图标url字段描述了 设备详细图标所在的url地址，这个地址对应的图标往往具有较高的清晰度，用户在 获取到相应的Url地址可以通过Http从网络中获取相关的资源。
由于硬件生厂商在后期可以通过修改uri地址对应的图片来灵活方便地更改设备 图标，因而在获取设备图标的时候，本智能家居系统本着优先获取设备url对应动态 图标的原则，如果无法获取动态图标则获取静态图标，如果这两个图标都获取失败， 则使用默认图标。
50
3.6.9	心跳机制
由于智能家居系统需要实时监控设备的状态以响应特定时间点对于某一个单独 设备的控制。所以本智能家居系统在控制设备端实现了专门的心跳机制来监控网络 中的设备在线状态。由于智能家居系统操作的主要对象为上线的标准设备和瘦客户 端设备以及未配置入网的瘦客户端设备，因而本文针对这两种情况设计了不同的心 跳机制实现方式。
由于未配置上线的设备在本质上是一个软AP,所以对于未配置上线设备的心跳 机制通过控制设备的Wi-Fi模块来实现，具体来说，控制设备会通过Onboarding的 scan( )API对于控制设备网络的附近的AP进行周期性扫描，具体时间通过 DEFAULT_HAERTBEAT决定。控制设备会注册相应的监听器来保持对Onboarding 的扫描结果的监听，如果接收到Onboarding九个状态之一的 OnboardingManager.EXTRA_ONBOARDEES_AP,且携带的设备列表消息不为空，则 代表控制设备周围存在未配置入网的瘦客户端设备。将这些扫描到的设备跟控制设 备在上一轮监听到的设备列表进行比较，就可以获取设备的新状态，
对于已经上线的标准设备和瘦客户端设备心跳机制的设计需要考虑系统内设备 底层的AllSeen通信方式。因为本智能系统中采用的部分硬件为市场上已有的AllSeen 设备，而另外一部分是智能家居系统开发的新的硬件，这些设备运行的AllSeen服务 框架版本存在一定的差异性，因而底层的通信流程也存在一定的差异，有的采用NS 进行服务的广播和发现，有的采用NGNS进行服务的广播和发现。为了保证本文设 计的智能家居系统能兼容这些采用不同底层通信方式的AllSeen服务框架的设备。本 文决定采用AllSeen服务框架的NGNS来设计本文的心跳机制从而满足对不同版本 硬件的心跳检测。
对于运行14.02版本或是基于NS的AllSeen设备，可以通过接收该设备的IS-AT 消息来实现。如果接收到IS-AT消息则认为该设备在线，如果连续三次都没有接收 到设备发送的IS-AT消息，则代表设备已经处于离线状态。服务客户端就会触发 LostAdvetisedName()方法将设备离线的状态传送到应用端。
由于AllSeen服务框架中，IS-AT消息的默认重传间隔为30s,基于IS-AT消息 机制的设备状态检测方式将导致90〜120s的时延，这对于绝大多数应用是无法容忍 的。因而在14.06版本中，AllSeen通过NGNS提出了一种更有效的设备状态检测方 法。这种方法由服务客户端通过单播信号实现。当近邻网络中某个服务被服务客户
51
端发现，服务客户端就可以通过调用相应的API来检测这个服务是否处于在线状态。
考虑到每个应用程序都有不同的设计逻辑，开发人员可能需要在不同的时间点 和逻辑点去检测其它设备的在线状态。AllSeen的NGNS将有关设备状态检测的部分 直接以独立接口的方式暴露出来以方便应用程序开发人员根据自己应用的逻辑去检 测设备状态。NGNS的检测API支持同步和异步两种模式，但从总线协议的角度来 看，这两种模式具有一样的消息序列。
本智能家居系统考虑到标准设备本身的硬件条件以及业务需求，最终决定采用 异步模式设计该系统的心跳机制，具体来说，控制端设备会开发一个设备管理器， 该管理器将存储发现的每一个服务端设备，并且周期性地利用AllSeen的Ping( )API 去检测每个设备的状态，并且会注册相应的监听机制，一旦发现某个设备掉线，该 设备管理器就会从设备列表中移除该设备。具体来说，对于已经配置了入网信息的 标准设备和瘦客户端，本系统框架对于单一设备单状态检测的消息序列主要如图 3-18所示：
消费端应用(NGNS)
图3-18控制设备检测基于NGNS的服务端设备在线状态流程
控制设备的设备管理器通过调用Ping接口根据WKN来检测某一服务设备是否 在线。如果服务端基于NGNS进行服务的广播和发现，那么标准设备将把网络中广
52
播的服务提供端的所有WKN记录在AllSeen的路由表中，在检测某一服务端是否在 线的时候，标准设备会通过单播消息查询服务端的状态；如果服务端在线，在接收 到该mDNS消息时，服务端的AllSeen路由就会通过D-Bus的Ping () API连接相 应的总线附件从而检测该服务应用的在线状态。如果连接成功，则通过mDNS回复 标准设备服务在线，否则将回复设备不在线。
另外一种情况是服务端的广播与服务采用基于名字系统的方式，那么该服务端 的路由就不支持Ping ()接口。此时服务端会给标准设备返回一个Ping接口没有实 现的异常，标准端设备的应用在接收到该异常之后就会调用基于NS系统的 FindAdvertisedName ()接口来检测该服务的在线状态，如图3-19所示。
服务端应用(NS)
消费端应用(NGNS)
AllSeen 应用
AdvertiseName ()
AllSeen核心库
Fi ndAdvert i sedName () LostAdvert isedName ()
AllSeen 应用
AllSeen核心库
命名服务
AllSeen 路由
NGNS
AllSeen 路由
周期IS-AT (名称)

通过NS找到名称：依靠周 期IS-AT信息确认存在
图3-19控制设备检测基于NS的服务端设备在线状态流程
3.6.10	异步事件”动作触发
目前AllSeen的事件-动作(Event-Action )机制只支持事件同步触发多个动作。 比如说，如果用户回到家把门打开，将门开当作一个事件，那么用户就可以根据自 己的需求为门开这个事件绑定相应的动作，现在假设用户为门开绑定了如下动作序 列，门开的同时，智能家居系统自动打开客厅的灯、电视和空调以及开启卫生间的 热水器。那么根据现在AllSeen支持的事件-动作机制，当门打开的时候，所有这些 动作会在瞬间被同时触发，也就是说用户会同时看到客厅的灯、电视和空调以及卫 生间的热水器被同时开启。这种联动机制虽然为智能家居的场景提供了更灵活丰富
53
的体验，但这种联动方式是单调的。如果用户想基于当前的事件-动作机制实现事件 在时间序列上离散触发动作则无法实现。但这种离散触发在现实生活场景发生频率 是极高的，比如用户在回家后需要打开客厅的灯、电视和空调，但是想要休息一个 小时后再进行洗浴，那就需要卫生间的热水器在半个小时候后再开启。那么此时， 标准设备就不能通过现有的事件-动作机制实现上述用户需求。因为现有的事件-动作 机制是同步触发模式，无法在该事件对应触发的动作组中添加半个小时后开启热水 器和关闭空调这两个动作。基于现有的机制，用户只能将开启卫生间热水器和关闭 空调这两个功能从门开这个事件绑定的动作组合中抽离出来，并在回家半个小时后 再手动操作这两个行为。显然这种同步模式下纷繁琐碎的离散操作要求较高的用户 参与度，这在某种程度上降低了智能家居系统的智能性。除了这个问题，现有的事 件-动作机制也不支持对事件绑定的动作组进行增、删、改、查的功能，考虑到用户 生活情景的多样性和易变性，对于这一功能的需求性不小。还是以上边的例子来阐 述，如果用户在休息十分钟之后，突然决定临时外出，那么用户就需要推迟卫生间 热水器的加热时间和提早关闭空调。然而，基于目前AllSeen中服务框架的事件-动 作机制，上述情景式是无法实现的。
为了解决上述问题，本文提出了一种基于AUSeen的具有CRUD功能的异步事 件-动作触发方法（CRUD： Create. Retrieve. Update. Delete代表增删改查）。该方 法为每一个事件创建一个带有计时器的动作组合，用户可以根据自己的需求为该动 作组合中的每个动作设定相应的触发时间，然后网关会根据每个动作设定的时间去 依次触发相应的动作，从而实现用单一事件在时间序列上离散异步触发多个动作。 除了引入计时器控制每个动作的执行时间。该方法还允许用户通过调用相应的接口 对特定事件绑定的动作组中的动作进行增、删、改、查的操作。使得AUSeen的事件 -动作机制更加灵活，为用户带来更好的服务体验。
为了实现该异步触发方法，需要网关暴露网络中各个设备的总线方法和总线信 号，并且提供基于事件创建相应动作组的接口，且网关需要携带一个计时器来帮助 网关在特定时间触发相应的动作，实现事件异步控制动作。网关创建时间-动作接口、 参数及实例分别如图3-20、3-21所示。
54
Action组创建接口	参数
creat eAct ionsGroup	triggerEvent
act ions []—
timers[]—
触发事件	异步Ac tion列			触发时间列
Event A	Action A	Action B	Action C	A 0s	B 0s	C1800s
门开	打开卧	打开客	打开卫生	相对	相对	相对
室灯	厅空调	间热水器	时间	时间	时间
图3-20网关时间-动作创建接口	图3-21网关时间-动作接口实例
需要指出的是图3-21中的动作组和计时组对于同一下标位置具有对应关系，即 相应下标的动作会在相应下标的时间后被网关触发。此外，网关还需要提供根据特 定事件查询相应动作组，并对该动作组的动作进行增、册k改等的接口，如图3-22 所示。在此需要注意的是，之所以选择在网关上开发相应的接口而不是在控制设备 上，是为了保证当控制设备离开网络时，网络也能根据设备设定的时间-动作组规则 进行特定的操作。
图3-22动作组管理接口	图3-23网关创建动作-事件组方案
图3-23描述了网关创建相应的事件-动作组的方案图。具体创建步骤如下：
(1)控制设备连入网关；
(2)控制设备和网关建立单点会话；
(3)网关将网络中设备的事件和动作接口暴露给控制设备；
(4)用户通过控制设备选择相应的事件和动作组，并为动作组中的动作设置 好相应触发时间并将这些参数传递给网关。
(5)网关接收到控制设备的请求和参数，调用网关的事件-动作组创建接口创 建相应的规则，并且将生成的规则绑定到规则引擎(RuleEngine)
(6)当网络中的设备触发事件-动作组中的事件，规则引擎和计时器根据创建
55
的接口参数开始同时制约和触发相应的动作。
下图3-24描述了事件-动作组的对动作的修改方案。具体修改步骤如下：
(1)控制设备连入网关；
(2)控制设备和网关建立单点会话；
(3)控制设备根据要修改的事件调用网关的事件-动作组查询接口，获取相应 的事件一动作组；
(4)用户通过控制设备输入事件-动作组的修改信息，并将这些信息传送给网 关；
(5)网关根据传送的数据信息调用网关的事件-动作组创建接口，根据新的数 据信息创建事件-动作组；
(6)网关将新创建的事件-动作组添加到规则引擎，并根据事件-动作组的触 发事件覆盖原有的事件-动作组，并实施新规则
图3-24网关修改动作-事件组中动作方案
3.6.11	AllSeen分布式代理
AllSeen是基于Client/Server的点对点的模型，因而在开发基于AllSeen服务框 架的移动应用时，需要通过在设备间建立会话进行通讯，下图3-25-a和图3-25-b分 别描述了 Wi-Fi协议和蓝牙协议下的AllSeen会话结构。
56
图3-25 a) Wi-Fi多点会话结构b)篮牙多点会话结构
如图3-25-a所示，当AllSeen服务框架采用Wi-Fi作为底层接入技术建立多点会 话时，会话拓扑结构成星型。在主机创建会话后，其后陆续加入的成员会按如上结 构分别与会话中先前的成员分别建立连接。由于链路的完整性，当会话中某一成员 可以按需选择是通过单播信号还是多播信号给其它成员或其它多个成员发送信号。 当AllSeen服务框架采用蓝牙作为底层接入技术建立多点会话时，会话拓扑结构如图 3-25-b所示会成发散型。在服务端创建会话后，其余陆续加入的控制设备会按上述 结构与服务端建立会话。当客户端需要给其它成员或其它多个成员发送信号时，则 需要通过主机进行单播或是多播转发，相对于Wi-Fi协议而言，采用蓝牙协议作为底 层通讯技术时，服务端在信息交流时损耗资源更多。
由于AllSeen服务框架采用的是服务端-客户端模式而非对等模式，充当服务端 和客户端的设备往往承担不一样的工作量，服务端需要比客户端承担更繁重的信息 交互，尤其在开发某些特殊的应用时，建立会话的主机在功能需求上也比加入会话 的客户端更多，比如主机需要承担交互系统的数据存储和逻辑功能的开发等相对耗 费资源的任务。如果此时采用的底层通信协议为蓝牙而非Wi-Fi,对于充当服务端的 设备硬件性能要求将更高。然而基于AllSeen服务框架的交互系统内的设备不是哑设 备，就是交互性较强的移动性可便携式设备，这些设备由于体积和成本方面的原因， 往往在CPU,内存，电量等资源方面都受到了一定的限制。
如果基于现有的AllSeen服务框架解决这一问题，可以将某些资源损耗性比较高 的工作移植到其它资源相对丰富的设备上，然后由这些设备承担数据存储、计算和 处理等工作，服务端和客户端只需要访问这些计算和处理结果即可。但该方案会增 加整个网络框架的通讯成本和结构的复杂性，并且也会降低应用的移动性，这是得 不偿失的。而且这种解决方式也没有实现网络中各设备资源使用的相对均衡。随着 开发应用越来越丰富的业务需求，资源损耗问题还是会暴露出来，影响到AllSeen服 务框架的进一步发展。
57
为了解决上述问题，本文提出了一种基于AllSeen服务框架的分布式代理方法, 如图3-26所示。该方法主要通过利用网络中其它设备的路由来分担服务端路由的工 作量。具体来说，网络中的设备路由会维护网络中所有可代理对象的列表（注：这 里的设备包括服务端设备和客户端设备）。在该方案中，认定只要两个路由都实现了 同一应用这两个路由就具备相互代理资格，由于该方案采用分布式结构，所以网络 中的每个可代理路由和服务端路由是等效的，在下文直接用主机应用代表当前正在 承担服务端功能的服务端或是代理客户端应用。
图3-26分布式代理流程
应用路由在运行时会实时检测自己设备的资源情况。在总线接收到总线方法的 调用或是总线信号的触发请求前，应用路由都会先判断自己的资源是否充足并根据 监测结果做出相应的处理。如果应用路由资源充足，那么应用路由就会自行响应相 应的业务请求。如果应用路由判断自己的资源不充足，那么应用路由就会进入请求
58
代理环节。路由不会将方法调用或是信号直接转发给应用而是会通过不针对会话的 信号在近邻网络中发送请求代理对象进行代理的请求信号，在发送完请求信号后， 该请求设备会在请求后保持120s的监听状态，等待网络中的可用代理设备响应。近 邻网络中可以代理的对象在接收到请求代理后将会判断自己是否具备代理条件：相 应资源是否在代理门限值以上，如果可以代理，代理客户端设备就会通过单播信号 对请求设备进行代理响应。请求设备端的路由在接收到代理对象的请求响应后将在 响应的代理对象中选择最佳代理对象进行代理。其中最佳对象的选择策略有两种， 一种是根据响应速度判断最佳对象，速度最快即为最佳，另一种是根据主项资源最 充足判断最佳对象。选定代理设备后，代理设备就会开始进行代理，并每隔30s便 向设备发送代理状况，直至代理工作完成。如果在120s的等待时间没有其余设备请 求代理，那么请求设备将自己进行处理。
通过该方法可以让闲置设备替代资源紧张设备承担部分工作量，从而达到平均 近邻网内各设备的资源使用情况，较少交互时间，提升交互速率，增强用户体验的 目的。
3.7	本章小结
本章主要介绍了智能家居系统的设计。首先，整体阐述了本文搭建的智能家居 系统的整体设计目标，然后根据该目标设定的各功能需要设计了系统的整体架构； 其次，详细介绍了该架构中不同类型的设备所承担的角色和分工并详细分析了各类 型设备的应用层框架；再次，控制设备作为整个智能家居系统的入口，负责和用户 进行交互，因而本章描述了控制应用的详细交互流程和深入分析了控制设备端本地 模式和云端模式的设计方式；最后，本章详细介绍了智能家居系统核心模块的实现 设计方案，包括设备的转换、发现、组网、通讯、控制、图标获取、心跳机制、异 步事件一动作触发和分布式多点会话。
59
60
第四章 基于AUSeen的智能家居系统实现与验证
本章根据第三章设计的智能家居系统方案，利用真实的智能家居产品和Arduino 开发板、定制网关以及安卓手机搭建了一套真实的智能家居系统。并对其中核心模 块的实现方案进行了详细阐述。此外，本章还基于搭建的环境针对本文的研究内容 和目标进行了多次测试和结果分析以验证本文研究内容的正确性和可行性。
4.1	核心模块实现
4.1.1	底层通讯基础
由于本智能家居系统需要实时监测设备的发现、掉线，以及接收和发送设备通 知，因而控制设备在开发功能时通过实现安卓系统的Application类将控制设备的准 备工作完成，包括完成设备管理器和通知管理器的初始化，保证在应用开启前，控 制系统的功能全部处于就绪状态，如图4-1所示：
public void mxtListenersO{
Wi5Util.getIns:anceO.ini:(th:s);
if(UZShared?referencesManaE*r.xsToSAcctpted(；. {
final String ke^torerileName^getAppEcationContextO
£• trileS treamPathC all) oyn_key s tore'*)
.getAbsolvtePathO;
DenceN lanagerlmp !.g*tln.stan:	?kn,S t orer ileN ame);
Nou5cationsMana£*fImpi.2e:In$tanceO-mit:.this);
图4-1控制应用启动前准备工作
设备管理器主要负责开启标准设备和瘦客户端设备的发现机制以及设备的心跳 机制，代码如图4-2所示：
Aj\lafta£er.g*dn$tance().in:t(c .keyS t orekeyStorer d*Name);
.AjMaxiager.getlnstanceO-onntctToAJO；
Onboardai£?vManager getlnstan:?." in::(m_ccctextTAj?^2anafer.gednstance. .gerBusAttachment 二二
图4-2设备管理器初始化工作
61
4.1.2	设备发现
a)已配置网络信息设备的入网发现
对于已经配置网络信息设备的发现主要是通过About机制实现的，其中设备管 理器会保持对总线上About信息的监听，如图4-3所示：
public class Aj'lan琴er unplements 且比ulLt逋?鲍丁[
@Overri 立
public void	Sttinf busName, find mt version, short port,
final AboutObjecOescriptionO objectDesonptions. final \£ap<String. Varian;〉abou:Data}{
new Thr±a&、/v RiamablefX
gCh,emde
public void n»0{
(!Z)^*ic^-anaferImpr.De\'ic£vIana£erItnpl.fe:Instance-O)
.onAimouncecientfbusName.pert.OtjectDesenptions.aboutData'.]
}).sranO；
图4・3已配置网络信息设备发现代码
并将监听到的信息转换为已配置网络信息设备的数据格式。需要强调的是，在 实现过程中，由于about广播的数据是〈String,Variant〉,在获取数据时需要注意数据格 式，将其转换为相应的类型。本智能家居系统已配置入网信息设备类数据成员如表 4-1所示：
表4-1已配置网络信息设备数据成员
数据字段	变量名
设备名称	friendlyNaine
总线名称	busName
端口号	port
总线对象描述	obj ectDescription
about元数据	aboutData
设备ID	deviceld
设备应用ID	uniqueld （唯一标识字段）
设备默认语言	defaultLanguage
62
续表4-1已配置网络信息设备数据成员
数据字段	变量名
设备名称	friendlyName
设备支持Uri	supportUrl
设备状态	status
b）未入网设备发现
对于未入网设备的发现，主要通过如图4-4所示的Onboarding机制的scan（）API 来实现。再通过注册的监听器对扫描结果进行数据抽象，本智能家居系统未入网设 备类数据成员如表4-2所示：
图45未入网设备发现核心代码
表4-2未配置网络信息设备数据成员
数据字段	变量名
AP名称	SSID（唯一标示符）
总线名称	AP信息：包含名称、类型、和信号强弱
设备状态	status：离线,在线已入网、在线未入网
4.1.3	设备组网
本智能家居系统主要通过Onboarding框架来实现设备的组网机制，通过对 Onboarding 九种不同的登陆状态：ERROR> CONNECTING_ONBOARDEE_WIFI. FINDING_ONBOARDEE、JOINING_SESSION, CONNECTING_TARGET_WIFI, VERIFYING_ONBOARDED, VERIFIED_ONBOARDED> ABORTING、ABORTED 分别处理，确保瘦客户端设备能连接到目标网络。具体组网的核心代码如
图4-5所示，其中onboardee代表未入网设备，target代表用户选择的目标网络， 对于入网设备和目标设备的连接事件和广播事件时间都分别设置为20、25s。
63
void runOnboardinsO (
OnboardmgX lanager.getlns tanoeQumOnb-oardinfC
new Onbo^rdmg Conftfuranen： Onboardee. ^*t5C onnectionTuneou:.
announcement Timeout.: aifet.wifiC otinec dotiTxiecut .annoimcecxent Timeout
}
图4・5未入网设备组网核心代码
4.1.4	设备转换
为了实现非AllSeen设备到AllSeen设备的转换，网关的转换模块主要包括如下 三个功能组件，分别为：兼容协议栈/接口、适配器、和转换桥，如图4-6所示。其 中兼容协议栈/接口主要实现了要兼容的非AllSeen通信协议栈或是接口，例如ZigBee 协议栈、Bluetooth协议栈、Z-Wave协议栈等，通过兼容协议栈或接口，网关可以实 现和这些非AllSeen设备的基础通信；适配器Adapter可以通过兼容协议栈/接口与非 AllSeen设备交互,主要负责将非AllSeen设备映射为虚拟AllSeen设备。转换桥Bridge 负责为适配器虚拟的AllSeen设备提供AllSeen的总线附件，并且将该虚拟设备及其 支持的服务广播到网关所在的网络中。通过这三个功能组件，位于AllSeen网络的设 备便可以成功发现由这些非AllSeen设备虚拟的AllSeen设备，并通过这些虚拟设备 控制相应的目标设备。
64
蓝牙
ZigBee
Zwave
设备1
设备2
设备1
设备2
设备1
设备2
图4-6非AUSeen设备转换系统架构图
4.1.5	设备图标获取
根据第三章设备图标的获取，可以知道为了保障每个设备显示最优的图标，本 智能家居系统为每个设备配备了默认图标、静态图标和动态图标，这三种图标在显 示优先级上为动态图标大于静态图标，静态图标大于默认图标。但由于动态图标需 要控制设备根据url从外网获取数据，而静态图标可以通过与设备建立会话从设备端 获取，默认图标则只要发现设备就可以获取。这三种的响应速度可以看出分别为默 认图标大于静态图标，静态图标大于动态图标。为了同时保证每个设备图标的质量 和响应速度，本智能家居系统在获取图标和显示图标采用两套截然相反的方法。其 中显示图标严格按照显示优先级来执行，只要存在质量更高的图标就进行替换，但 是在获取的时候会依据响应速度获取，当获取到更优质量的图标时，会发出系统通 知更换控制设备上响应的设备图标。
考虑到设备每次都需要建立新的线程去获取设备的静态图标和动态图标，其中 静态图标的内容、大小以及动态图标url的获取都需要和设备建立会话获取，因而可 以将静态图标和动态图标的获取线程放置在同一个线程中，且将与设备建立会话获 取的信息存储起来，防止获取图标失败时，每次需要建立新的会话来获取这些信息
65
以减少控制设备的资源损耗和提高响应速度。
本智能家居系统在开发的过程中，通过半个布尔字节来标志设备图标的获取状 态，0位为About Icon接口支持位，代表设备是否支持about,为false代表不支持 aboutlcon,为true代表支持Aboutlcon； 1位为About元数据获取位，代表控制设备 与设备建立会话获取icon元数据状况,为true代表获取成功,为false代表获取失败； 2位为静态图标获取位，代表静态icon获取情况，为true代表静态图标获取成功， 为false则代表静态图标获取失败；3位动态图标获取位代表根据url下载动态图标状 态，为ture代表动态图标下载成功，为flase代表动态图标下载失败。
本智能家居系统设备图标获取的实现逻辑如图4-7所示：
a）目标设备是否支持Aboutlcon,是跳转到b；否结束，设备显示默认图标
b）将About Icon接口支持位标记为1
c）与目标设备建立会话，成功跳到步骤e,失败跳到重试逻辑
d）与目标设备建立会话次数是否小于10,是跳转到步骤c,否跳转到重试逻辑 e）根据AboutlconProxy获取设备图标的元信息，包括静态图标数据内容和动 态图标的url,失败跳转到重试逻辑
f） About元数据获取标记位置为1
g）获取静态图标并表存，失败跳转到重试逻辑
h）静态图标获取位标记为1
i）更新设备显示图标为静态图标
j）根据获取的url地址下载动态图标，失败跳转到重试逻辑
k）动态图标获取位标记为1
1）更新设备为动态图标 重试逻辑流程
a）	About Icon接口标记位是否为L否跳转到获取逻辑a
b）	About元数据获取标记位是否为1,否跳转到获取逻辑c
c）静态图标获取位标记是否为1,否跳转到获取逻辑g
d）动态图标获取位标记是否为1,否跳转到获取逻辑j
66
图4-7设备图标获取逻辑流程
67
4.1.6	设置通讯
本智能家居系统主要通过Notification框架来发送和接收通知，为了保证实时性, 控制设备实现了 AllSeen服务框架的Notification机制，在应用启用前注册通知监听 器，从而保证当网络中有通知时，迅速响应。控制设备在接收到通知后根据通知类 型进行处理并将通知转换为系统通知。通知接收部分代码如图4-8所示。
public class NotiricationsManaferlmp! extends Broadcas^leceiver
implements	Notiucatioti^Iaiiagef{
@Ch'*rrid*
public void receh'e(Nonflcaticn notification) {
Stnng responseObiectPath^iiDtincation.fed<esponseObjectPath；：;
boolean ^-ithAcuon^^responseObjeccPath' =null'.-J:± 二 r”pon$?Object?a;h.i 正mptyC ：
^Jc(?fespons*Obj tz t?ath. equals! enoreC as K HnuUrt));
handleNotincationWithActiot!；no Hficam，;
}eke{
hand!eNot:5ca:ion；no:iScation);
图4-8设备通讯核心代码
4.1.7	设备心跳机制实现
a）已配置网络信息设备的心跳机制如下，设备管理器会在每一个心跳周期开启新的 线程去检测设备列表中的设备状态，控制设备将连接每一个设备去检测设备是否 在线，并根据检测的状态对设备状态加以更新，具体代码如图4-9所示。
68
boolean	opPmgmgC ,；
if(hean:beatSecci^s>3) {
戌 mqinJT 心：
m_p 瞧: ger =new TimefTPinglger");
tn_pin£Tnner. schedule A traedRate;
new TsmerTaskOf
gOenide
public void nm(){
fcrOe\ice de\ice:ge: AUDe\"ic*$0) {
De\Sc*Starns denoeStatus®dtxioe.eetStatusQ；
if( de vi»S unx<=D*\,ioe AVAIL AB LE denceS tanxs=D*\ioe. UN AV AIL AB LE | &vi8s【ani$==Oevi8 GONE)：
dexxe.pmz,^s\'nc;denc*.£e:On?mElisten«<j；
) ,0.heanb*a:Seconds* 1000);
)
retuni kasRumung;
j
图4-9已入网设备心跳机制核心代码
b)未入网设备的心跳机制则通过周期性发现周围的未入网设备，检测到和已有设备 交集部分则代表设备在线，否则代表掉线，具体示意图如图4-10所示。
public void scanQJ
m_OnboardmgTtmer= n*^ Timen' Onboarduin im*rK);
m_OnboardmgTnn«. $chedul*AtrDi*dRat *(ne^v Timer： a$kO {
@ Overri 击
public \oid nm0{
tiy{
Onboarding?v^ana£er.zetln$:anceC'.soanWifiO；
} catchO^'inDisabledrxception e){
updateTheU: IntenLAcnons-AJ-OX^TFI-DISASLED);
e.pnntStackTrace{；］
jL->JDE三'v."L. T" 11 -* Siz. *,»» ■
图4-10未入网设备心跳机制核心代码
69
4.2核心功能测试
4.2.1	设备发现测试
1）已配置网络信息设备的入网和掉线测试：
a）首先将 AllSeen 设备 wlOO gg 和 Hitache w5O 连接到 2801
b）关闭控制设备控制应用
c）将控制设备连接到家庭网络2801
d）打开控制应用，观察控制应用检测到的本地智能设备
e）关掉Hitache w50,观察控制应用检测到的本地智能设备
下图4-11-a和4-11-b分别为步骤d和f的观察结果，从图片可以看出控制设备
对于已配置网络信息设备的入网和掉线都有极高的敏感度。
体脸第
图4-11 a）已入网设备入网测试b）已入网设备掉线测试c）待连接设备入网测试d）待连接设备掉线测试
2）未入网设备发现和掉线测试：
a）首先将Hitache w50恢复出厂设置
b）打开控制应用检测网络中的未入网设备，并观察检测结果
c）关闭Hitache w50,观察检测结果
上图4-H-c和4-11-d分别为步骤b和c的观察结果，从图片可以看出控制设备可 以迅速发现近邻网络中的待连接设备和检测到这些未配置入网信息设备的掉线。
3） ZigBee设备发现测试
a）首先将ZigBee设备连接到定制网关
b）打开控制应用检测网络中的本地设备，并观察检测结果
70
下图4-12-a为步骤b的观察结果，可以看出转换模块可以将ZigBee设备转换为 虚拟AllSeen设备，此外转换模块本身还通过控制桥向外暴露自己的转换服务。
4.2.2	设备组网测试
1）已入网设备组网
a）将设备W100 gg和Hitache w5配置到网关所在的家庭网络2801
b）重启设备 W100 gg 和 Hitache w50
c）打开控制设备并将其连接到家庭网络2801
图4-12 a） ZigBee设备发现b）已入网设备组网测试c）未入网设备组网入口 d）未入网设备组网
上图4-12-b为步骤d的观察结果，从图中可以看出控制设备可以迅速发现位于 2801网络的设备WIOOgg和Hitache w50,可以得知对于已经配置过网络信息的设备 在启动后会自行加入配置的网络。（注：已经配置过网络信息的入网设备包括标准设 备和已经组网的瘦客户端设备） 2）未入网设备入网
a）首先将Hitache w50恢复出厂设置
b）打开控制设备，将控制设备连接到家庭网络2801
c）打开控制应用，检测周围的带连接设备，并仔细观察检测结果
d）配置设备入网，在此，直接选择家庭网络2801,点击下一步
e）确认配置，点击下一步
f）打开控制应用的首页，检测周围设备，仔细观察检测结果
71
上图4-12-c、4-12-d. 4-12-b分别为步骤c、d、f的观察结果，从图中可以看出 控制应用可以选择待连接的设备并将其配置到指定的目标网络，当完成配置之后， 控制设备和待连接设备都将连接到目标网络。
4.2.3	设备通知测试
a）首先清空控制应用的通知列表，使其为空
b）控制音乐播放器Hitachew50,使其播放张学友的《一千个伤心的理由》
c）控制设备会接收到一条系统通知
d）点开系统通知，控制应用跳转到消息列表界面
e）点击相应的消息，进入到通知的详情界面
下图4-13-a、4-13-b、4-13-c、4-13-d分别为步骤a、c、d、e的观察结果,从图 中可以看出控制应用可以接收网络中设备传送的通知，并获取通知的详情。
H
■MH
<1
No noUkution* to cfeplwy
D
You will receive notifications from the devices tn Nearby Devices on this screen
图4-13 a）已入网设备组网测试b）未入网设备组网测试c）未入网设备组网测试d）未入网设备组网测试
4.2.4	其它测试
1）通知接收效果测试
设备可以通过设备通知开关来选择是否接收通知与否，当选择接收相应设备的通 知，便可以选择接收的效果，通知铃声和震动，这两者是相互独立的，用户可以根 据自己的兴趣选择单一的效果或是组合效果，如图4-14-a、4-14-b所示。其中通知铃
72
声关联系统的铃声，用户可以自行选择，如图4-14-C所示。

家魁W阿
除量更新
设警通知
等，*爵。•一	，春膏 津»仃茶烟”菸。Q.	*51寿蠡・&，；满	怒＜s3	沏3・）。3石
-	⑥	-—	写， M
Now Maytnfl ■平凡之■-朴树 HA«ch<W5Q
How Playw>9 • *R2JB - M
枇小W50
Mow Ptaying ■平凡ZJB - M NltoCtxWMS
Mow Ptoyinfl ■平凡之IB -朴捌
UftacN W5G
Mow Ptoylno - TyNSQfl9a由
图4-14 a）通知效果设置入口1））通知效果设置c）通知铃声选择d）通知删除回撤入口
2）通知删除和回撤测试
对于接收到的通知，系统可以进行单条删除和回撤或是进行批量化操作，如图 4-14-d所示。需要注意的是虽然通知删除和通知回撤从用户的角度来看来并没有什 么差异，似乎这两者都是删除了通知，但其底层机制有明显的差异。回撤实现的是 第三章设计的回撤机制，当点击回撤时，系统会从通知发送方将通知删除掉，并通 知其它设备该通知不可获取，从而网络中的其它设备也将无法再获取该消息。而删 除消息，只要通知还在存活期内，网络中的其它设备就还可以获取该消息、。
3）家庭Wi-Fi设置测试

S型下午



图4-15 a）家庭Wi-Fi设置入口 b）家庭Wi-Fi配置界面c）家庭Wi-Fi密码输入d）家庭Wi-Fi配置
考虑到一般家庭里的网络数量远远少于设备数量，因而一般都会将多个设备配 置在同一个网络中，所以将某一个网络设置为家庭网络是有意义的。具体的设置过
73
程如下，首先进入到家庭Wi-Fi的配置界面，然后选择需要配置为家庭Wi-Fi的网络， 并且将网络的相关验证信息输入并保存。这样之后在配置设备的时候就可以直接选 择将家庭网络作为目标网络，具体示意图如图4-15-a.4-15-b>4-15-c和4-15-d所示。
4.2.5	控制设备黑屏
在对搭建的智能家居系统进行测试的过程中，发现当控制设备所处网络存在过 多设备时，控制设备就会存在黑屏现象。这严重影响了系统的稳定性。对此，利用 Eclipse工具仔细检测控制设备的硬件资源损耗，发现当所处网络中设备增多的时候, 控制应用中用于检测设备心跳机制和下载设备图标的线程也相应增加。尤其在设备 图标下载不成功的时候，设备中的线程数量会急剧增加。这会过多损耗控制设备的 硬件资源。由于本智能家居系统中选定安卓智能手机充当控制设备，所以控制应用 为运行在安卓系统的安卓应用，由于安卓应用在运行过程中当设备的硬件资源己经 过度损耗不能满足需求时，安卓应用后台便会自动杀掉应用的某些线程来释放资源, 如果释放的线程为控制应用的基础线程设备就会出现黑屏现象。为了解决这一问题, 就需要对控制应用中的线程进行管理和优化，本文提出的具体解决方案是将应用中 简短而繁琐的任务放在一个新开的线程池中而不是每次都针对具体的任务来创建新 的线程以避免重复创建和销毁线程的开销。然后，将已联网设备的发现机制和未入 网设备的发现机制与应用的相关交互界面联系起来，从而减小不必要的资源损耗。 此外，将心跳机制和设备图标下载线程都开启为后台线程，降低这两类线程的优先 级，在发生资源紧缺问题时，让系统优先考虑释放这两类线程，其中设备图标下载 线程的优先级比心跳机制的线程优先级更低。
4.3本章小结
本章详细介绍了智能家居系统的实现方案，并针对系统内的核心模块进行了多 次测试从而获取实验结果和数据验证本文研究内容的正确性。此外，本文还介绍了 本文研究过程中遇到的部分问题并提出了详细解决方案，进一步提升了系统的稳定 性。
74
第五章总结与展望
第五章总结与展望
5.1	论文工作总结
随着物联网技术的飞速发展和普及，智能家居领域作为物联网领域的黑马也迎 来了发展的新契机。本文在综合考虑了智能家居行业的特点、国内的发展现状和现 有技术特点这三个方面之后，以AllSeen服务框架为技术基础，设计和搭建了一套完 整的智能家居系统，并通过该系统框架对智能家居领域设备的发现、组网与通讯机 制进行了深入的研究。具体来说，本文主要完成了以下六项工作：
1）深入学习AllSeen服务框架，了解AllSeen服务框架的工作原理和底层通信细节， 为利用AllSeen服务框架搭建智能家居系统奠定了坚实的技术基础。
2）根据本文的研究内容和目标设计本文搭建的智能家居系统的整体架构，确定系统 内的设备类型以及各设备应用层的协议栈，明确设备间的通信流程和交互方式。
3）利用AllSeen服务框架根据设计方案搭建智能家居系统，为本文的研究奠定基础。 具体来说，在实现AllSeen服务框架的时候重点实现对AllSeen标准设备和 AllSeen瘦客户端设备的发现，联网和心跳机制检测，设备间的单点和多点会话 建立，和设备间的控制以及设备间的通知机制等在内的基础功能。
4）打破AllSeen服务框架目前只支持Wi-Fi协议的局限性，通过在该智能家居系统 中引入定制网关拓展AllSeen服务框架对ZigBee协议的支持，该定制网关的转 换模块可以将连接到该网关的ZigBee设备转换为Wi-Fi协议下的虚拟AllSeen 设备。从而实现该智能家居系统对ZigBee协议的支持。
5）提出合理的可行性方案改进当前AllSeen服务框架存在的一些问题，具体来说主 要包括以下两个方面的改进：将AllSeen服务框架现有的Event-Action机制拓展 为支持CRUD （增删改查）功能的异步触发机制；在现有的多点通信协议基础上 引入分布式代理的概念，以优化资源的配置和适应更复杂的功能需求环境。
6）提出和现有AllSeen Onboarding基础服务框架相一致的蓝牙哑设备组网方案，以 期为AllSeen服务框架提供一套完整的支持Wi-Fi、蓝牙和ZigBee等多协议的一 致性物联网通信网络解决方案，该方案通过借助带有图形界面和输入设备的标准 设备来实现蓝牙哑设备之间的动态组网，包括微微网和散射网。
75
5.2	进一步研究工作
本文通过搭建真实的智能家居系统深入研究了智能家居系统中设备管理和通讯 的机制，也利用测试结果验证了提出方案的正确性。但受限于项目整体时间和当时 能力，本文对于有些地方的研究和实现还不够深入，需要在今后的工作中继续改进： 1）当前控制系统负责的业务逻辑过多，很容易导致控制设备黑屏，后期需要考虑将 控制设备的部分业务逻辑转移到网关。
2）当前系统中的网关虽然会对网络中的设备操作进行日志记录，但是并没有对这部 分记录下来的数据进行任何分析和处理，在后期的研究工作中，可以考虑结合数 据挖掘技术来挖掘这部分数据的信息和规则引擎更好地相互配合,进一步提升系 统的智能性。
3）当前系统只支持Wi-Fi和ZigBee协议，但蓝牙协议在短距离通信也有着重要的 影响，市面上的蓝牙设备种类纷繁且数量也极其巨大，在后期的研究工作中，可 以进一步深入学习蓝牙协议，参考Zigbee转换模块的实现，实现本系统对蓝牙 协议的拓展。对于其它的优秀协议也应该纳入拓展考虑范围。
参考文献
参考文献
[1]周燕.简述无线通讯技术在数字化的应用[R].北京：中国新通信，2015: 109-110.
[2]刘云浩.物联网工程专业系列教材:物联网导论[M].第2版.北京：科学出版社, 2013.
[3]中国产业请研网.2016-2020年中国智能家居（智能住宅）行业市场分析及发展趋 势预测报告[R].北京:中国产业调研网.2016.
[4]洪水坤.闯出“互联网物流”的发展新路[J].中国储运,2015: 54-55.
[5]罗兰.基于融合视角的我国物联网产业发展研究[D],湖南：湖南大学.2011.
[6]搜狐.全球物联网整体法规与政策 [EB/OL].
http://mt.sohu.com/20160825/n465956573.shtml, 2016-08-25.
[7]唐云.物联悯时代的智能家居新生活[J].福建电脑,2014.
[8]刘陈昕：和慧家居控制技术的发展解析[J].信息通信.2015: 115-116.
[9]张川.资能家庭网络:技术、标准与应用实践[M].北京：人民邮电出版社.2014.
[10]李凌B含.靠于AllJoyn的异构物联网融合的研究[D].北京：北京邮电大学, 2016.
[11]	AllSeen-Aj|iance,
https://AHSeenaITiance.org/framework/documentation/leam/core/system-description/syste m-architecture, 2016.
[12]	AllSeen-Alliance.
https://AllSeenalliance.org/framework/documentation/leam/core/standard-core. 2016.
[13]	AllSeen-Alliance, https://AnSeenalliance.org/framework/documentation/learn/architecture. 2016.
[14]	ATTSeen-Alliance.
https://AUSeenalliance.org/framework/documentation/leam/core/thin-core, 2016.
[15]	AllSeen-Alliance, https://AllSeenalliance.org/framework/documentation/leam/glossary, 2016.
[16]郑琨.基于AllJoyn的智能家居网关开发与实现[D],北京：北京邮电大学. 2016.
[17]齐磊.基于AllJoyn的物联网控制系统的设计和实现[D],北京：北京邮电大学, 2016.
77
[18]刘彦美.基于AllJoyn的智能家居系统标准客户端研究[D].北京：北京邮电大 学,2016.
[19]李永华，王思野.AllJoyn技术原理及物联网程序开发指南[M].北京：清华大学 出版社,2016.
[20]	AllSeen-Alliance, https://AllSeenalliance.org/framework/documentation/leam/core/events-and-actions, 2016. [21] AllSeen-Alliance, https://AllSeenalliance.org/framework/documentation/learn/core/system-description/data-exchange, 2016.
[22]	AllSeen-Alliance,
https://AHSeenalliance.org/fraiTiework/docunientation/leam/core/system-description/adver tisement-discovery, 2016.
[23]	AllSeen-Alliance, https://AllSeenalliance.org/framework/documentation/leam/core/systeni-description/alljoy n-session, 2016.
[24]	AllSeen-Alliance,
https://AllSeenalliance.org/framework/documentation/leam/core/system-description/sessio nless-signal, 2016.
[25]	AllSeen-Alliance,
https://AllSeenalliance.org/framework/documentation/leam/base-services/onboarding, 2016.
[26]	AllSeen-Alliance,
https://AllSeenalliance.org/framework/documentation/leam/base-services/notification, 2016.
[27]	AllSeen-Alliance, https://AllSeenalliance.org/framework/documentation/leam/base-services/config, 2016. [28] AllSeen-Alliance, https://AllSeenalliance.org/framework/documentation/leam/base-services/controlpanel, 2016.
[29]李永华，高英，陈青云.Arduino软硬件协同设计：实战指南[M].北京：清华大 学出版社,2015.
78
参考文献
[30] Qi Lei, Lu Yueming, Li Yonghua. A centralized home gateway architecture based on the analysis of user log [A]. CCT [C], Beijing: 2014.
[31 ] AllSeen-Alliance, https://wiki.AllSeenalliance.org/gateway/dsb, 2016.
79
