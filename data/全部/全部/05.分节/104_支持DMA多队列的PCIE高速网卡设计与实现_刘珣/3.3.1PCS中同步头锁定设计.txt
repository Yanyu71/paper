3.3.1PCS中同步头锁定设计
目前对于这部分的设计普遍采用滑动窗口法，即通过滑动66bit的代码块对所 2bit的同步头进行判断。判断为有效同步头时，Index向后滑动66bit再次判断；当 判断为无效头时，Index向后滑动lbit重新进行判断。
上述方式在大概率下可以不重复的完成同步，但在小概率下会造成重复的同步 判断。由于PMA位宽是16bit或32bit或64bit,总小于66bit,需要对数据进行拼接， 即前文提到的RX变速箱的功能，而Index是RX变速箱中的一个滑动指针。RX变
25
速箱对数据缓存然后拼接成66bit进行发送，Sync_Block同步模块再对66bit进行同 步头的判断。当判断为无效头时，Sync_Block同步模块通知RX变速箱将Index向 后滑动lbit,但从Sync_Block同步模块向RX变速箱发出无效头反馈信息需要时延， 在这一过程中，RX变速箱一直在发送66bit的信息，对于发送多少个66bit无法掌 控，因此Sync_Block同步模块无法对刚刚判断错误的下一个66bit进行判断。有可 能正确的同步头的位置，就在这一过程进行发送，而Sync_Block同步模块已经略过 正确的同步头的位置。如图3-4所示。
图3-4同步头的重复判断
针对这一小概率问题，本文提岀一种基于滑动窗口的改进方式。即将当判断为 无效头时，并不会立刻通知RX变速箱将Index进行滑动，而是继续进行66bit的接 收，一直接收到上次判断为无效头的下一个66bit,这样可保证在进行判断时不会略 过正确的同步头的位置。在进行同步头的锁定过程中，同步头的位置固定重复出现， 即每一个66bit的正确的同步头的位置在经过一个循环周期后会再次出现在相同位 置，因此只需要跳过这个循环周期，并且再多接收一次66bit,即指向了下一个66bito 为避免长0或长1出现，规范规定同步头11或00为无效头，10或01为有效头，具 体设计如下：
滑动机制在本文特指两种滑动一横向滑动和纵向滑动，分别代表两个指针Index 和header_count,通过两种滑动完成同步头的锁定。首先，64bit的数据需要在RX变 速箱进行缓存，然后以66bit将数据进行发送，等待进行同步。为了提高同步效率, 对每次收到的66bit数据的第一、二位进行同步头的判断，如果为01或10,则 header_count+l。当header_count累加到指定数值后，表示完成同步头的锁定，即第 一、二位是同步头所在位置。如图3-5所示。
26
当header_count在未达到指定数值前，对66bit数据同步头的判断时发现了无效 头，则需要继续进行数据的接收，但此时不再做判断。假如在对第3个66bit判断时， 发现了无效头，则继续进行数据的接收，接满一个循环周期后，向下滑动，将第4个 66bit放在第一位置，即开始对第4个66bit进行同步头的判断。如图3-6所示。
图3・6判断失败时滑动示意图
27
当header_count持续累加到一定数值后发现无效头，这种情况出现次数累加到 指定数值后，Index开始进行横向滑动，即从第0位置向右滑动到第1位置，开始对 66bit的第二、三位开始判断，如图3-7所示。可以看出，Index的最大限度为65,即 从第0位置向右滑动到第65位置。通过以上滑动机制，通过硬件进行实现，可大大 减少同步头的锁定时间，提升整体效率，同时对于硬件实现要求不高，简化实现难 度。本部分内容将在第四章进行具体设计。
图3-7持续判斷失败滑动示意图
