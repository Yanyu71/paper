4.1.2RX通道
图4-5 RX通道接收数据
如图4-5所示a】，PMA层将64bit的数据发送到PCS模块，数据首先进入RX 变速箱进行位宽转换，RX变速箱结构不同于TX变速箱，RX变速箱为192bit位宽 的FIFO,将数据进行缓存然后以66bit位宽发送给Sync_Block模块。Sync_Block模 块负责锁定同步头，通过第三章设计的滑动窗口机制进行同步。在未同步之前，只传 送IDLE字符，且Sync_Block不会将这些数据发送到解扰器。完成同步后，数据进 入到解扰器进行解扰。解扰结束后，将66bits的数据发送到64b/66b解码器。64b/66b 解码器对同步头进行判断，按照附图1和2进行解码，最后发送到MAC层。
(1) RX变速箱
在接收过程中，需要对64bit的数据转换成66bit,需要进行位宽转换，RX变速 箱用以实现这个功能。RX变速箱不同于TX变速箱，由于Index在标识同步头过程 中，可最多指向第65位，从第65位向后截取66bit的数据需要13Obit位宽，在进行 滑动发送的时候，由于每次进64bit,但输出为66bit,每次输出都需要多发2bit,即 在发送第1个64bit时，需要占用第二个64bit的前2bit数据；在发送第2个64bit 时，需要占用第三个64bit的前4bit数据。当发送到第32个64bit时，又回到了发送 第一个64bit的位置，而这时需要向后取66bit数据，加上之前发送的64bit数据，至 少需要130bit的缓存大小，而又因数据以64bit为单位进入，因此向上取整，将RX 变速箱的缓存大小设置为64X3即192bit,如图4-6所示。并且其有一个用来标识同 步头的指针Index»主要功能是接收满192bit的数据后以66bit位宽将数据发给
39
Sync_Block模块，同时会收到Sync Block模块的反馈信息来将Index进行移位操作。 其具体工作原理同Sync Block在下面进行分析。
Index
V	192 	►
Block 2	Block 1	Block 0	”
I			n-
I
| 6 60 66 66 0 1
图4-6 RX变速箱内部结构
(2) Sync_Block 同步模块
Sync_Block模块用来确定数据里同步头的位置，由于66bit中的数据只有2bit的 同步头，需要接收方通过同步模块进行同步，本文结合实际情况将此模块原理设计 如下：
未同步之前，发送端会持续发送IDLE字符用于同步，即发送方会持续发送 2112bit (64X33)的数据块，在这个2112bit的数据块中，每个66bit的同步头出现 的位置相同。通过RX变速箱以192bit的FIFO对其进行缓存，并且按66bit的数据 发送到本模块。
Sync_Block模块会持续接收32个66bit数据，即收满2112bit数据。令收到第一 个的66bit为Block 0,并且假定第一位和第二位是同步头所在位置，如果第一、二 位是01或10,则将数据记录下来，并继续对Blockl做判断，直到判断完两个2112bit
步头的位置，如图4-7所示。
如果在header_count未达到64的时候，同步头出现了 11或00,则停止判断， 但仍要收满32个Blocko收满32个Block后，开始从Blockl的第一、二位进行同 步头的判断，counter+1 o当counter=32时，即滑动判断回到了 Block。，此时将通知 RX变速箱将Index后移一位，即从BlockO的第二、三位开始判断，并继续重复上述 操作，如图4-8所示。
40
图4-8同步头锁定失败流程
在最坏的情况下，即同步头在Block31的最后两位时，需要进行Index=65次判 断，也就是对2112bit的数据进行33X65次判断，如图4-9。其中所花费的时间为 2112X65X32+161130000827.2ms,通过硬件来做最多只需要27.2ms即可完成同
图4-9最长时间完成同步头锁定流程
(3) 解扰器
在Sync_Block模块锁定好同步头的位置后，接收和发送端结束同步阶段。此时， Sync_Block模块会将66bit数据发送到解扰器进行解扰。解扰器是扰码器的逆运算, 原理同扰码器一致。同样采用如公式4-1的多项式。对应的编码电路如图4-10所示 [32]
同样采用VHDL硬件描述语言进行RTL级的代码设计。
图4-10解扰电路
(4) 64b/66b 解码器
64b/66b解码是64b/66b编码的逆操作，采用查找表的方式完成解码。具体操作 为：首先对2bits的同步头进行判断，如果同步头为01,则表示64bits的数据为用户
41
数据，将8bits的控制信号全部译码为0,并和64bits的用户数据一起发送到MAC 层。如果同步头为10,则表示64bits中包含用户数据和控制字符，将8bits的控制信 号全部译码为1,并且需要按照附图1确定66bit数据中Block Type Field的种类进 行解码，并且按照附图2的控制字符对应表进行解码转换，从而得到64bits的数据， 与8bits的控制信号一起发送到MAC层。
