2.3.1Dijkstra最短路径算法
迪杰斯特拉（Dijkstra）算法于1959年提出，是一种计算起点到所有其他节 点最短路径的有效方案。Dijkstra算法以起点为中心向距离其节点最近的各节点
18
逐渐扩展，直至到达路径终点。Dijkstra算法采用了 “贪心”的策略，即每次都 查找与该点距离最近的节点，因此该算法也逐渐成为了搜索最短路径的代表性算 法。由于其搜索的依据是最短距离，所以该算法主要用于非负图的路径规划，这 也正与信道译码中最常见的计算欧式距离十分契合。
Dijkstra最短路径算法的基本思路如下：
1	.声明一个数组D来保存源点到各个节点的最短距离，一个保存已经找到 了的最短路径节点的集合T,和一个未确定最短路径的顶点集合U。
2	.将起始点s的路径权重被赋值为0 (D[s] = 0),若对于起始点s存在能 直接到达的边(s,m),则把D[m]设为M(s,m),同时把所有s不能直接到达 的节点的路径长度设为无穷大，所以在起始时刻，集合T中只有起始点
So
3	.从D数组中选择最小值，则该值就是起始点s到该值所对应的顶点的最 短路径，并将该节点加入到集合T中。加入新节点后，寻找新节点到达 其他顶点的路径值，并计算通过该节点到达其他店的路径长度是否比源 点拥有更小的路径长度，若小于源点到某节点的路径值则替换这个顶点 在D中值。
4	.从数组D中找到最小值，重复上述操作，直至集合T中包含图中所有节 点。
若一个拥有六个节点的无向图如图2-7所示。
利用Dijkstra算法搜索以A为起点经过所有其他节点到F的最短路径的步 骤如表2-1所示。
19
表2-1 Dijkstra算法搜索路径步骤
步骤	集合T	集合U
1	初始化A,此时T=<A> 最短路径A->A=0 以A为起点开始搜索	U=<B CDEF> A->B=6, A->C=3, A->others=oo A->C=3最小
2	选择C,止匕时T=<AC> 最短路径 A->A=0, A->C=3 以C为中间点，A->C这条路径 开始搜索	U=<B DEF> A->C->B=5, A->C->D=6, A->C->E=7 A->C->others=oo, A->C->B =5 最小
3	选择B,止匕时T=<ABO 最短路径 A->A=0 , A->C=3 , A->C->B=5 以B为中间点，A->C->B这条 路径开始搜索	U=<DEF> A->C->D=6,（丢弃 A->C->B->D=10）, A->C->B->others=oo A->C->D=6 最小
4	选择D,此时T=<ABCD> 最短路径 A->A=0, A->C=3, A->C->B=5, A->C->D=6 以D为中间点，A->C->D这条 路径开始搜索	U=<E F> A->C->E=7,（丢弃 A->C->D->E=8） A->C->D->F=9 A->C->E=7 最小
5	选择E,此时T=<ABCDE> 最短路径 A->A=0, A->C=3, A->C->B=5, A->C->D=6, A->C->E=7 以E为中间点，A->C->E这条路 径开始搜索	U=<F> A->C->D->F=9,（丢弃 A->C->E->F=12） A->C->D->F=9 最小
6	选择F,止匕时T=<ABCDEF> 最短路径 A->A=0, A->C=3, A->C->B=5, A->C->D=6, A->C->E=7, A->C->D->F=9 此时F已经到达终点，搜索结束	集合U已空，搜索结束
由上述Dijkstra算法（DA）的步骤可知，DA主要应用于选择一条从起始点 到终点的最短路径，在信道译码中它主要的应用场景就是格图。若不加改变，完 全按照Dijkstra算法实践，将会搜索格图上的所有节点，最终到达译码终点。虽 然这种寻找方法一定得到的是一条最短路径，且对于译码来讲一定是最优译码码 字，但是这显然违背了降低译码复杂度、简化搜索路径的初衷。所以，对Dijkstra 20
算法进行简化是必然之举。应当选择一个合适的决策方法，当从某一节点出发时， 不再盲目搜索与之相连的所有路径，而是有选择地尝试正确概率最高的路径，这 也就是我们为什么要研究A*启发函数(A* Heuristic Function) o
2.3.2	A*算法及其启发函数
A* (A Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法， 即依据某个或某些优化准则(如工作代价最小、行走路径最短、行走时间最短等)， 在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。我们的 译码算法运用了一种广义迪杰斯特拉算法(Generalized Dijkstra Algorithm ),即 利用人工智能最优路径规划的方式进行信道译码。
A*算法搜索整个译码格图的依据式(2-29)
/(m) = g(m) + /2(m)	(2-29)
其中f(m)表示从初始状态经由状态m到达目标状态的代价估计，g(m)表示 在状态空间中从初始状态到达状态m的实际代价，做m)表示从状态m到目标状 态的最佳路径估计，即前面所提到的启发函数。
A*算法也可以通过调用两个堆栈来进行，即Open List和Close List。其中 Open List用于存储已经比较过，但是尚未被纳入最短路径的节点，Close List用 于存储已经被判断为最短路径的节点。A*算法的步骤可以总结为以下几点：
1	.将起始点纳入Open Listo
2	.遍历Open List,查找f(m)值最小的节点，把它作为当前要处理的节点， 然后移到Close List中。
3	.对当前Close List中的节点的下一个相邻节点进行检查，若该节点不在 Open List中，则将其加入到Open List；若该节点已经在Open List中， 检查当前路径是否更近，如果是就对路径值进行更新并重新计算它的 4m)和/(m)值，并重新对f(m)值进行排序，如果不是就保持原值。
4	.判断译码终点是否加入到OpenList。若没有加入Open List,则继续执行 步骤2〜步骤4；若译码终点已经位于Open List中，则译码停止。
启发函数人(m)的选择会影响A*算法的行为：若/?(m)=0,则只有g(m)起作 用，此时A*算法演变成Dijkstra算法，这一定保证可以能找到最短路径。〃(m)越 小，A*算法扩展的节点越多，运行也就会越慢。最理想的情况即为力(m)精确地 等于从m移动到目标的代价，则A*将会仅仅寻找最佳路径而不扩展别的任何结 点，这会大大降低运行时间。尽管这种情况不可能经常发生，但仍然可以在一些 特殊情况下做到地相等。如果〃(m)过大，则A*不能保证找到一条最短路径，但 它可以运行得更快。所以，启发函数的选择需要在运行速度和运行精确度中做出
21
取舍。
1993年，YSHan等人将A*算法应用到线性分组码的译码中，其中定义了 一种可供参考的启发函数计算方法，将最小分支度量值与最小欧式距离的平方相 联系口叫 假设该线性分组码为二元码字，经过BPSK调制，在AWGN信道条件 下以下1传输。接收端收到的序列表示为0 = (%用,％…,%-J，经过证明可知， 若对接收序列进行排序将会减少其他分支路径计的数量，从而降低计算量，所以 对接收序列|0|进行从大到小排序。这是因为根据AWGN信道高斯分布特性可 知，距离干1越远，根据其符号进行译码错误的概率就越小。重排后的序列记为 9*=(现0；,脸...,心)，在实现中对该过程并行处理，其复杂度为O(kxn),其 中k为一组码字的输入比特数。同时用力=(£#；,唳…,v")表示根据“符号做 出的硬判决。由于位于0*中的前k比特码字为系统码，一旦确定，其后(n-k) 比特码字也就已经确定，所以只需要搜索前k比特码字，无需对后面的码字搜索， 直接计算得到即可。
当搜索到第匕比特时，A*算法的启发函数h(m)表示为：
["1 /	八2、
向11<2侬_(_11)> -1<£< k-1
"	7	"T	, \2
(T)") k-l<l<n
(2-30)
上式给出了 A*算法用于信道译码时的启发函数计算，式(2-30)表明，若译
码m是目标节点，则有h(m)=0。该启发算法需要计算欧氏距离的平方，在实现 层面上还有许多不便，1996年，LauraEkroot与SamDolinar又将式(2-30)做了 简化处理，得到了其等价形式口叫c：表示根据译码规则译出的码字，由式(2-31) 表示：
/7-1
MM =	(5的丰。)	(2-31)
/=0
上式省略了计算平方的步骤，且只有根据选择路径所译出的码字与硬判决结
果不同时才需要进行累加，若译出的码字与硬判决结果相同，所需加入的累积量 为0,这也极大减少了启发函数的计算量，为后续算法应用A*算法进行最短路 径的选择提供了更大的应用空间。
