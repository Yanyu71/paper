2.2.2FANO译码算法的改进
与Viterbi译码算法相比，Fano译码算法的优势在于Fano译码算法突破了卷 积码编码器约束长度的限制，使得译码复杂度与约束长度不再有指数增长的关系, Fano序列译码方式使得约束长度大于8的卷积码得以应用，这极大地提高了信 息传输的可靠性。
然而，Fan。序列译码算法还是存在一些劣势。第一，Fano序列译码算法的 搜索复杂度与信道噪声相关，当噪声较小时，其译码次数较少；相反，当噪声较 大时，其译码次数会极大增加，甚至有可能高于Viterbi译码算法，所以序列译码 更适合工作在高信噪比条件下。第二，Fano提出的序列译码算法并不是严格的 按照最大似然(ML)译码，Fano所提出的序列译码算法只是一种次最优译码方 法。2002年，Yiinghsiang S. Han等人对Fano译码算法进行改进，将费诺(Fano)
15
度量依据瓦格纳(Wagner)准则改进，从而使序列译码算法服从最大似然译码, 并进一步降低序列译码的算法复杂度。
由于这种新的度量值具有非负特性，这种新的序列译码方式能够使用和维特 比译码同样的网格图进行译码，而不是利用Fan。所提出的码树进行译码，也就
是说，在最坏的译码条件下(即译码信噪比较低)，这种改进的序列译码算法在 最差情况下译码搜索次数不会高于全路径搜索的Viterbi译码算法。当信噪比较 高时(一般大于3dB),在AWGN信道条件下，改进的序列译码算法平均计算 次数相较于Viterbi译码算法降低几个数量级。为了方便书写，将这种改进的Fano 译码算法称为 MLSDA〔2" (Maximum-Likelihood Soft Decision Sequential Decoding Algorithm)。
首先介绍MLSDA算法的分支度量计算。将一个卷积码用(n,k,m)表示，其 中k表示输入译码器的码元比特数，n表示输出的码字比特数，m表示编码中寄 存器个数，设L为输入信息比特长度，则输出码字长度表示为N2n(L + m)。之 前已经提到过，MLSDA将Fan。译码的码树图改为格图，即将码树图中相同状 态的节点合并，并且格图的起点和终点都是唯一的。卷积编码结果表示为v2 (v。，Vi，V2,	经过信道,接收端接收到的信息表示为r = (r0,rlrr2,
由接收信息r得到的硬判决结果为y =仇,心，…,弘-1)。
1 Pr,ID
硬判决依据式(2-21)的符号做出,
△ 力=
即
1,0 < 0
0, ^>0
(2-21)
(2-22)
y的伴随式可以表示为
△ T tT
(2-23)
其中H是编码矩阵的校验矩阵，E(s)表示所有伴随式为s的错误样式集合。
根据瓦格纳准则，可以找到如下e*e E(s)满足下式：
N—\	N-\
ZWMKIXMI	(2-24)
7=0	;=0
其中e e E(s) o 1983年，S.Lin和J.Costello等人对上式进行了证明，证明过 程如下：
假设利用ML译码算法，译码输出结果为£=/,其中/满足下式：
16
N\	*\2	N-1	2
E(^-(-i)j ?。厂(-1厂)
N-l	*	N-1
=£ 一 (一旷。厂E-(-1广我
7=0	7=0
O；£[(T)" -(T)"]圾 < ；Z[(-1)" -(-1)'"]%	(2-25)
乙j=U	乙y=0
N—l	N—1
O z(匕㊉u)同江(匕㊉V7)k|
7=0	产。
N—l	N-\
= £e：同空白同
产 0	7=0
由上式可以得到式(2-26)
£ = y㊉e*	(2-26)
由式(2-25)和式(2-26)可以得到新的比特度量：
〃(七)=(无㊉ xj ■	(2-27)
当译码时刻为/时，假设选择路径对应输出的译码结果为 %1)=(/当''…由式(2-27)可以得到整个路径的度量累积值：
.	. ln—\
(2-28)
7=0
式(2-28)即为MLSDA算法的分支路径度量。
MLSDA算法改善了 Fano度量，定义了一种新的分支度量方式。由以上论 述可知，度量值M%)是一个非负值，所以使用MQj)度量值判断分支路径，可以 使译码树搜索合并成为格图搜索，这样做可以极大降低实现中搜索出的分支路径 的存储空间。并且通过运用这种新的度量计算方式，可以将Fano顺序译码算法 由一种次优的译码方法变为可证明的最大似然译码方式。
基于格图的MLSDA顺序译码算法的步骤可以概括为以下5步：
1	.初始化一个名为Open的堆空间，将译码起始节点放入堆中，并将此事的 分支度量设为0。
2	.初始化另一个名为Close的堆空间，将位于Open堆栈中节点的所有基于 该状态的下一时刻幸存节点的度量值计算出来，选择当前Open堆栈中 最上方的节点。将该节点加入到Close堆中，同时删除Open堆栈中的该 节点。
3	.加入新的分支路径时，如果后续幸存节点位于Open堆栈中，比较两次 度量值大小，选择较小的值进行更新，若后续幸存节点已经位于Close堆
17
栈中，则直接丢弃新的路径，即一个比当前分支更好的路径已经被选择 了。
4	.将已经加入Close堆栈中的节点的后续幸存节点及其度量值插入到Open 堆栈中，该堆栈的按照度量值从小到大排序（所有度量值均为非负数）。
5	.当译码终点位于Open堆栈的最上方时，译码结束，否则，返回步骤2继 续译码。
前面介绍了一种基于Fano顺序译码的改进算法，通过改变Fano度量使得新 的度量值满足非负特性，并证明这种MLSDA改进算法满足最大似然译码策略。 在实现层面，Open堆栈空间和Close堆栈空间不可能开辟到无限大，这对于存 储空间和排序算法都是无法接受的。针对这个问题，可以采用固定堆栈大小的方 式，即预先设计好堆栈的最大深度，若堆栈超出预定长度，则删除该堆栈中最大 的节点数据（即最不可能成为最大似然路径的分支）来保证堆栈长度不大于预定 深度。
这种限制堆栈长度的方式在低信噪比下确实会造成一定的性能损失，但是这 种方法能保证在较高信噪比条件下译码性能和工程实现都能被接收，也极大地推 动了顺序译码算法在工程实践中使用。这种新的顺序译码算法，优化了深度优先 的顺序译码策略，使得后续基于Dijkstra最短路径思想的A*算法成为可能，并 为后续Turbo码的两个SOVA分量译码器降低计算量和减小存储空间指引了新 的方向。
