3.3.2.1Lazy.Viterbi译码算法步骤
对上述问题的探索已经在第222节提出的MLSDA算法中有所体现，为了 更适应SOVA软输出的特性，对第二章提到的MLSDA算法进行小幅度的修改， 提出了更适应SOVA算法的Lazy-Viterbi译码算法⑵】。
Lazy Viterbi译码算法中包含两个非常重要的计算模块，一个是译码网格图 (trellis),另一个是优先序列PQ (priority queue) □译码格图中的各个节点都 是从起始节点位置到当前节点的最短路径，在格图中每个节点u都有一个指针指 向它的前向节点Prev(u),且每一个节点都有其扩展路径，可以到达下一个节点 V。优先序列由一系列尾随节点(shadow nodes)组成。每一个尾随节点都是当前 节点的潜在扩展路径，使当前节点延展到下一个节点u。若用比来表示优先序列 中当前节点u的尾随节点，每个尾随节点都有一个累加度量值acc5)，其值表示 从u到&下勺路径度量，在优先序列PQ中的丘的排列顺序主要取决于accQ),将
40
PQ中的度量值acc(Q)按照从小到大排序，且每一个在优先序列中的尾随节点的 前向节点都必须保证已经位于格图向量中。
在译码的起始状态下，译码格图为空，优先序列中包含起始节点s的尾随节 点灯且有acc(§) = 0。译码开始后，优先序列PQ中不断有新的尾随节点插入， 每次选取优先序列中包含最小度量值的尾随节点，再将尾随节点插入到网格矩阵 中，使网格矩阵向译码序列的终点不断延展。若当前优先序列中的尾随节点已经 存在于网格之中，则丢掉该优先序列中的点，因为此时已经有距离更短的路径存 在于译码网格路径中；否贝IJ,对于网格矩阵中的新插入节点u, Prev(u) = Prev(u), 对于当前插入节点u的全部尾随节点v,。将被插入优先序列PQ,其度量值大小 为 acc(i5) = M + d(u, v)o
下面介绍Lazy-Viterbi译码算法的步骤：
1	.结合第222节提出的非负分支度量值d(u,v)的计算方法，计算所有可能 的输出符号的分支度量值；
2	.初始化优先序列PQ,在格图(trellis)中插入节点s；
3	.取出优先序列PQ中最小值所对应的节点(即位于PQ堆栈中最上方的 值)；
4	.若该节点已经位于格图中，则丢掉当前取出的节点，继续步骤3,否则将 该节点插入译码格图中，继续步骤5；
5	.计算新插入节点的路径度量值acc(。)，将该节点插入优先序列PQ中；
6	.如果优先序列PQ中位于顶端的节点不是译码终止节点，则返回继续执 行步骤3；
7	.回溯最大似然路径，输出最大似然路径对应的硬判决输出。
上述Lazy-Viterbi算法的译码步骤是由Jon Feldman等人与2002年提出，由 该算法的译码步骤可知，它的输出仍是硬判决结果。和1。为了适应适应SOVA 算法的输出，使其能够应用在Turbo码分量译码器中，对上述译码算法中的步骤 4做出修改，让它为SOVA算法的软输出提供信息。
更新步骤4：若PQ中取出的节点已经位于格图中，则计算当前存在与格图 中的最大似然路径度量值和当前竞争路径度量值的差，即笛=M2 - CMK
