4.4.2服务端消息陋
RocketMQ的部署结构如图4-13所示，其中涉及到了 RocketMQ的全部核心 组件，并且在该部署结构下的所有组件均可实现水平拓展。
图4-13 RocketMQ的部署结构
RocketMQ核心组件包括：
1	.生产者(Proucer)负责生产消息，向消息服务器发送由系统生成的消息。
2	.消费者(Consumer)负责消费消息，从消息服务器拉取消息并将其推送至 用户的应用程序中。
3	.消息服务器(Broker)是消息存储中心，主要作用是接收来自于生产者的消 息并进行存储，而消费者从这里拉取消息。
4	.名称服务器(Name Server)用来存储Broker的元信息，并给生产者及消费 者提供消息的路由信息。
消息中间件模块引入了 RocketMQ的消息队列，借助RocketMQ可以对数据 流量削峰填谷的特性，对来自于NB-IoT设备端的大量数据进行缓冲，完成了数 据解析与数据处理的解耦。本文设计的消息中间件模块是根据具体业务为数据对
46
象制定相应的Topic, Worker线程中调用RocketMQ的Producer把数据处理模块 中生成的数据对象缓存到RocketMQ消息队列中。在业务处理模块中，RocketMQ 的Consumer Group根据对应的Topic拿到数据对象，并在Consumer中执行其具 体的业务逻辑从而消费掉消息队列中的消息。但是，在请求密集的时间段， Producer会往消息队列中缓存大量的消息，此时，若Consumer处理缓存消息的 速度跟不上Producer生产消息的速度，将出现大量消息堆积的情况，因此本文 所述的服务器系统性能的另一瓶颈在于服务器消费者一端的消息处理能力。
在服务端业务处理的逻辑中，很多时候会存在复杂而耗时的数据库操作，其 中等待I/O处理往往会占用线程大量的时间，而如果使用消息队列当中的消费者 去处理中这些耗时的操作，将会存在消费者线程被阻塞的风险，一旦消费者拿到 了这些上报数据的处理权，但是又无力在合理的时间范畴内将其操作完毕，将会 触发数据回滚操作，造成数据重复消费等不良后果。为了解决上述的问题，本文 系统在服务端业务处理部分加入了业务线程池，采用多线程的方式处理数据库 I/O操作，用于接收及处理复杂而耗时的数据库操作，有效减少了 I/O等待时间 浪费的资源，提高了 CPU利用率。
系统服务端由Java语言搭建，Java语言从1.5版本开始可以通过Executor 框架来控制线程的启动、执行和关闭，极大地简化了并发编程的操作。该框架中 Executors类提供了 4种可以用于创建线程池的静态工厂方法，但是框架内自带 的线程池都存在一些比较明显的缺陷：会造成OOM异常或者是stack overflow 异常，因此本文服务端线程池采用自行定义的线程池来实现业务。自定义线程池 构造函数如图4-14所示。
public ThreadPoolExecutorfint corePoolSize,
int maximum PoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runable> wordQueue, ThreadFactory th read Facto ryz	；
RejectedExecutionHandler handler）	-
图4T4自定义线程池构造方法
在设置自定义线程池的最大线程数时需要避免极端情况的出现，最大线程数 设置过大，可能会导致出现较高的内存使用量，耗尽处理器的资源；最大线程数 设置过小，可能会导致消息处理不及时，系统的吞吐量及消息处理能力无法得到 提升。在实际应用中可以使用公式4-1来设置线程池的最大线程数，而核心线程 数值设置为最大线程数的20%o
thread = % * -。+ 勺	（4-1）
其中，Nthread表示线程池的最大线程数，而Ncpu表示处理器的核心数目，g
47
表示为预期的CPU使用率，w与t分别代表任务的理论等待时间及计算时间。
