3.4基于SCA的预编码
问题(3-5)是一个NP-hard问题，于是在工程应用中我们只有寻找具有低复杂度 的次优解。在优化问题中，约束条件形成凸集，仅目标函数为非凸函数。因此我们 可以利用对目标函数渐进凸逼近来求得局部最优解。
注意到函数iogdet(x)对变量xesq_+为一凹函数。通过一阶近似，凹函数 logdet(I + X)的上界为一线性函数 logdet(I+Xo) + tr((I + Xo)-1 (X-Xo))[38,39]o 注 意到当对目标函数logdet(N)I + ￡"M€KzH扇邱)使用一阶近似时，信息用户和速率 刀转化为一凹函数，由于凹函数可以轻易地转化为凸函数，因此该一阶近似对和速 率十分有效。
我们定义第i个信息用户经过第n次迭代后的发送协方差矩阵为SJ"),则信息用 户和速率的下界可以表示为
Rid > ￡ [logdet(I+^- ￡ H^Hf)
ieKx L	1N0keKx
-糸㈣”))T ￡ H’S网)—#) "o	k^i,keKx	-I
=襦({SJ)	(3-11)
其中Q?).表示第n次迭代时干扰加噪声的估计协方差，們表示第n次迭代时所得 的标量。
宓)=I+g E 晔?)邱	(3-12)
#)=logdet(宓))-#tr((州))T ￡ HXn)Hf) (3-13) 7V0	k/i,k^KT
由于logdet(I+志岛Hf)是凹函数且雄■((宓))一1￡皿心/母破)为线性 函数，因此R幣是凹函数。经过上述变换，我们将目标函数转化为凹函数。在(n + 1)次迭代中，我们通过求解如下所示凸优化问题来更新S,-,Vi € Kx
maximize^ ((SJ)	(3-14)
subject to ￡ tr(Sf) < Pt
i￡K工
4"(帳域)2 0,\/心￡
iEK工
S上0预e卮
容易看出该优化问题是一个凸优化问题,我们可以便捷地利用凸优化工具箱CVX[37] 来求解。我们可以将迭代算法概括如下表所示由于在每次迭代后目标函数不减且有
算法3.1基于SCA的预编码算法
1:初始化:S^=QyieKx.
2:设定:n := 1.
3:重复
4:	通过计算(3-14),计算S'VieKj：
5:	更新发送协方差矩阵：s￡")= S：, Vi G K工.
6:	增加迭代次数:n:=n+l.
7:直至收敛
8:通过计算S，")的SVD分解求得第i个信息用户的预编码矩阵B,?
上界，故该算法一定收敛到一局部最优解。然而为了确保最优解的可行性，必须有 rank(S;) < Mia
命题3.1假设S；是优化问题(3-14)的最优解，则rank(S? < Mh Vi e Kx.
证明：证明基于优化问题(3-14)的Karush-Kuhn-Tucker (KKT)条件。证明十分复杂, 将在我们之后的论文中给出。	口
命题3.2同等条件下基于SCA的预编码性能一定优于零空间预编码。
证明：由于在算法中我们初始化发送协方差矩阵为零矩阵，即S酔=O,Vi€位,因 此对所有幷曲都有必°)= I和班=0。此时若加上完全消除多用户干扰的约束条 件后，R倉({S,}) = ￡皿處det(I + ^HfSfHf)与优化问题(3-6)的目标函数完全相同。因此，基于SCA的预编码第一次迭代时的性能不亚于零空间预编码。此外在每 一次迭代后，目标函数R用({S，)不减，所以同等条件下基于SCA的预编码性能一 定优于零空间预编码。	口
当P?足够大时，优化问题(3-14)和(3-6)都是不可解的。事实上为了检验问题 的可行性，我们只需检验是否存在一个可行解可以同时满足所有约束条件。不失一 般性，我们可以通过令S = ￡左省,这样就变成了一如下所示的可行性问题
find S	(3-15)
subject to tr(S) < PT
S；0
尽管目前尚没有找到上述问题的充分必要条件的闭式解，然而我们可以通过求解如 下问题来确定问题的可行性
minimize PT	(3-16)
subject to tr (S) < PT
^(HjSH^>QjyjeK￡
S^O
上述问题是一个正定规划问题，可以方便地利用内点法来求解。我们定义最优解为 呼。显然，当PT>Pf时问题可解，反之则不可解。
