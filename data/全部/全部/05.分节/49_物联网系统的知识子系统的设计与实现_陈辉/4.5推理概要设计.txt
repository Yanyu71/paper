4.5推理概要设计
结合功能需求分析，推理模块的功能主要是利用一阶逻辑推理器来推理目标，通过 对新来的事件进行处理，然后推理证明目标是否成立。SMT理论求解器Z3的推理证明 功能主要釆用数理逻辑中以下过程：
基于已有的事实P,若要推理出Q成立，则是要证明P-Q的反不可满足。因为P -Q = -PVQ,其中Q是的目标,P是已有的事实，即已有事件处理之后的布尔表达 式。 P-Q的取反即是PA-Qo因此，想要证明P-Q成立，则需要证明PA-Q不可满足。 因为若上式为假，则可得P-Q为真。
SMT推理器Z3主要利用Solver对象进行推理和证明，Solver类是Z3推理器的主 类，其通过Context对象进行创建，Context是Z3提供一个包含Z3大部分对象和方法 工厂方法类。通过Context接口创建的布尔表达式对象都要加入到Solver对象中进行推 理，加入到Solver中的所有的一阶逻辑表达式都是以合取范式的形式存在。
通过将用户的目标处理成一阶表达式对象Q,已有的事件知识通过处理成一阶逻辑 表达式对象P,然后将P以及Q的逻辑反表达式对象都加入到同一个solver中，调用 solver的check。函数，如果结果等价于Status.UNSATISFIABLE则证明目标成立，反之 则表明无法证明目标成立。
整体推理流程图如下图4-14所示：
图4-14目标推理流程图
首先，因为用户的目标推理请求是原生的http请求模型，所以需要解析目标推理请 求。解析目标推理请求包括主题信息提取、知识对象映射、目标一阶表达式生成等任务。
1）	提取主题信息，然后利用此主题信息通过事件接入模块订阅相关主题信息以接 收事件，接收到的事件用于后续事件处理。
2）	知识对象映射，提取目标中的scope信息，通过映射生成知识对象。知识对象 对应知识库中的实例，也就是本体中类的实例。利用此对象查询本体知识库可以获取与 此对象实例相关的实例、数据属性、对象属性。这些关系和属性构成了一个包含概念， 属于描述逻辑中的包含范畴。然后利用描述逻辑与一阶逻辑的关系，通过翻译模块翻译 成为一阶逻辑表达式。用这些一阶逻辑关系可以推理新的事件知识对象是否属于目标推 理范围。
3）	目标一阶表达式生成o主要将目标中的参数和相关约束处理成一阶逻辑表达式。
约束对应了一阶逻辑推理库中的算子函数。比如等于、大于等于、小于等于、大于、小 于等等约束。结合出租车数据，scope对应道路信息，映射成知识库中的道路实例，此 道路实例由多个位置实例组成。这个关系由hasPosition组成，通过将已有的这些关系翻 译成一阶逻辑表达式，可以判断位置与道路的包含关系是否为真。	'
目标解析流图如图4-15所示：
结束
图4-15目标解析流程图
目标解析之后，首先需要接收订阅的事件，为了处理通过事件接入模块到来的事件, 首先要根据事件映射成为事件对象，这可以通过主题映射到爭件结构的方式实现，每一 个主题对应一个schema,根据schema确定事件的携带信息结构，然后解析生成具体的 事件对象。利用Java语言面向对象利多态的特点，实现一?个事件的抽象父类，然后对 应每一类具体事件实现相应的具体实现类。在系统内部维护一个事件主题信息到事件实 现类句的映射表，在Java中也就是维护…个HashMap<String, String〉，对这样可以迅速 的获取事件的实现类名。对于特定的事件，首先利用事件的主题信息获取对应的实现类 名，然后然后利用Java反射获取事件实现类的Class,通过此Class就可以动态的获取 事件实现类的构造函数。从而可以利用构造函数新建事件实例，完成事件信息到事件实 现类的转化。
事件对象生成之后，需要与知识库中的知识对象映射起来，所以需要实现事件对象 与知识对象的映射机制。首先需要实现知识库中的知识对应的Java类，同样，利用多 态特性，实现一个知识对象的抽象父类。抽象父类包含知识对象的唯一标识URI,此 URI也对应了本体中的本体标识符。然后需要实现不同知识对应的不同的实现类，利用 本体中的Position概念就可以用一个具体的实现类来表示，实现Position的相关坐标属 性，并利用类中的标识URI唯一确认知识类。有了知识类之后，需要提供几种将事件 类对象映射到知识类对象的方法，比如结合本论文建立的本体实例和深圳出租车数据， 出租车的坐标信息需要与本体中的Position概念进行关联起来，当一个出租车GPS事 件到来时，首先根据上述流程将事件转化为对应的具体事件对象类实例，此具体对象类 实例包含出租车具体的经度、纬度、速度等信息。为了将此事件类实例与Posigion概念 对应的实例进行映射，可以利用事件类实例的坐标信息和Position概念实例信息的坐标 信息来实现。如果事件类实例的坐标落在Position类实例的坐标范围之中，则说明此两 者对应。
结合Z3的Solver的特性，一旦有新的数据到来就应该更新推理器Solver的内容， 也就是添加BoolExpr对象到Solver中，在实际应用场景中，数据量可能会非常大，如 果每一个对象都加入到系统中进行推理就会造成服务器非常大的负荷。因此，当数据量 增大时，要考虑先过滤无用数据。所以在将事件映射成知识对象时如果发现事件无法对 应知识库中的知识则将事件对象及时的销毁，因为本课题主要采用java语言实现，所 以这可以通过将对象置为null并强制GC来实现。
爭件转化流程图如下图4-16所示：
图4-16事件转化流程图
事件映射为知识对象之后，需要知道知识对象是否处于目标推理的范围之内。只有 属于推理范围内的事件才有意义。如前所述，我们可以利用一阶逻辑推理来实现。在描 述逻辑中，包含概念是一种基本概念，在本体中定义也非常方便，比如，一个类有多个 部分组成，所以一个类的实例也有多个组成部分，这是最为常见的一种包含概念应用。 在本体的构建中包含关系在本体中已经定义好，本体也存储在本体知识库中。在目标解 析过程中，通过査询知识库将目标对象包含的范围中的实例都查询岀来。事件对应的知 识对象如果在这些实例中则说明属于推理的范围之内，如果不是则不属于推理范围之内。
范围推理流程图如下图4-17所示：
图4-17范围推理流程图
利用SPARQL查询知识库取出的相关的模型信息是OWL格式的，为了利用一阶逻 辑推理能力，需要将其进行转化处理成一阶逻辑表达式，也就是将OWL表示的知识转 化翻译为Z3中的一阶逻辑表达式。因为OWL格式和内容众多，如果直接翻译的话工 作量将会是非常巨大的，而且容易出错。结合本体的描述逻辑特性，我们可以参考本体 推理器的推理实现，本体推理器是基于描述逻辑进行推理的，为此可以获取本体推理器 在进行本体解析推理过程中的中间形式，这样可以免除翻译过程的繁琐的本体解析和分 类任务。例如本体推理器Hermit是利用OWL API并扩展接口来进行本体的解析、表示 和推理，利用本体推理器Hermit的API可以获取hermit的中间代码表示。
Hermit是少数的几个优秀的开源本体推理器之一，其源码都是由Java实现的，而 本系统各个模块均釆用Java实现，所以可以无缝集成Hermit的API。利用Hermit的 API首先加载本体文件或者输入流InputStream,加载之后会得到一个Ontology类对象， 此对象表示的是一个本体实例，实际上Hermit调用了 OWL API加载Ontology,而 Ontology类是0WL API提供的接口。然后，为了扩展0WL API以实现自己的算法。
Hemit利用此Ontology对象生成一个Reasoner类对象。在Reasoner类对象的生成过程 中，会将Ontology对象中的对象属性、数据属性、对象属性约束和数据属性约束等翻 译成Hermit内部表示形式。包括Atom、DLClause^ Role等对象实例。
本体解析和描述逻辑翻译成一阶逻辑表达式的流程图如下图4-18所示：
图4-18本体解析翻译流程图
在加载本体获得DLOntology对象之后，需要将对应的数据和对象属性约束翻译成 Z3中的函数。这些约束都包含在DLOngology对象的一个类型为Set<DLClause>的成员 属性中。将这些DLClause输入时的格式如下所示：
?<http://www.semanticweb.org/traffic-ontology#Road>(X)
<http://www.semanticweb.org/traffic-ontology#hasPosition>(X,Y)
?<http://www.semanticweb.org/traffic-ontology#Position>(Y)
<http://www.semanticweb.org/traffic-ontology#hasPosition>(X,Y)
单输入参数的DLClause表示一个参数属于什么类，两个参数的DLClause表示两 个参数之间的关系。比如<http://www.semanticweb.org/traffic-ontology#Road>(X)表示 X 是 Road 类的实例，<http:〃www.semanticweb.org/traffic-ontology#Position>(Y)表示 Y 是
Position 的实例 o |(lj<http://www.semanticweb.org/traffic-ontology#hasPosition>(X.Y)则表 示X和丫之间的:元关系。
Z3的函数与数学中的函数-样，有定义域domain和值域range。domain可以是… 个或者多个输入参数，这些参数可以是不同的类型，在Z3中用Sort接口来表示，具体 的有 IntSort、BoolSort、RealSort、UnintepretedSort 等等，分别对应整型、布尔型、实 数、非解释型。而值域只有一个，类型为上述类型中的一种。结合DLClause的格式， 在翻译过程中，将Z3函数值域都定义为BoolSort,然后分析DLClause的格式得到定义 域参数的个数，同时依据参数的类型确定Z3函数对应的定义域参数类型。因为DLClause 中包含许多重复的函数定义，所以需要维护一个Map以便去重。方便起见，Map的key 对应函数名，也就是DLClause中小括号前的字符串，Map的value即我们生成的Z3函 数。
翻译完函数之后，需要利用这些函数将本体中的Assertion也就是断言翻译成一阶 逻辑表示形式。本体中的断言是既有的事实，在DLOntology中，这些断言都处在一个 名为m_positivefacts的成员属性中，其类型为Set<Atom〉，将Atom打印出的形式如下 所示：
<http://www.semanticweb.org/traffic-ontology#hasPosition>(<http://www.semanticweb .org/traffic-ontology#福中路>,<http://www.semanticweb.Org/traffic-ontology#福中路 p2>)
显然，这也是一个函数形式，利用翻译本体生成Z3函数时得到的Map,可以迅速 的取得对应的函数，然后分别将参数实例化，并将函数应用在这些实例化的参数上。最 后将函数应用结果断言为TRUE而成为一个布尔表达式，所有这些布尔表达式就构成了 推理的前提。如果新加的布尔表达式与前提相矛盾，则说明新加入的布尔表达式不成立。
因为目标事件需要一定的时间窗口来推理出目标事件，比如拥堵需要利用一段时间 内的事件进行推理。所以需要一个缓冲队列来缓存属于目标事件推理范围内的事件，每 一次推理都将整个队列内的事件对象一起推理。因此，事件如果经过范围推理属于目标 事件的推理范围，则将事件对象加入到目标事件对象的缓冲队列之中，并适时的将缓冲 队列队头的数据移除出去。
目标事件发现流程图如下图4-19所示：
困4-19目标事件发现流程图
用户的目标定义，经过处理同样会生成一阶逻辑表达式。每个目标由一个Solver 负责。每一次推理，将属于目标的缓冲队列内的所有事件对象依次遍历，根据事件对象 生成的一阶逻辑表达式会依次添加到相关的Solver中，然后调用对应的Solver的check() 接口获取推理结果值，此结果值表示了是否发现目标事件，从而对事件作出响应。推理 结果需要存储到数据库中持久化以便结果展示时获取。
