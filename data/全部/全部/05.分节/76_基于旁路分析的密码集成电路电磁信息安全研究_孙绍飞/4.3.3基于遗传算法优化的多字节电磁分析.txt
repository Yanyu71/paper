4.3.3基于遗传算法优化的多字节电磁分析
基于遗传算法优化的多字节电磁分析(Multi-Byte ElectroMagnetic Analysis based on Genetic Algorithm, MBEMAGA)主要是将多目标优化与遗传算法相结 合，并成功应用到相关电磁分析中。多目标优化广泛应用于我们的日常生活和大 多数工程优化问题中，是一个向量函数的优化问题向量函数值的比较比标 量函数值的比较要复杂的多。在理想情况下，多目标优化要求每一部分的目标函 数值都是最优的。
解决多目标优化问题的方法有很多种，最重要的方法是将多目标优化问题的 解转化为合适的解来进行求解。通常可分为两种方式：一种是重构新的目标函数， 将问题转化为新目标的求解；二是将多目标优化问题转化为多个单目标优化问题。
本文采用第二种方式将多字节电磁分析与多目标优化问题进行结合，其数学 模型可描述为
FWmax = [A(Xi)/(X2),…/(XJ7	(4 一 29)
s.t. ftCXt) E [-1,1]
X = [X1,X2r-,Xi\
Xt = [x1(x2,-,xn]
Xn e (0,1}
其中，向量适应度函数尸(X)max= [A(X1)/(X2),“/(M)F的目标是实现所有子 目标函数的极大化，尸(X)为128比特完整密钥的相关系数；%(X。是第i个字节
79
子密钥的目标函数或适应度函数，即密钥第i个字节的相关系数。
遗传算法以种群为基础的方式适于求解多目标优化问题。结合二者的优点, 我们将多目标遗传算法应用到CEMA中Ml,按照如下方式进行结合：
（1）随机产生一组包含n个128比特的初始密钥作为初始种群中的个体，
即 key_candidate 1, key_candidate 2, …，key_candidate n；
（2）依据子密钥的目标函数将种群中的全部个体平均分成一些子种群，即 subkey 1, subkey 2, …，subkey 16;
（3）在每一个子种群中分别计算相应的子密钥的适应度函数subFitness；
（4）在每个子种群中按照轮盘赌的方法选择子密钥适应度值高的个体来组 成新的子种群；
（5）在每个新的子种群中执行交叉算子和变异算子的操作；
（6）对新的子种群进行重组，计算向量适应度函数尸（X）,并寻找出多目标 优化后向量适应度值高的个体进入下一代的进化；
（7）该过程经过多次循环迭代，直至选出满足条件的密钥后停止。
基于遗传算法优化的多字节电磁分析单次迭代循环的过程如图4-14所示。
图4-14遗传算法优化多字节电磁分析的基本流程
基于遗传算法优化的多目标电磁分析被用作CEMA的替代方案，使用多字 节作为目标，而不是使用一个字节来恢复密钥。在标准遗传算法的基础上，我们 增加了排序算子和筛选算子应用于多字节电磁分析中来助力最优解的搜索。排序 算子将子种群中的个体按适应度降序排列，使不同子种群中较好的候选子密钥排 在前面，能够以较大的概率组合在一起生成最优候选密钥。筛选算子主要执行如 下操作过程：选择一个临时最优密钥keyjemp,将密钥候选解与临时最优密钥
80
keyjemp进行对比，如果二者之间存在某个字节不同，则对临时最优密钥 超匕彭如进行替换，如果替换之后的适应度值比之前的要高，则对其进行更新, 否则依然保留的Je”不变，直至最后一个密钥候选解比对完成。
算法4・2给出了基于遗传算法优化的多字节相关电磁分析的基本流程。
算法4-2基于遗传算法优化的多字节相关电磁分析______________________________
Input； 最大遗传代数种群大小NCVD,交叉概率尸°,变异概
率Pm
Output：密钥最优解 key_optimal
1： key_cand = Initialization(7\®VD);	〃初始化所有个体
2： subkey_cand = T)ivide(key_cand);	〃密钥个体切分
3 ：	Sub¥itnGss(subkey_cand);	〃计算所有子密钥的适应度函数
4：	gen = 0;
5：	keyjright = 0;
6：	while gen < genjnax	and keyjright =	0 do	〃循环迭代优化
7 ：	Seleciion(subkey_cand);
8 ：	Crossover^ 汕物尸°);
9：	Mutatioii(s"麻纱
10：	SubFitness(subkeycand);
11：	Sort(subkey〃子密钥适应度排序
12：	key_cand = Recombme(subkey_cand); 〃子密钥重组
13：	Fitness(tey_cand); 〃计算完整密钥的适应度
14 ：	Selection(氏y_caM；
15 ：	key optimal_cand = MaxF itii^s(key_cand); //选出最优密钥
16：	gen = gen + 1;
17：	If VertiGc^tion(key_optimaljcand) = true	then
18：	key_optimal = key_optimalyand}
19：	key_right=l;
20：	Endif
21：	end while
22：	if (key_right=Q) then
23：	key_optimal = Sieve(key_optimal_cand);	〃密钥个体筛选
24：	end if
25 ：	return key optimal
81
