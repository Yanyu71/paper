2.1.6变形技术
每当运行变形技术(Metamorphism)处理的恶意代码时，它将改变装入内存的操 作码并且写入新版本的恶意代码到宿主机。恶意代码依然保持具有恶意行为，但 是其字节序列却与在内存中的原始操作码不同。所以常规的基于签名的方法需要 用百万个签名来扫描恶意代码。变形技术根据是否使用交互通道可以分为开放型 和闭合型两种。
1.开放型变形技术。开放型可以和网站进行交互并自动下载更新。2008年 Con^cker蠕虫迅速蔓延，被感染的主机大都使用了开放式交互，即微软的RPC漏 洞。Conficker利用50000个域和500个URL建立了一套完整的指挥和控制结构卩°】。
2,闭合型变形技术。闭合型并不依赖外部的交互来进行变异。在变化过程 中，可执行文件自行变异它自身或使用伪码来展示新变异生成的恶意代码。在32 位系统下的Apparition就是第一个使用闭合型变形技术的病毒。
一旦感染宿主机，恶意代码制造者就能利用多种策略来对恶意代码进行变形, 包括给每个访问过恶意网站的访客一个不同的模糊处理的病毒或变异的病毒。通 过感染主机传播的恶意软件必须支持自发变异来躲避检测。然而，开放型恶意软 件能够根据一些新特征自动进行更新，例如新代码支持变异，并且每次运行都能 够生成新版本。这也常被称作动态代码模糊。变形技术与其他恶意代码伪装技术 相比更为复杂，其执行可以分为下述五步：
首先，用反汇编器解析操作码。Windows是~*个IA-32(Intel Architecture,32 位)的处理器。也就是说它有丰富的指令集，并且许多操作码结合大量的操作数 和操作，可以执行完全相同的任务。另外，IA-32支持变长和扩展的操作码，导 致打包和解码操作码与操作数变得异常复杂；然后，为防止代码的持续增长，用 一个压缩程序压缩反汇编的代码。剩下未被压缩的代码将会成因太占空间而被剔 除出去；第三，置换程序会把原始指令以随机的顺序重新排布，并以jmp操作码 来进行连接，寄存器和操作码也被替换；第四，用扩展程序将原始操作码指令进 行重新编码，例如加入良性操作码nop。每次运行变形程序都会执行这一步，由 此生成新的恶意代码；最后，汇编程序会重新编码恶意代码，计算新加入的jmp 和call指令，并且重新计算jmp和call指令的地址。对于一段伪码，汇编程序会将 上述内容反汇编到目标操作码中。’
14
图2-4变形前后的库函数操作码对比
图2.4所示为kemel32动态链接库中的GetModuleHandle()函数，其中左边的为 原始代码，右边的为变形转化的代码，从图中可见，变形前后操作码的差异极大， 使用基于签名的扫描器进行检测难以应对变形处理的恶意代码，对于这种恶意代 码伪装技术，有必要引入新的检测方法。本文提出的检测方法即是在这种背景下 产生的，对于变形化的代码具有较好的检测效果。
